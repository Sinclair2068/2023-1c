

----QUIT----(20 March 2023 11:15:29) CuisUniversity-5706.image priorSource: 4313282!

----STARTUP---- (20 March 2023 11:15:29) as /Users/hernan/Documents/Cuis/5.0-64Bits/Cuis-University-Installer/CuisUniversity-5706.image!


----QUIT----(20 March 2023 11:15:30) CuisUniversity-5706.image priorSource: 8712809!

----STARTUP---- (26 April 2023 08:16:09) as F:\CUIS University ISW1\CuisUniversity-5706.image!


----End fileIn of E:\ISW1\Parciales\2022\2C\Primer parcial\ISW1-2022-2C-1erParcial.st----!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 08:34:28'!
PASSED!

Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:36:48'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:36:55'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:37:01'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:39:56'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:40:00'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:40:07'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Pirate category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:40:15'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 08:40:18'!
PASSED!

Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terrain category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:45:20'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:45:37'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:45:41'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Diggable category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:45:48'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Terrain methodsFor: 'nil' stamp: 'AS 4/26/2023 08:47:50'!
moveIn: aPirate
	
	self subclassResponsibility ! !
!Tree methodsFor: 'nil' stamp: 'AS 4/26/2023 08:49:27' overrides: 50604717!
moveIn: aPirate
	
	^aPirate moveToTree! !
!Pirate methodsFor: 'nil' stamp: 'AS 4/26/2023 08:50:14'!
moveToTree

	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 08:54:02'!
canMoveCorsario
	
	^false! !
!Empty methodsFor: 'nil' stamp: 'AS 4/26/2023 08:54:45'!
canMoveCorsario
	
	^true! !
!Diggable methodsFor: 'nil' stamp: 'AS 4/26/2023 08:55:00'!
canMoveCorsario
	
	^true! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 08:55:17'!
canMoveCorsario

	self subclassResponsibility ! !

!classRemoval: #Tree stamp: 'AS 4/26/2023 08:57:35'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Empty stamp: 'AS 4/26/2023 08:57:35'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Diggable stamp: 'AS 4/26/2023 08:57:35'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Terrain stamp: 'AS 4/26/2023 08:57:35'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Filibustero stamp: 'AS 4/26/2023 08:57:36'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Corsario stamp: 'AS 4/26/2023 08:57:36'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Bucanero stamp: 'AS 4/26/2023 08:57:36'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Pirate stamp: 'AS 4/26/2023 08:57:36'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Map stamp: 'AS 4/26/2023 08:57:36'!
Object subclass: #Map
	instanceVariableNames: 'island startPosition steps treasureMarkPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Island stamp: 'AS 4/26/2023 08:57:36'!
Object subclass: #Island
	instanceVariableNames: 'boardSize treesAt digsAt crewAt treasureAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Crew stamp: 'AS 4/26/2023 08:57:37'!
Object subclass: #Crew
	instanceVariableNames: 'island pirates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #CrewTest stamp: 'AS 4/26/2023 08:57:37'!
TestCase subclass: #CrewTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

----End fileIn of E:\ISW1\Parciales\2022\2C\Primer parcial\ISW1-2022-2C-1erParcial.st----!

Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:58:20'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:58:27'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 08:58:33'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Corsario methodsFor: 'nil' stamp: 'AS 4/26/2023 09:01:23'!
moveTo: aTerrain at: aPosition
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:02:15' prior: 50605171!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [pirate moveTo: terrain at: aPosition].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:02:19'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:02:19'!
PASSED!
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:04:32'!
moveTo: aTerrain at: aPosition in: anIsland

	aTerrain = #Tree ifTrue: [ 
				anIsland clearTerrainAt: aPosition.
				^false
			].
	aTerrain = #Empty ifTrue: [ ^true ].
	aTerrain = #Diggable ifTrue: [^true ].! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:05:30'!
moveTo: aTerrain at: aPosition anIsland: in 
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:05:30' prior: 50605462!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [pirate moveTo: terrain at: aPosition anIsland: anIsland].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!methodRemoval: Corsario #moveTo:at: stamp: 'AS 4/26/2023 09:05:30'!
moveTo: aTerrain at: aPosition
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].!
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:05:30' prior: 50605525!
moveTo: aTerrain at: aPosition anIsland: in 
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:06:34'!
moveTo: aTerrain at: aPosition in: in 
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:06:35' prior: 50605535!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [pirate moveTo: terrain at: aPosition in: anIsland].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!methodRemoval: Corsario #moveTo:at:anIsland: stamp: 'AS 4/26/2023 09:06:35'!
moveTo: aTerrain at: aPosition anIsland: in 
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].!
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:07:34' prior: 50605582!
moveTo: aTerrain at: aPosition in: anIsland 
	
	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true
		].
	aTerrain = #Diggable ifTrue: [ ^true ].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:08:52' prior: 50605592!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [acc := acc & pirate moveTo: terrain at: aPosition in: island].
		
		(pirate isKindOf: Filibustero) ifTrue: [acc := acc & pirate moveTo: terrain at: aPosition in: island].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:08:56'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:08:56'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:08:56'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:08:56'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:08:56'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:08:56'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:08:56'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:08:56'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:09:10'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:10:07' prior: 50605641!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [acc := acc & (pirate moveTo: terrain at: aPosition in: island)].
		
		(pirate isKindOf: Filibustero) ifTrue: [acc := acc & (pirate moveTo: terrain at: aPosition in: island)].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:10:10'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:10:10'!
PASSED!
!Bucanero methodsFor: 'nil' stamp: 'AS 4/26/2023 09:11:25'!
moveTo: aTerrain at: aPosition in: anIsland

	aTerrain = #Tree ifTrue: [ ^false ].
	aTerrain = #Empty ifTrue: [ ^true ].
	aTerrain = #Diggable ifTrue: [ ^true ].! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:11:52' prior: 50605695!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.
		
		(pirate isKindOf: Corsario) ifTrue: [acc := acc & (pirate moveTo: terrain at: aPosition in: island)].
		
		(pirate isKindOf: Filibustero) ifTrue: [acc := acc & (pirate moveTo: terrain at: aPosition in: island)].
		
		(pirate isKindOf: Bucanero) ifTrue: [ acc := acc & (pirate moveTo: terrain at: aPosition in: island)].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:11:55'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:11:55'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:12:25' prior: 50605753!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.	
		acc := acc & (pirate moveTo: terrain at: aPosition in: island).		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:12:27'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:12:27'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:13:45' prior: 50605801!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	
	pirates do: [:pirate | pirate moveTo: terrain at: aPosition in: island].
	"
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.	
		acc := acc & (pirate moveTo: terrain at: aPosition in: island).		
		ix := ix + 1.
	].
"
	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:13:51'!
FAILURE!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:13:51'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:13:51'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:13:51'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:13:51'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:13:51'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:13:51'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:13:51'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:14:16' prior: 50605841!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	
	pirates do: [:pirate | acc := acc & (pirate moveTo: terrain at: aPosition in: island)].
	"
	ix := 1.
	
	[ix <= pirates size] whileTrue: [ | pirate |
		pirate := pirates at: ix.	
		acc := acc & (pirate moveTo: terrain at: aPosition in: island).		
		ix := ix + 1.
	].
"
	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:14:20'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:14:20'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:19:36' prior: 50605884!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	
	"pirates do: [:pirate | acc := acc & (pirate moveTo: terrain at: aPosition in: island)]."
	acc := pirates inject: true into: [:move :pirate | move & (pirate moveTo: terrain at: aPosition in: island)].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:19:44'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:19:44'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:20:57' prior: 50605927!
moveTo: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.

	"nos movemos si todos pueden moverse"	
	(pirates inject: true into: [:acc :pirate | acc & (pirate moveTo: terrain at: aPosition in: island)]) ifTrue:	[
		 island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 09:21:00'!
PASSED!

Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terrain category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 09:21:54'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 09:22:11'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 09:22:16'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Diggable category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 09:22:22'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 09:24:00' prior: 50605745!
moveTo: aTerrain at: aPosition in: anIsland

	^aTerrain canMoveBucanero
! !
!Empty methodsFor: 'nil' stamp: 'AS 4/26/2023 09:24:30'!
canMoveBucanero

	^true
! !
!Diggable methodsFor: 'no messages' stamp: 'AS 4/26/2023 09:24:55'!
canMoveBuscanero
	
	^true
! !
!Tree methodsFor: 'nil' stamp: 'AS 4/26/2023 09:25:10'!
canMoveBuscanero
	
	^false! !

!classRemoval: #Tree stamp: 'AS 4/26/2023 09:56:45'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Empty stamp: 'AS 4/26/2023 09:56:45'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Diggable stamp: 'AS 4/26/2023 09:56:45'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Terrain stamp: 'AS 4/26/2023 09:56:45'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Filibustero stamp: 'AS 4/26/2023 09:56:45'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Corsario stamp: 'AS 4/26/2023 09:56:45'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Bucanero stamp: 'AS 4/26/2023 09:56:45'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Pirate stamp: 'AS 4/26/2023 09:56:46'!
Object subclass: #Pirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Map stamp: 'AS 4/26/2023 09:56:46'!
Object subclass: #Map
	instanceVariableNames: 'island startPosition steps treasureMarkPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Island stamp: 'AS 4/26/2023 09:56:46'!
Object subclass: #Island
	instanceVariableNames: 'boardSize treesAt digsAt crewAt treasureAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Crew stamp: 'AS 4/26/2023 09:56:46'!
Object subclass: #Crew
	instanceVariableNames: 'island pirates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #CrewTest stamp: 'AS 4/26/2023 09:56:46'!
TestCase subclass: #CrewTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

----End fileIn of E:\ISW1\Parciales\2022\2C\Primer parcial\ISW1-2022-2C-1erParcial.st----!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:35:52' prior: 50606494!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	pirates do: [:pirate | 
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		ix := ix + 1.
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:35:54'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:35:54'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:36:29' prior: 50606741!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	pirates do: [:pirate | 
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:36:32'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:36:32'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:40:34' prior: 50606800!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := pirates inject: true into: [:acc2 :pirate | 
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc2 & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc2 & true 
			].
			terrain = #Diggable ifTrue: [ acc2 &  true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc2 & false
			].
			terrain = #Empty ifTrue: [ acc2 & true ].
			terrain = #Diggable ifTrue: [ acc2 & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc2 & false ].
			terrain = #Empty ifTrue: [ acc2 & true ].
			terrain = #Diggable ifTrue: [ acc2 & true ].
		].
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:40:44'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:40:44'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:36:29' prior: 50606858!
moveTo: aPosition

	| acc ix terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.
	ix := 1.
	
	pirates do: [:pirate | 
		
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				acc := acc & true 
			].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				acc := acc & false
			].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ acc := acc & false ].
			terrain = #Empty ifTrue: [ acc := acc & true ].
			terrain = #Diggable ifTrue: [ acc := acc & true ].
		].
	].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:45:09'!
move: pirate to: aPosition in: terrain
	
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [ ^false ].
			terrain = #Empty ifTrue: [ 
				pirate drawDirectionTo: aPosition.
				^true 
			].
			terrain = #Diggable ifTrue: [ ^true ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [ 
				island clearTerrainAt: aPosition.
				^false
			].
			terrain = #Empty ifTrue: [ ^true ].
			terrain = #Diggable ifTrue: [ ^true ].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ ^false ].
			terrain = #Empty ifTrue: [ ^true ].
			terrain = #Diggable ifTrue: [ ^true ].
		].

	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:45:13'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:45:13'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:46:38' prior: 50606914!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	acc := acc & pirates do: [:pirate | 		self move: pirate to: aPosition in: terrain].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:46:39'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:46:39'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:48:21' prior: 50606995!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	acc := pirates do: [:pirate | 		acc := acc & self move: pirate to: aPosition in: terrain].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:48:22'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:48:22'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:48:48' prior: 50607032!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	pirates do: [:pirate | 		acc := acc & self move: pirate to: aPosition in: terrain].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:48:49'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:48:49'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:48:49'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:48:49'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:48:49'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:48:49'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:48:49'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:48:49'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:49:27' prior: 50607069!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	pirates do: [:pirate | 		acc := acc & (self move: pirate to: aPosition in: terrain)].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:49:29'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:49:29'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:50:20' prior: 50607106!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	pirates inject: true into: [:acc1 :pirate | 		acc1 & (self move: pirate to: aPosition in: terrain)].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:50:21'!
FAILURE!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:50:21'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:50:21'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:50:21'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:50:21'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:50:21'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:50:21'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:50:21'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:50:37' prior: 50607143!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	acc := pirates inject: true into: [:acc1 :pirate | 		acc1 & (self move: pirate to: aPosition in: terrain)].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:50:38'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:50:38'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:51:01' prior: 50607181!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := true.	
	acc := pirates inject: true into: [:canMove :pirate | 		canMove & (self move: pirate to: aPosition in: terrain)].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:51:31' prior: 50607219!
moveTo: aPosition

	| acc terrain |
	
	terrain := island terrainAt: aPosition.
	
	acc := pirates inject: true into: [:canMove :pirate | 		canMove & (self move: pirate to: aPosition in: terrain)].

	"nos movemos si todos pueden moverse"
	acc ifTrue: [ island crewAt: aPosition ].
	
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:52:06' prior: 50607232!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [:canMove :pirate | 		canMove & (self move: pirate to: aPosition in: terrain)].

	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].
	
	! !

Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 13:52:35'!
Pirate subclass: #Bucanero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 13:52:41'!
Pirate subclass: #Corsario
	instanceVariableNames: 'rank map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 13:52:46'!
Pirate subclass: #Filibustero
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:54:05' prior: 50606946!
move: pirate to: aPosition in: terrain

	^pirate moveTo: aPosition in: terrain at: island

	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:54:09'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:54:15'!
ERROR!
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:54:27'!
moveTo: aPosition in: terrain at: anIsland 
	self shouldBeImplemented.! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:55:20' prior: 50607327!
moveTo: aPosition in: terrain at: anIsland 

	terrain = #Tree ifTrue: [ ^false ].
	terrain = #Empty ifTrue: [ 
			self drawDirectionTo: aPosition.
			^true 
		].
	terrain = #Diggable ifTrue: [ ^true ].
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:55:22'!
ERROR!
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:55:29'!
moveTo: aPosition in: terrain at: anIsland 
	self shouldBeImplemented.! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:55:55' prior: 50607346!
moveTo: aPosition in: terrain at: anIsland 

	terrain = #Tree ifTrue: [ 
				anIsland clearTerrainAt: aPosition.
				^false
			].
			terrain = #Empty ifTrue: [ ^true ].
			terrain = #Diggable ifTrue: [ ^true ].
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:55:57'!
ERROR!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:56:03'!
moveTo: aPosition in: terrain at: anIsland 
	self shouldBeImplemented.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 13:56:28' prior: 50607365!
moveTo: aPosition in: terrain at: anIsland 
	
	terrain = #Tree ifTrue: [ ^false ].
	terrain = #Empty ifTrue: [ ^true ].
	terrain = #Diggable ifTrue: [ ^true ].
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:56:30'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:56:37'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:56:39'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:56:39'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:56:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:56:41'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:56:42'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:56:43'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 13:58:22'!
PASSED!

Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Terrain category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 14:00:05'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Tree category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 14:00:15'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Empty category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 14:00:21'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Diggable category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 14:00:26'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:02:36' prior: 50607371!
moveTo: aPosition in: terrain at: anIsland 
	
	^terrain canMove: self to: aPosition at: anIsland
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:02:40'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:03:07'!
ERROR!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:05:45' prior: 50606626!
terrainAt: aPosition

	| ix |
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ Tree new].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ Diggable new].
		ix := ix + 1.
	].

	^ Empty new.
	
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:05:51'!
ERROR!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:10:46' prior: 50607476!
moveTo: aPosition in: terrain at: anIsland 
	
	^terrain canMoveBucanero: self to: aPosition at: anIsland
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:10:54'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:10:57'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:11:16'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:11:51'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:12:00'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:12:44'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:13:00'!
ERROR!
!Tree methodsFor: 'no messages' stamp: 'AS 4/26/2023 14:15:16'!
canMoveBucanero: aBucanero to: aPosition ar: anIsland
	
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:15:23'!
canMoveCorsario: aBucanero to: aPosition ar: anIsland
	
	^false! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:15:32'!
canMoveFilibustero: aBucanero to: aPosition ar: anIsland
	
	^false! !
!Empty methodsFor: 'no messages' stamp: 'AS 4/26/2023 14:16:12'!
canMoveCorsario: aCorsario to: aPosition at: anIsland
	
	^true
! !
!Diggable methodsFor: 'nil' stamp: 'AS 4/26/2023 14:16:22'!
canMoveCorsario: aCorsario to: aPosition at: anIsland
	
	^true! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:17:38' prior: 50607528!
moveTo: aPosition in: terrain at: anIsland 
	
	^terrain canMoveBucanero: self to: aPosition ar: anIsland.

! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:18:05'!
canMoveBucanero: aBucanero to: aPosition at: anIsland
	
	^false! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:18:05' prior: 50607646!
moveTo: aPosition in: terrain at: anIsland 
	
	^terrain canMoveBucanero: self to: aPosition at: anIsland.

! !

!methodRemoval: Tree #canMoveBucanero:to:ar: stamp: 'AS 4/26/2023 14:18:05'!
canMoveBucanero: aBucanero to: aPosition ar: anIsland
	
	^false!
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:18:39'!
canMoveBucanero: aBucanero to: aPosition at: anIsland
	
	^true! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:19:08'!
canMoveBucanero: aBucanero to: aPosition at: anIsland
	
	^true
! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:20:01' prior: 50607333!
moveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveCorsario: self to: aPosition ar: anIsland
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:20:10'!
canMoveCorsario: aBucanero to: aPosition at: anIsland
	
	^false! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:20:10' prior: 50607678!
moveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveCorsario: self to: aPosition at: anIsland
	! !

!methodRemoval: Tree #canMoveCorsario:to:ar: stamp: 'AS 4/26/2023 14:20:10'!
canMoveCorsario: aBucanero to: aPosition ar: anIsland
	
	^false!
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:20:46'!
canMoveFilibustero: aFilibustero to: aPosition at: anIsland
	
	^true! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:21:01'!
canMoveFilibustero: aFilibustero to: aPosition at: anIsland
	
	^true
! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:21:11'!
canMoveFilibustero: aBucanero to: aPosition at: anIsland
	
	^false! !

!methodRemoval: Tree #canMoveFilibustero:to:ar: stamp: 'AS 4/26/2023 14:21:11'!
canMoveFilibustero: aBucanero to: aPosition ar: anIsland
	
	^false!
!Terrain methodsFor: 'nil' stamp: 'AS 4/26/2023 14:21:41'!
canMoveFilibustero: aFilibustero to: aPosition at: anIsland

	self subclassResponsibility ! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:21:51'!
canMoveBucanero: aBucanero to: aPosition at: anIsland

	self subclassResponsibility ! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:22:02'!
canMoveCorsario: aCorsario to: aPosition at: anIsland

	self subclassResponsibility ! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:22:19' prior: 50607710 overrides: 50607719!
canMoveFilibustero: aFilibustero to: aPosition at: anIsland
	
	^false! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:23:06' prior: 50607352!
moveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveFilibustero: self to: aPosition at: anIsland! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:23:08'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:23:08'!
FAILURE!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:23:08'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:23:08'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:23:08'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:23:08'!
FAILURE!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:23:08'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:23:08'!
PASSED!
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:24:19' prior: 50607738 overrides: 50607719!
canMoveFilibustero: aFilibustero to: aPosition at: anIsland
	
	anIsland clearTerrainAt: aPosition.
	^false! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:25:08' prior: 50607641 overrides: 50607731!
canMoveCorsario: aCorsario to: aPosition at: anIsland
	
	aCorsario drawDirectionTo: aPosition.
	^true! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:25:27'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:25:27'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:25:27'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:25:27'!
FAILURE!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:25:27'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:25:27'!
FAILURE!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:25:27'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:25:27'!
PASSED!
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:25:52' prior: 50607784 overrides: 50607731!
canMoveCorsario: aCorsario to: aPosition at: anIsland
	
	^true! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:25:58' prior: 50607637 overrides: 50607731!
canMoveCorsario: aCorsario to: aPosition at: anIsland
	
	aCorsario drawDirectionTo: aPosition.	
	^true
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:26:15'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:26:15'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:26:15'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:26:15'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:26:15'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:26:15'!
FAILURE!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:26:15'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:26:15'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:26:49'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:26:49'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:26:49'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:26:49'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:26:49'!
FAILURE!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:26:49'!
FAILURE!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:26:49'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:26:49'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:26:51'!
FAILURE!
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:31:49' overrides: 16901772!
= anObject

	^anObject = #Diggable
! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:32:00' overrides: 16901772!
= anObject

	^anObject = #Empty! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:32:09' overrides: 16901772!
= anObject

	^anObject = #Tree! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:32:18'!
PASSED!

!methodRemoval: Crew #move:to:in: stamp: 'AS 4/26/2023 14:34:50'!
move: pirate to: aPosition in: terrain

	^pirate moveTo: aPosition in: terrain at: island

	
	!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:34:50' prior: 50607244!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [:canMove :pirate | 		canMove & (pirate moveTo: aPosition in: terrain at: island

	
	)].

	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].
	
	! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:35:09' prior: 50607928!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [:canMove :pirate | 		canMove & (pirate moveTo: aPosition in: terrain at: island	)].

	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:35:14'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:35:14'!
PASSED!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:36:06'!
canMoveTo: aPosition in: terrain at: anIsland 
	
	^terrain canMoveBucanero: self to: aPosition at: anIsland.

! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:36:06'!
canMoveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveCorsario: self to: aPosition at: anIsland
	! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:36:06'!
canMoveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveFilibustero: self to: aPosition at: anIsland! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:36:06' prior: 50607941!
moveTo: aPosition

	| moved terrain |
	
	terrain := island terrainAt: aPosition.
	
	moved := pirates inject: true into: [:canMove :pirate | 		canMove & (pirate canMoveTo: aPosition in: terrain at: island	)].

	"nos movemos si todos pueden moverse"
	moved ifTrue: [ island crewAt: aPosition ].
	
	! !

!methodRemoval: Bucanero #moveTo:in:at: stamp: 'AS 4/26/2023 14:36:06'!
moveTo: aPosition in: terrain at: anIsland 
	
	^terrain canMoveBucanero: self to: aPosition at: anIsland.

!

!methodRemoval: Corsario #moveTo:in:at: stamp: 'AS 4/26/2023 14:36:06'!
moveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveCorsario: self to: aPosition at: anIsland
	!

!methodRemoval: Filibustero #moveTo:in:at: stamp: 'AS 4/26/2023 14:36:06'!
moveTo: aPosition in: terrain at: anIsland 

	^terrain canMoveFilibustero: self to: aPosition at: anIsland!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:36:09'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:36:09'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:37:02' prior: 50606458!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate |
	
		(pirate isKindOf: Corsario) ifTrue: [ 
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [ 				pirate drawTreasureMarkAt: aPosition ].
		].
		
		(pirate isKindOf: Filibustero) ifTrue: [
			terrain = #Tree ifTrue: [].
			terrain = #Empty ifTrue: [].
			terrain = #Diggable ifTrue: [].
		].
		
		(pirate isKindOf: Bucanero) ifTrue: [
			terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
			terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
			terrain = #Diggable ifTrue: [ island receiveTreasureAt: aPosition ].
		].
	].
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:37:05'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:37:05'!
PASSED!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:39:24' prior: 50608053!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate |
	
		pirate buryTreasureAt: aPosition in: terrain.
	].
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:39:30'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:39:30'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:39:30'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:39:30'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:39:30'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:39:30'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:39:30'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:39:30'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:39:32'!
ERROR!
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:39:46'!
buryTreasureAt: aPosition in: terrain 
	self shouldBeImplemented.! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:40:18' prior: 50608142!
buryTreasureAt: aPosition in: terrain 

	terrain = #Tree ifTrue: [].
	terrain = #Empty ifTrue: [].
	terrain = #Diggable ifTrue: [ 				self drawTreasureMarkAt: aPosition ].
! !

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:40:20'!
ERROR!
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:40:26'!
buryTreasureAt: aPosition in: terrain 
	self shouldBeImplemented.! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:40:45' prior: 50608160!
buryTreasureAt: aPosition in: terrain 

	terrain = #Tree ifTrue: [].
	terrain = #Empty ifTrue: [].
	terrain = #Diggable ifTrue: [].
! !

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:40:47'!
ERROR!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:40:53'!
buryTreasureAt: aPosition in: terrain 
	self shouldBeImplemented.! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:42:16'!
buryTreasureAt: aPosition in: terrain at: anIsland

	terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
	terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
	terrain = #Diggable ifTrue: [ anIsland receiveTreasureAt: aPosition ].! !
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:43:25' prior: 50608182!
buryTreasureAt: aPosition in: terrain at: anIsland  
	self shouldBeImplemented.! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:43:25'!
buryTreasureAt: aPosition in: terrain at: anIsland  

	terrain = #Tree ifTrue: [].
	terrain = #Empty ifTrue: [].
	terrain = #Diggable ifTrue: [ 				self drawTreasureMarkAt: aPosition ].
! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:43:25'!
buryTreasureAt: aPosition in: terrain at: anIsland  

	terrain = #Tree ifTrue: [].
	terrain = #Empty ifTrue: [].
	terrain = #Diggable ifTrue: [].
! !
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:43:25' prior: 50608105!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate |
	
		pirate buryTreasureAt: aPosition in: terrain at: at.
	].
	! !

!methodRemoval: Bucanero #buryTreasureAt:in: stamp: 'AS 4/26/2023 14:43:25'!
buryTreasureAt: aPosition in: terrain 
	self shouldBeImplemented.!

!methodRemoval: Corsario #buryTreasureAt:in: stamp: 'AS 4/26/2023 14:43:25'!
buryTreasureAt: aPosition in: terrain 

	terrain = #Tree ifTrue: [].
	terrain = #Empty ifTrue: [].
	terrain = #Diggable ifTrue: [ 				self drawTreasureMarkAt: aPosition ].
!

!methodRemoval: Filibustero #buryTreasureAt:in: stamp: 'AS 4/26/2023 14:43:25'!
buryTreasureAt: aPosition in: terrain 

	terrain = #Tree ifTrue: [].
	terrain = #Empty ifTrue: [].
	terrain = #Diggable ifTrue: [].
!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:44:24' prior: 50608195!
buryTreasureAt: aPosition in: terrain at: anIsland  
	
	terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
	terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
	terrain = #Diggable ifTrue: [ anIsland receiveTreasureAt: aPosition ].	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:44:26'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:44:26'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:44:26'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:44:26'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:44:26'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:44:26'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:44:26'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:44:26'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:44:33'!
ERROR!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:45:28' prior: 50608245!
buryTreasureAt: aPosition in: terrain at: anIsland  
	
	terrain = #Tree ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ].
	terrain = #Empty ifTrue: [ self error: 'Arrgh!! I cannot dig this type of terrain!!' ]	.
	terrain = #Diggable ifTrue: [ (anIsland receiveTreasureAt: aPosition) ].	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:45:31'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:45:31'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:45:31'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:45:31'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:45:31'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:45:31'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:45:31'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:45:32'!
ERROR!
!Crew methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:46:14' prior: 50608217!
buryTreasureAt: aPosition

	| terrain |
	
	terrain := island terrainAt: aPosition.
	
	pirates do: [:pirate |
	
		pirate buryTreasureAt: aPosition in: terrain at: island.
	].
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:46:16'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:46:16'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:46:16'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:46:16'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:46:17'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:46:17'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:46:17'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:46:17'!
PASSED!
!Bucanero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:49:50' prior: 50608287!
buryTreasureAt: aPosition in: terrain at: anIsland  
	
	terrain bucanero: self buryTreasureAt: aPosition at: anIsland
! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:50:37'!
bucanero: aBucanero buryTreasureAt: aPosition at: anIsland	
	
	anIsland receiveTreasureAt: aPosition.	! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:52:24'!
bucanero: aBucanero buryTreasureAr: aPosition at: anIsland	
	
	self error: 'Arrgh!! I cannot dig this type of terrain!!'	.! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:53:03'!
bucanero: aBucanero buryTreasureAt: aPosition at: anIsland

	self error: 'Arrgh!! I cannot dig this type of terrain!!'
	! !
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:54:02' prior: 50608200!
buryTreasureAt: aPosition in: terrain at: anIsland  

	terrain corsario: self buryTreasureAt: aPosition at: anIsland
! !
!Diggable methodsFor: 'nil' stamp: 'AS 4/26/2023 14:54:52'!
corsario: aCorsario buryTreasureAt: aPosition at: anIsland
	
	aCorsario drawTreasureMarkAt: aPosition! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:55:18'!
corsario: aCorsario buryTreasureAt: aPosition at: anIsland
	! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:55:28'!
corsario: aCorsario buryTreasureAt: aPosition at: anIsland
! !
!Filibustero methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:57:35' prior: 50608209!
buryTreasureAt: aPosition in: terrain at: anIsland  

	terrain filibustero: self buryTreaseureAt: aPosition at: anIsland
! !
!Diggable methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:57:59'!
filibustero: aFilibustero buryTreaseureAt: aPosition at: anIsland! !
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:58:05'!
filibustero: aFilibustero buryTreaseureAt: aPosition at: anIsland! !
!Tree methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 14:58:13'!
filibustero: aFilibustero buryTreaseureAt: aPosition at: anIsland! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:58:19'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:58:19'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:58:19'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:58:53'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 14:58:53'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 14:58:53'!
ERROR!
!Empty methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:00:00'!
bucanero: aBucanero buryTreasureAt: aPosition at: anIsland	
	
	self error: 'Arrgh!! I cannot dig this type of terrain!!'	.! !

!methodRemoval: Empty #bucanero:buryTreasureAr:at: stamp: 'AS 4/26/2023 15:00:00'!
bucanero: aBucanero buryTreasureAr: aPosition at: anIsland	
	
	self error: 'Arrgh!! I cannot dig this type of terrain!!'	.!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:00:06'!
PASSED!

!methodRemoval: Diggable #= stamp: 'AS 4/26/2023 15:01:52'!
= anObject

	^anObject = #Diggable
!

!methodRemoval: Empty #= stamp: 'AS 4/26/2023 15:02:08'!
= anObject

	^anObject = #Empty!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:02:13'!
PASSED!

!methodRemoval: Tree #= stamp: 'AS 4/26/2023 15:02:26'!
= anObject

	^anObject = #Tree!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:02:48'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:02:48'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:13:32' prior: 50606588!
clearTerrainAt: aPosition

	treesAt remove: aPosition ifAbsent: []! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:13:36'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:13:36'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:14:26' prior: 50606612!
isEmptyAt: aPosition

	^(treesAt includes: aPosition) not! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:18:19' prior: 50607511!
terrainAt: aPosition
	
	| ix |

	(treesAt includes: aPosition) ifTrue: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
	"
	
	ix := 1.
	[ix <= treesAt size] whileTrue: [ | pos |
		pos := treesAt at: ix.
		(aPosition = pos) ifTrue: [ ^ Tree new].		
		ix := ix + 1.
	].

	ix := 1.
	[ix <= digsAt size] whileTrue: [ | pos |
		pos := digsAt at: ix.
		(aPosition = pos) ifTrue: [ ^ Diggable new].
		ix := ix + 1.
	].

	^ Empty new.
	
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:18:25'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:18:25'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:18:35' prior: 50608622!
terrainAt: aPosition
	
	(treesAt includes: aPosition) ifTrue: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:21:57' prior: 50608665!
terrainAt: aPosition
	
	treesAt detect: [ :position | position = aPosition]
		ifFound: [^Tree new]
		ifNone: [treesAt detect: [ :position | position = aPosition]
				ifFound: [^Diggable new]
				ifNone: [^Empty new] ]
	"
	(treesAt detect: aPosition) ifFound: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:21:59'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:21:59'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:21:59'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:21:59'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:21:59'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:21:59'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:21:59'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:21:59'!
ERROR!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:23:12' prior: 50608673!
terrainAt: aPosition
	
	treesAt detect: [ :position | position = aPosition]
		ifFound: [:position | ^Tree new]
		ifNone: [treesAt detect: [ :position | position = aPosition]
				ifFound: [:position | ^Diggable new]
				ifNone: [^Empty new] ]
	"
	(treesAt detect: aPosition) ifFound: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
"! !

	^Empty new!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:23:37'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:23:37'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:23:37'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:23:37'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:23:37'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:23:37'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:23:37'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:23:37'!
ERROR!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 15:23:43' prior: 50606271!

test06CrewCanBuryTreasureIfBucaneroCanDig

	| island crew treePosition crewPosition map digPosition |
	
	crewPosition := 1@1.
	treePosition := 1@2.
	digPosition := 2@2.
	
	island := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: digPosition).
	
	map := Map of: island crewStartsAt: crewPosition.
	
	crew := Crew 
			at: island 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition.

	crew moveTo: 2@1.
	crew buryTreasureAt: 2@2.
	
	self assert: map hasTreasureMark.
	
			
	
	
	
! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:24:00' prior: 50608712!
terrainAt: aPosition
	
	treesAt detect: [ :position | position = aPosition]
		ifFound: [:position | ^Tree new]
		ifNone: [digsAt detect: [ :position | position = aPosition]
				ifFound: [:position | ^Diggable new]
				ifNone: [^Empty new] ]
	"
	(treesAt detect: aPosition) ifFound: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
"! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:24:16' prior: 50608774!
terrainAt: aPosition
	
	treesAt detect: [ :position | position = aPosition]
		ifFound: [^Tree new]
		ifNone: [digsAt detect: [ :position | position = aPosition]
				ifFound: [^Diggable new]
				ifNone: [^Empty new] ]
	"
	(treesAt detect: aPosition) ifFound: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:24:18'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:24:18'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:24:18'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:24:18'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:24:18'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:24:18'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:24:18'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:24:18'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:24:24'!
ERROR!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:24:55' prior: 50608789!
terrainAt: aPosition
	
	treesAt detect: [:position | position = aPosition]
		ifFound: [:position | ^Tree new]
		ifNone: [digsAt detect: [ :position | position = aPosition]
				ifFound: [:position | ^Diggable new]
				ifNone: [^Empty new] ]
	"
	(treesAt detect: aPosition) ifFound: [^Tree new].
	(digsAt includes: aPosition) ifTrue: [^Diggable new].
	^Empty new
"! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:24:57'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:24:57'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:25:04' prior: 50608831!
terrainAt: aPosition
	
	treesAt detect: [:position | position = aPosition]
		ifFound: [:position | ^Tree new]
		ifNone: [digsAt detect: [ :position | position = aPosition]
				ifFound: [:position | ^Diggable new]
				ifNone: [^Empty new] ]
! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:25:43' prior: 50608871!
terrainAt: aPosition
	
	^treesAt detect: [:position | position = aPosition]
		ifFound: [:position | Tree new]
		ifNone: [digsAt detect: [ :position | position = aPosition]
				ifFound: [:position | Diggable new]
				ifNone: [Empty new] ]
! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:28:26' prior: 50608882!
terrainAt: aPosition
	
	(self hasTreeAt: aPosition) ifTrue: [^Tree new].
	(self hasDiggable: aPosition) ifTrue: [ ^Diggable new].
	^Empty new.! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:28:32'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:28:35'!
ERROR!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:28:43'!
hasTreeAt: aPosition 
	self shouldBeImplemented.! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:29:30' prior: 50608929!
hasTreeAt: aPosition 
	
	^treesAt includes: aPosition
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:29:33'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:29:35'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:29:36'!
ERROR!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:29:43'!
hasDiggable: aPosition 
	self shouldBeImplemented.! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:30:03' prior: 50608948!
hasDiggable: aPosition 

	^digsAt includes: aPosition! !

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:30:05'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:30:07'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:30:07'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:30:08'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:30:08'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:30:09'!
PASSED!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:32:53'!
isDiggable: aPosition 

	^digsAt includes: aPosition! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:32:53' prior: 50608893!
terrainAt: aPosition
	
	(self hasTreeAt: aPosition) ifTrue: [^Tree new].
	(self isDiggable: aPosition) ifTrue: [ ^Diggable new].
	^Empty new.! !

!methodRemoval: Island #hasDiggable: stamp: 'AS 4/26/2023 15:32:53'!
hasDiggable: aPosition 

	^digsAt includes: aPosition!
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:33:07'!
isDiggableAt: aPosition 

	^digsAt includes: aPosition! !
!Island methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:33:07' prior: 50608981!
terrainAt: aPosition
	
	(self hasTreeAt: aPosition) ifTrue: [^Tree new].
	(self isDiggableAt: aPosition) ifTrue: [ ^Diggable new].
	^Empty new.! !

!methodRemoval: Island #isDiggable: stamp: 'AS 4/26/2023 15:33:07'!
isDiggable: aPosition 

	^digsAt includes: aPosition!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:33:10'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:33:10'!
PASSED!
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:35:24' prior: 50606684!
lastPosition

	| acc ix |

	^steps inject: startPosition into: [:position | position + 1].
	
	"
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc
	"
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:35:31'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:35:31'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:35:31'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:35:31'!
ERROR!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:35:31'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:35:31'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:35:31'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:35:31'!
ERROR!
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:39:06' prior: 50609034!
lastPosition

	| acc ix |

	^steps inject: startPosition into: [:position :stepsPosition | position + stepsPosition].
	
	"
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc
	"
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:39:11'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:39:11'!
PASSED!
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:39:59' prior: 50609070!
lastPosition

	

	^steps inject: startPosition into: [:lastPosition :stepsPosition | lastPosition + stepsPosition].
	
	"
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc
	"
	! !
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:40:12' prior: 50609107!
lastPosition

	

	^steps inject: startPosition into: [:lastPosition :step | lastPosition + step].
	
	"
	acc := startPosition.
	ix := 1.
	
	[ix <= steps size] whileTrue: [
		acc := acc + (steps at: ix)	.
		ix := ix + 1.
	].

	^ acc
	"
	! !
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:40:26' prior: 50609118!
lastPosition

	^steps inject: startPosition into: [:lastPosition :step | lastPosition + step].
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:40:27'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:40:27'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:40:28'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:40:28'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:40:28'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:40:28'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:40:28'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:40:28'!
PASSED!

!methodRemoval: Map #startPosition stamp: 'AS 4/26/2023 15:41:05'!
startPosition

	^ startPosition
	
	!

!methodRemoval: Map #step: stamp: 'AS 4/26/2023 15:42:12'!
step: ix

	^ steps at: ix.
	
	!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:42:17'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:42:17'!
PASSED!
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:43:02' prior: 50606668!
hasTreasureMark

	^ treasureMarkPosition isNotNil
	
	! !
!Map methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:43:15' prior: 50609192!
hasTreasureMark

	^ treasureMarkPosition notNil
	
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:43:17'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:43:17'!
PASSED!
!Pirate methodsFor: 'no messages' stamp: 'AS 4/26/2023 15:44:06'!
canMoveTo: aPosition in: terrain at: anIsland 
	
	self subclassResponsibility 
! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:44:27'!
buryTreasureAt: aPosition in: terrain at: anIsland  
	
	self subclassResponsibility ! !

Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Bucanero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:44:48'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Corsario category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:44:53'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Filibustero category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:44:56'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Pirate category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:45:02'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:46:05'!
aCaptainIWasMeantToBe

	rank := #Captain! !

!methodRemoval: Bucanero #aCaptainIWasMeantToBe stamp: 'AS 4/26/2023 15:46:05'!
aCaptainIWasMeantToBe

	rank := #Captain!

!methodRemoval: Corsario #aCaptainIWasMeantToBe stamp: 'AS 4/26/2023 15:46:34'!
aCaptainIWasMeantToBe

	rank := #Captain!

!methodRemoval: Filibustero #aCaptainIWasMeantToBe stamp: 'AS 4/26/2023 15:46:37'!
aCaptainIWasMeantToBe

	rank := #Captain!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:46:45'!
PASSED!

!methodRemoval: Corsario #initialize stamp: 'AS 4/26/2023 15:48:59'!
initialize

	rank := #NoRank!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:49:02'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:49:02'!
PASSED!
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:49:41'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	! !

!methodRemoval: Bucanero #searchTreasureIn:with: stamp: 'AS 4/26/2023 15:49:42'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!methodRemoval: Corsario #searchTreasureIn:with: stamp: 'AS 4/26/2023 15:50:07'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!methodRemoval: Filibustero #searchTreasureIn:with: stamp: 'AS 4/26/2023 15:50:11'!
searchTreasureIn: island with: aMap

	rank = #SimplePirate ifTrue: [ self error: 'I am a simple pirate!!' ].
	rank = #Captain ifTrue: [ ^ true "Aye, Aye!! La implementación está fuera del scope del parcial." ].
	!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:50:17'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:50:17'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:50:18'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:50:18'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:50:18'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:50:18'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:50:18'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:50:18'!
PASSED!
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:51:23' overrides: 16920235!
initialize

	rank := #SimplePirate! !

!methodRemoval: Bucanero #initialize stamp: 'AS 4/26/2023 15:51:23'!
initialize

	rank := #SimplePirate!
!Corsario methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:51:42' prior: 50606419!
initializeWith: aMap

	"rank := #SimplePirate."
	map := aMap! !

!methodRemoval: Filibustero #initialize stamp: 'AS 4/26/2023 15:51:48'!
initialize

	rank := #SimplePirate!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:51:51'!
PASSED!

Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #PirateRank category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:53:15'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #SimplePirate category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:53:27'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #Captain category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 15:53:33'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:53:47' prior: 50609285!
aCaptainIWasMeantToBe

	rank := Captain new! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:53:59' prior: 50609419 overrides: 16920235!
initialize

	rank := SimplePirate new! !
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:55:11' prior: 50609355!
searchTreasureIn: island with: aMap

	rank searchTreasureIn: island with: aMap.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:55:20'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:55:20'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:55:20'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:55:20'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:55:20'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:55:20'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:55:20'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:55:20'!
ERROR!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:55:23'!
ERROR!
!Captain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:55:44'!
searchTreasureIn: island with: aMap 
	self shouldBeImplemented.! !
!Captain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:56:10' prior: 50609540!
searchTreasureIn: island with: aMap 
	
	^true "Aye, Aye!! La implementación está fuera del scope del parcial."
	! !

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:56:11'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:56:46'!
ERROR!
!SimplePirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:56:54'!
searchTreasureIn: island with: aMap 
	self shouldBeImplemented.! !
!SimplePirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 15:57:10' prior: 50609557!
searchTreasureIn: island with: aMap 

	self error: 'I am a simple pirate!!'! !

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:57:12'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:57:14'!
ERROR!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:58:02'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:58:02'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:58:02'!
ERROR!
!PirateRank methodsFor: 'no messages' stamp: 'AS 4/26/2023 15:59:36'!
searchTreasureIn: island with: aMap 

	^self subclassResponsibility ! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:59:46'!
ERROR!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 15:59:46'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 15:59:46'!
ERROR!
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:02:03' prior: 50609507!
searchTreasureIn: island with: aMap

	^rank searchTreasureIn: island with: aMap.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:02:09'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:02:09'!
PASSED!
!PirateRank methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:03:18'!
searchTreasureFor: aPirate at: anIsland with: aMap 

	^self subclassResponsibility ! !

!methodRemoval: PirateRank #searchTreasureIn:with: stamp: 'AS 4/26/2023 16:03:23'!
searchTreasureIn: island with: aMap 

	^self subclassResponsibility !
!Captain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:03:36' overrides: 50609667!
searchTreasureFor: aPirate at: anIsland with: aMap 

	^true "Aye, Aye!! La implementación está fuera del scope del parcial."
	! !

!methodRemoval: Captain #searchTreasureIn:with: stamp: 'AS 4/26/2023 16:03:40'!
searchTreasureIn: island with: aMap 
	
	^true "Aye, Aye!! La implementación está fuera del scope del parcial."
	!
!SimplePirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:03:50' overrides: 50609667!
searchTreasureFor: aPirate at: anIsland with: aMap 

	self error: 'I am a simple pirate!!'! !

!methodRemoval: SimplePirate #searchTreasureIn:with: stamp: 'AS 4/26/2023 16:03:57'!
searchTreasureIn: island with: aMap 

	self error: 'I am a simple pirate!!'!
!Pirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:04:20' prior: 50609636!
searchTreasureIn: island with: aMap

	^rank searchTreasureFor: self at: island with: aMap.
	! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:05:06'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:05:06'!
PASSED!
!Terrain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:06:45'!
bucanero: aBucanero buryTreasureAt: aPosition at: anIsland	

	self subclassResponsibility ! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:07:03'!
corsario: aCorsario buryTreasureAt: aPosition at: anIsland
	
	self subclassResponsibility ! !
!Terrain methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 16:07:22'!
filibustero: aFilibustero buryTreaseureAt: aPosition at: anIsland

	self subclassResponsibility ! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:46:59' prior: 50606153!
test01MovingCrewToTreePlaceDoesNotMove

	| island1 crew crewPosition treePosition map |
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island1 crewStartsAt: crewPosition.

	crew := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition.
			
	crew moveTo: treePosition.
	
	self deny: (island1 hasCrewAt: treePosition).
	self assert: (island1 hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:47:04' prior: 50609752!
test01MovingCrewToTreePlaceDoesNotMove

	| island1 crew1 crewPosition treePosition map |
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island1 crewStartsAt: crewPosition.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition.
			
	crew1 moveTo: treePosition.
	
	self deny: (island1 hasCrewAt: treePosition).
	self assert: (island1 hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:47:20' prior: 50609774!
test01MovingCrewToTreePlaceDoesNotMove

	| island1 crew1 crewPosition1 treePosition map |
	
	crewPosition1 := 1@1.
	treePosition := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island1 crewStartsAt: crewPosition1.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition1.
			
	crew1 moveTo: treePosition.
	
	self deny: (island1 hasCrewAt: treePosition).
	self assert: (island1 hasCrewAt: crewPosition1).! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:47:24' prior: 50609796!
test01MovingCrewToTreePlaceDoesNotMove

	| island1 crew1 crewPosition1 treePosition1 map |
	
	crewPosition1 := 1@1.
	treePosition1 := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition1)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island1 crewStartsAt: crewPosition1.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition1.
			
	crew1 moveTo: treePosition1.
	
	self deny: (island1 hasCrewAt: treePosition1).
	self assert: (island1 hasCrewAt: crewPosition1).! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:47:56' prior: 50609818!
test01MovingCrewToTreePlaceDoesNotMove

	| island1 crew1 crewPosition1 treePosition1 map1 |
	
	crewPosition1 := 1@1.
	treePosition1 := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition1)
		digsAt: (OrderedCollection with: 3@3).
	
	map1 := Map of: island1 crewStartsAt: crewPosition1.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map1) with: Filibustero new with: Bucanero new)
			at: crewPosition1.
			
	crew1 moveTo: treePosition1.
	
	self deny: (island1 hasCrewAt: treePosition1).
	self assert: (island1 hasCrewAt: crewPosition1).! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:47:57'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:47:57'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'HAW 9/22/2022 16:37:37' prior: 50609840!
test01MovingCrewToTreePlaceDoesNotMove

	| island crew crewPosition treePosition map |
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island crewStartsAt: crewPosition.

	crew := Crew 
			at: island 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition.
			
	crew moveTo: treePosition.
	
	self deny: (island hasCrewAt: treePosition).
	self assert: (island hasCrewAt: crewPosition).! !

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 16:52:26'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 16:52:28'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1 treePosition1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 16:52:30'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1 treePosition1 island1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 16:52:31'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1 treePosition1 island1 map1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 16:52:32'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1 treePosition1 island1 map1 crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:52:24' overrides: 16961394!
setUp
	
	crewPosition1 := 1@1.
	treePosition1 := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition1)
		digsAt: (OrderedCollection with: 3@3).
	
	map1 := Map of: island1 crewStartsAt: crewPosition1.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map1) with: Filibustero new with: Bucanero new)
			at: crewPosition1.		! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:54:07' prior: 50609891!
test01MovingCrewToTreePlaceDoesNotMove
		
	crew1 moveTo: treePosition1.
	
	self deny: (island1 hasCrewAt: treePosition1).
	self assert: (island1 hasCrewAt: crewPosition1).! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:54:08'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:54:08'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:54:50' prior: 50606174!
test02MovingCrewToTreePlaceFilibusteroRemovesTree

	self deny: (island1 isEmptyAt: treePosition1).
				
	crew1 moveTo: treePosition1.

	self assert: (island1 isEmptyAt: treePosition1).
	
	self deny: (island1 hasCrewAt: treePosition1).
	self assert: (island1 hasCrewAt: crewPosition1).! !

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:54:52'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:54:52'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:55:38' prior: 50606198!
test03MovingCrewToFreePlace

	| nextPosition |

	nextPosition := 2@1.
	self assert: (island1 isEmptyAt: nextPosition).
	
	crew1 moveTo: nextPosition.

	self deny: (island1 hasCrewAt: crewPosition1).
	self assert: (island1 hasCrewAt: nextPosition).! !

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:55:41'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:55:41'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:56:11' prior: 50606221!
test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap

	| nextPosition |

	nextPosition := 2@1.
	self assert: map1 isEmpty.

	crew1 moveTo: nextPosition.

	self assert: map1 stepsSize equals: 1. 
	self assert: map1 lastPosition equals: nextPosition.
! !

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:56:12'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:56:12'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:57:33' prior: 50606244!
test05CrewCannotBuryTreasureIfBucaneroCannotDig

	| digPosition |
	
	digPosition := 2@2.
	
	crew1 moveTo: 2@1.
	
	self 
		should: [ crew1 buryTreasureAt: 3@1 ] 
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error | 
			self assert: error messageText equals: Bucanero cannotDigErrorDescription.
			self deny: map1 hasTreasureMark ]
			
	
	
	
! !

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:57:38'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:57:38'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:58:08' prior: 50608752!
test06CrewCanBuryTreasureIfBucaneroCanDig

	| digPosition |
	
	digPosition := 2@2.
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 2@2.
	
	self assert: map1 hasTreasureMark.
	
			
	
	
	
! !

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:58:13'!
ERROR!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:58:30' prior: 50610170!
test06CrewCanBuryTreasureIfBucaneroCanDig

	| digPosition |
	
	digPosition := 2@2.
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.
	
	self assert: map1 hasTreasureMark.
	
			
	
	
	
! !

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:58:33'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:58:33'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:59:23' prior: 50606293!
test07CaptainCanUseMap

	| digPosition pirate |
	
	digPosition := 2@2.
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 2@2.

	pirate := Bucanero new.
	pirate aCaptainIWasMeantToBe.
	
	self assert: (pirate searchTreasureIn: island1 with: map1)! !

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:59:27'!
ERROR!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 16:59:39' prior: 50610219!
test07CaptainCanUseMap

	| digPosition pirate |
	
	digPosition := 2@2.
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	pirate aCaptainIWasMeantToBe.
	
	self assert: (pirate searchTreasureIn: island1 with: map1)! !

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 16:59:43'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 16:59:43'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:00:20' prior: 50606316!
test08SimplePirateCannotUseMap

	| digPosition pirate |
	
	digPosition := 2@2.
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island1 with: map1 ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: 'I am a simple pirate!!'
! !

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:00:23'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:00:23'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:01:25' prior: 50610127!
test05CrewCannotBuryTreasureIfBucaneroCannotDig

	crew1 moveTo: 2@1.
	
	self 
		should: [ crew1 buryTreasureAt: 3@1 ] 
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error | 
			self assert: error messageText equals: Bucanero cannotDigErrorDescription.
			self deny: map1 hasTreasureMark ]
			
	
	
	
! !

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:01:26'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:01:26'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:01:33' prior: 50610182!
test06CrewCanBuryTreasureIfBucaneroCanDig

	
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.
	
	self assert: map1 hasTreasureMark.
	
			
	
	
	
! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:01:39' prior: 50610354!
test06CrewCanBuryTreasureIfBucaneroCanDig
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.
	
	self assert: map1 hasTreasureMark.
	
			
	
	
	
! !

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:01:40'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:01:40'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:01:52' prior: 50610232!
test07CaptainCanUseMap

	| pirate |
		
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	pirate aCaptainIWasMeantToBe.
	
	self assert: (pirate searchTreasureIn: island1 with: map1)! !

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:01:55'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:01:55'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:02:03' prior: 50610271!
test08SimplePirateCannotUseMap

	| pirate |
		
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island1 with: map1 ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: 'I am a simple pirate!!'
! !

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:02:04'!
PASSED!

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 17:02:28'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition treePosition1 island1 map1 crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:28' prior: 50610007!
test02MovingCrewToTreePlaceFilibusteroRemovesTree

	self deny: (island1 isEmptyAt: treePosition1).
				
	crew1 moveTo: treePosition1.

	self assert: (island1 isEmptyAt: treePosition1).
	
	self deny: (island1 hasCrewAt: treePosition1).
	self assert: (island1 hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:28' prior: 50609955 overrides: 16961394!
setUp
	
	crewPosition := 1@1.
	treePosition1 := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition1)
		digsAt: (OrderedCollection with: 3@3).
	
	map1 := Map of: island1 crewStartsAt: crewPosition.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map1) with: Filibustero new with: Bucanero new)
			at: crewPosition.		! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:28' prior: 50610048!
test03MovingCrewToFreePlace

	| nextPosition |

	nextPosition := 2@1.
	self assert: (island1 isEmptyAt: nextPosition).
	
	crew1 moveTo: nextPosition.

	self deny: (island1 hasCrewAt: crewPosition).
	self assert: (island1 hasCrewAt: nextPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:28' prior: 50609970!
test01MovingCrewToTreePlaceDoesNotMove
		
	crew1 moveTo: treePosition1.
	
	self deny: (island1 hasCrewAt: treePosition1).
	self assert: (island1 hasCrewAt: crewPosition).! !

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 17:02:33'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition treePosition island1 map1 crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:33' prior: 50610498 overrides: 16961394!
setUp
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island1 := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map1 := Map of: island1 crewStartsAt: crewPosition.

	crew1 := Crew 
			at: island1 
			composedBy: (OrderedCollection with: (Corsario with: map1) with: Filibustero new with: Bucanero new)
			at: crewPosition.		! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:33' prior: 50610485!
test02MovingCrewToTreePlaceFilibusteroRemovesTree

	self deny: (island1 isEmptyAt: treePosition).
				
	crew1 moveTo: treePosition.

	self assert: (island1 isEmptyAt: treePosition).
	
	self deny: (island1 hasCrewAt: treePosition).
	self assert: (island1 hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:33' prior: 50610525!
test01MovingCrewToTreePlaceDoesNotMove
		
	crew1 moveTo: treePosition.
	
	self deny: (island1 hasCrewAt: treePosition).
	self assert: (island1 hasCrewAt: crewPosition).! !

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 17:02:37'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition treePosition island map1 crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:37' prior: 50610559!
test02MovingCrewToTreePlaceFilibusteroRemovesTree

	self deny: (island isEmptyAt: treePosition).
				
	crew1 moveTo: treePosition.

	self assert: (island isEmptyAt: treePosition).
	
	self deny: (island hasCrewAt: treePosition).
	self assert: (island hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:37' prior: 50610514!
test03MovingCrewToFreePlace

	| nextPosition |

	nextPosition := 2@1.
	self assert: (island isEmptyAt: nextPosition).
	
	crew1 moveTo: nextPosition.

	self deny: (island hasCrewAt: crewPosition).
	self assert: (island hasCrewAt: nextPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:37' prior: 50610398!
test07CaptainCanUseMap

	| pirate |
		
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	pirate aCaptainIWasMeantToBe.
	
	self assert: (pirate searchTreasureIn: island with: map1)! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:37' prior: 50610543 overrides: 16961394!
setUp
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map1 := Map of: island crewStartsAt: crewPosition.

	crew1 := Crew 
			at: island 
			composedBy: (OrderedCollection with: (Corsario with: map1) with: Filibustero new with: Bucanero new)
			at: crewPosition.		! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:37' prior: 50610436!
test08SimplePirateCannotUseMap

	| pirate |
		
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island with: map1 ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: 'I am a simple pirate!!'
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:37' prior: 50610571!
test01MovingCrewToTreePlaceDoesNotMove
		
	crew1 moveTo: treePosition.
	
	self deny: (island hasCrewAt: treePosition).
	self assert: (island hasCrewAt: crewPosition).! !

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 17:02:41'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition treePosition island map crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:41' prior: 50610611!
test07CaptainCanUseMap

	| pirate |
		
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	pirate aCaptainIWasMeantToBe.
	
	self assert: (pirate searchTreasureIn: island with: map)! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:41' prior: 50610637!
test08SimplePirateCannotUseMap

	| pirate |
		
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island with: map ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: 'I am a simple pirate!!'
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:41' prior: 50610621 overrides: 16961394!
setUp
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island crewStartsAt: crewPosition.

	crew1 := Crew 
			at: island 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition.		! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:41' prior: 50610312!
test05CrewCannotBuryTreasureIfBucaneroCannotDig

	crew1 moveTo: 2@1.
	
	self 
		should: [ crew1 buryTreasureAt: 3@1 ] 
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error | 
			self assert: error messageText equals: Bucanero cannotDigErrorDescription.
			self deny: map hasTreasureMark ]
			
	
	
	
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:41' prior: 50610087!
test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap

	| nextPosition |

	nextPosition := 2@1.
	self assert: map isEmpty.

	crew1 moveTo: nextPosition.

	self assert: map stepsSize equals: 1. 
	self assert: map lastPosition equals: nextPosition.
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:41' prior: 50610362!
test06CrewCanBuryTreasureIfBucaneroCanDig
	
	crew1 moveTo: 2@1.
	crew1 buryTreasureAt: 3@3.
	
	self assert: map hasTreasureMark.
	
			
	
	
	
! !

!classDefinition: #CrewTest category: 'ISW1-2022-2C-1erParcial' stamp: 'AS 4/26/2023 17:02:47'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition treePosition island map crew'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610705!
test05CrewCannotBuryTreasureIfBucaneroCannotDig

	crew moveTo: 2@1.
	
	self 
		should: [ crew buryTreasureAt: 3@1 ] 
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error | 
			self assert: error messageText equals: Bucanero cannotDigErrorDescription.
			self deny: map hasTreasureMark ]
			
	
	
	
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610689 overrides: 16961394!
setUp
	
	crewPosition := 1@1.
	treePosition := 1@2.
	
	island := Island
		sized: 3@3
		treesAt: (OrderedCollection with: treePosition)
		digsAt: (OrderedCollection with: 3@3).
	
	map := Map of: island crewStartsAt: crewPosition.

	crew := Crew 
			at: island 
			composedBy: (OrderedCollection with: (Corsario with: map) with: Filibustero new with: Bucanero new)
			at: crewPosition.		! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610676!
test08SimplePirateCannotUseMap

	| pirate |
		
	crew moveTo: 2@1.
	crew buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island with: map ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: 'I am a simple pirate!!'
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610649!
test01MovingCrewToTreePlaceDoesNotMove
		
	crew moveTo: treePosition.
	
	self deny: (island hasCrewAt: treePosition).
	self assert: (island hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610718!
test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap

	| nextPosition |

	nextPosition := 2@1.
	self assert: map isEmpty.

	crew moveTo: nextPosition.

	self assert: map stepsSize equals: 1. 
	self assert: map lastPosition equals: nextPosition.
! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610666!
test07CaptainCanUseMap

	| pirate |
		
	crew moveTo: 2@1.
	crew buryTreasureAt: 3@3.

	pirate := Bucanero new.
	pirate aCaptainIWasMeantToBe.
	
	self assert: (pirate searchTreasureIn: island with: map)! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610588!
test02MovingCrewToTreePlaceFilibusteroRemovesTree

	self deny: (island isEmptyAt: treePosition).
				
	crew moveTo: treePosition.

	self assert: (island isEmptyAt: treePosition).
	
	self deny: (island hasCrewAt: treePosition).
	self assert: (island hasCrewAt: crewPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610600!
test03MovingCrewToFreePlace

	| nextPosition |

	nextPosition := 2@1.
	self assert: (island isEmptyAt: nextPosition).
	
	crew moveTo: nextPosition.

	self deny: (island hasCrewAt: crewPosition).
	self assert: (island hasCrewAt: nextPosition).! !
!CrewTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:02:47' prior: 50610729!
test06CrewCanBuryTreasureIfBucaneroCanDig
	
	crew moveTo: 2@1.
	crew buryTreasureAt: 3@3.
	
	self assert: map hasTreasureMark.
	
			
	
	
	
! !

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:02:52'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:02:52'!
PASSED!
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:04:58'!
simplePirateErrorDescription

	^ 'I am a simple pirate!!'! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:04:58' prior: 50610776!
test08SimplePirateCannotUseMap

	| pirate |
		
	crew moveTo: 2@1.
	crew buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island with: map ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: self simplePirateErrorDescription
! !

!methodRemoval: CrewTest #simplePirateErrorDescription stamp: 'AS 4/26/2023 17:05:51'!
simplePirateErrorDescription

	^ 'I am a simple pirate!!'!
!PirateRank class methodsFor: 'nil' stamp: 'AS 4/26/2023 17:06:07'!
simplePirateErrorDescription

	^ 'I am a simple pirate!!'! !
!CrewTest methodsFor: 'tests' stamp: 'AS 4/26/2023 17:06:44' prior: 50610878!
test08SimplePirateCannotUseMap

	| pirate |
		
	crew moveTo: 2@1.
	crew buryTreasureAt: 3@3.

	pirate := Bucanero new.
	
	self 
		should: [ pirate searchTreasureIn: island with: map ] 
		raise: Error - MessageNotUnderstood 
		withMessageText: PirateRank simplePirateErrorDescription
! !

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test01MovingCrewToTreePlaceDoesNotMove stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test02MovingCrewToTreePlaceFilibusteroRemovesTree stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test03MovingCrewToFreePlace stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test04MovingCrewToFreePlaceCorsarioWritesDirectionInMap stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test05CrewCannotBuryTreasureIfBucaneroCannotDig stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test06CrewCanBuryTreasureIfBucaneroCanDig stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test07CaptainCanUseMap stamp: 'AS 4/26/2023 17:06:46'!
PASSED!

!testRun: #CrewTest #test08SimplePirateCannotUseMap stamp: 'AS 4/26/2023 17:06:46'!
PASSED!
!SimplePirate methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 17:07:29' prior: 50609692 overrides: 50609667!
searchTreasureFor: aPirate at: anIsland with: aMap 

	self error: PirateRank simplePirateErrorDescription ! !

!classRemoval: #Tree stamp: 'AS 4/26/2023 17:12:06'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Empty stamp: 'AS 4/26/2023 17:12:06'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Diggable stamp: 'AS 4/26/2023 17:12:07'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Terrain stamp: 'AS 4/26/2023 17:12:07'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #SimplePirate stamp: 'AS 4/26/2023 17:12:07'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Captain stamp: 'AS 4/26/2023 17:12:07'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #PirateRank stamp: 'AS 4/26/2023 17:12:07'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Filibustero stamp: 'AS 4/26/2023 17:12:07'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Corsario stamp: 'AS 4/26/2023 17:12:08'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Bucanero stamp: 'AS 4/26/2023 17:12:08'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Pirate stamp: 'AS 4/26/2023 17:12:08'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Map stamp: 'AS 4/26/2023 17:12:08'!
Object subclass: #Map
	instanceVariableNames: 'island startPosition steps treasureMarkPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Island stamp: 'AS 4/26/2023 17:12:08'!
Object subclass: #Island
	instanceVariableNames: 'boardSize treesAt digsAt crewAt treasureAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Crew stamp: 'AS 4/26/2023 17:12:08'!
Object subclass: #Crew
	instanceVariableNames: 'island pirates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #CrewTest stamp: 'AS 4/26/2023 17:12:09'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition treePosition island map crew'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

----End fileIn of E:\ISW1\Parciales\2022\2C\Primer parcial\ISW1-2022-2C-1erParcial-Solucion.st----!

----SNAPSHOT----(26 April 2023 17:13:36) CuisUniversity-5706.image priorSource: 8713034!

----STARTUP---- (26 April 2023 21:06:23) as F:\CUIS University ISW1\CuisUniversity-5706.image!


----End fileIn of E:\ISW1\Parciales\2022\1C\Primer Parcial\ISW1-2022-1C-Parcial-1.st----!

----STARTUP---- (26 April 2023 21:08:34) as F:\CUIS University ISW1\CuisUniversity-5706.image!


----End fileIn of E:\ISW1\Parciales\2022\1C\Primer Parcial\ISW1-2022-1C-Parcial-1.st----!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:10:12'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:10:12'!
PASSED!
!GrandPrix methodsFor: 'simulation' stamp: 'AS 4/26/2023 21:13:03' prior: 50613380!
advance: aTimeLapse
	
	| cars |
	
	cars := track cars asOrderedCollection.
	cars do: [ :car | self relocate: car after: aTimeLapse ]
	
	"
	| ix cars |
	
	cars := track cars asOrderedCollection.
	ix := 1.
	[ix <= cars size] whileTrue: [ | car |
		car := cars at: ix.
		self relocate: car after: aTimeLapse.
		ix := ix + 1.
	]
"! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:13:04'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:13:05'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:13:05'!
PASSED!
!GrandPrix methodsFor: 'simulation' stamp: 'AS 4/26/2023 21:13:16' prior: 50613813!
advance: aTimeLapse
	
	| cars |
	
	cars := track cars asOrderedCollection.
	cars do: [ :car | self relocate: car after: aTimeLapse ]
	! !
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:14:48' prior: 50613666!
cars
	| allCars |
	
	allCars := Set new.
	
	sectors do: [ :sector | allCars addAll: sector cars ].
	
	"
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		allCars addAll: s cars.
		ix := ix + 1.
	].
"
	^ allCars
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:14:53'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:14:53'!
PASSED!
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:16:16' prior: 50613922!
cars
	| allCars |
	
	allCars := Set new.
	
	"sectors do: [ :sector | allCars addAll: sector cars ]."
	
	^sectors inject: Set new into: [ :set :sector | set addAll: sector cars ].
	
	"^ allCars"
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:16:21'!
FAILURE!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:16:21'!
FAILURE!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:16:21'!
FAILURE!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:16:21'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:16:21'!
PASSED!
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:16:59' prior: 50614021!
cars
	| allCars |
	
	allCars := Set new.
	
	sectors do: [ :sector | allCars addAll: sector cars ].
	
	^ allCars
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:17:01'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:17:01'!
PASSED!
!Track class methodsFor: 'car position' stamp: 'AS 4/26/2023 21:19:50'!
carNotFoundErrorDescription

	^ 'Car not found'! !

!methodRemoval: Track #carNotFoundErrorDescription stamp: 'AS 4/26/2023 21:19:50'!
carNotFoundErrorDescription

	^ 'Car not found'!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:20:09'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:20:09'!
PASSED!
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:23:10' prior: 50613674!
length	

	| acc ix |

	^sectors inject: 0 * kilometer into: [ :length :sector | length + sector length ].

"
	acc := 0 * kilometer.
	ix := 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector := sectors at: ix.
		acc := acc + sector length.
		ix := ix + 1.		
	].

	^ acc. "
! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:23:14'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:23:14'!
PASSED!
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:23:25' prior: 50614311!
length	

	^sectors inject: 0 * kilometer into: [ :length :sector | length + sector length ].! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 21:23:27'!
PASSED!

Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #SectorTurboAdmited category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 21:27:43'!
Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #SectorTurboNotAdmited category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 21:27:48'!
Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 21:28:19' overrides: 50613489!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!SectorTurboNotAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 21:28:19' overrides: 50613489!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !

!methodRemoval: Sector #activateTurboTo: stamp: 'AS 4/26/2023 21:28:19'!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
!
!SectorTurboNotAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 22:49:47' prior: 50614549!
activateTurboTo: aCarToActivateTurboTo

	self error: Sector turboNotAllowedErrorDescription
! !
!Sector methodsFor: 'turbo' stamp: 'AS 4/26/2023 22:50:24'!
activateTurboTo: aCarToActivateTurboTo
	
	self subclassResponsibility! !
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 22:51:13' prior: 50614531 overrides: 50614588!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	positionOfCarAhead := self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 22:51:18'!
FAILURE!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 22:51:18'!
FAILURE!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:51:18'!
ERROR!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:51:18'!
FAILURE!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 22:51:18'!
ERROR!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 22:51:18'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 22:51:18'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 22:51:18'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 22:51:18'!
ERROR!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 22:51:18'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 22:51:33'!
FAILURE!
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:53:10' prior: 50613548!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ SectorTurboAdmited new initializeOf: aLength; withTurbo: true; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:54:47' prior: 50613557!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ SectorTurboNotAdmited new initializeOf: aLength; withTurbo: false; yourself ! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 22:54:56'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 22:54:56'!
PASSED!
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:55:42' prior: 50614701!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ SectorTurboAdmited new initializeOf: aLength; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:55:51' prior: 50614711!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ SectorTurboNotAdmited new initializeOf: aLength; yourself ! !

!methodRemoval: Sector #withTurbo: stamp: 'AS 4/26/2023 22:56:07'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 22:56:11'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 22:56:11'!
PASSED!
!SectorTurboAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 22:56:36' overrides: 50613589!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !
!SectorTurboNotAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 22:56:36' overrides: 50613589!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!methodRemoval: Sector class #turboNotAllowedErrorDescription stamp: 'AS 4/26/2023 22:56:36'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'!

!methodRemoval: SectorTurboNotAdmited class #turboNotAllowedErrorDescription stamp: 'AS 4/26/2023 22:56:45'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'!
!SectorTurboNotAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 22:57:09'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!methodRemoval: SectorTurboAdmited class #turboNotAllowedErrorDescription stamp: 'AS 4/26/2023 22:57:16'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 22:57:21'!
ERROR!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 22:57:21'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 22:57:22'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 22:57:22'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 22:57:22'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 22:57:22'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 22:57:22'!
ERROR!

----STARTUP---- (26 April 2023 23:00:47) as F:\CUIS University ISW1\CuisUniversity-5706.image!


!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:52'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:52'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 4/30/2022 18:38:56'!
test01SectorLengthMustBePositive

	self 
		should: [ Sector withTurboOf: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07'!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector _ Sector withTurboOf: 10 * kilometer.
	outside _ sector length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07'!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector _ Sector withoutTurboOf: 10*kilometer.
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:20'!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 20 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:26'!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:35'!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:40'!
test07TrackMustHaveSectors

	self
		should: [ Track withSectors: #() ]
		raise: Error
		withMessageText: Track mustHaveSectorsErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:46'!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	track _ Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:23:36'!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	outside _ track length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:24:51'!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	positionInSector2 _ 5 * kilometer.
	positionInTrack _ sectors first length + positionInSector2.
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:15'!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	track _ Track withSectors: sectors.
	car1 _ FormulaOneCar drivenBy: #Schumacher.
	car2 _ FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:37'!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:26:29'!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track _ Track withSectors: (OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer)).
	numberOfLaps _ 100.
	
	grandPrix _ GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:14'!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100.
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:18'!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:27:57'!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:28:20'!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:29:34'!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:40'!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	sectorA _ Sector withTurboOf: 10 * kilometer.
	sectorB _ Sector withTurboOf: 30 * kilometer.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:48:08'!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:31'!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:58'!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:19:06'!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:24'!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:59'!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:54'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:54'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'initialization' stamp: 'HAW 5/2/2022 14:12:13'!
initializeDrivenBy: aDriver 

	driver _ aDriver.
	turboActivated _ false.
	turboActivations _ 0.
	speed _ 0*kilometer/hour.
	traveledDistance _ 0.
	! !
!FormulaOneCar methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:28'!
runningInGrandPrix: aGrandPrix
	
	grandPrix _ aGrandPrix! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:07'!
advance: aDistance

	traveledDistance _ traveledDistance + aDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'FRT 4/30/2022 16:33:07'!
atSector: aSector

	currentSector _ aSector.! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/2/2022 14:11:23'!
speed

	turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	].

	^speed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/1/2022 17:34:26'!
speed: newSpeed

	speed _ newSpeed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:19'!
traveledDistance

	^ traveledDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:31'!
traveledDistance: aDistance

	traveledDistance _ aDistance! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:23:56'!
activateTurbo

	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:47'!
deactivateTurbo
	
	turboActivated ifFalse: [ self error: self turboAlreadydeActivatedErrorDescription ].
	
	turboActivated _ false! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:13'!
turboAlreadydeActivatedErrorDescription
	
	^'Turbo is already deactivated'! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 4/30/2022 19:10:34'!
isTurboActivated
	
	^turboActivated! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 5/2/2022 14:23:06'!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'HAW 5/2/2022 14:23:47'!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 ! !

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:55'!
FormulaOneCar class
	instanceVariableNames: ''!

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:55'!
FormulaOneCar class
	instanceVariableNames: ''!
!FormulaOneCar class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 18:44:15'!
drivenBy: aDriver 

	^self new initializeDrivenBy: aDriver ! !

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:55'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:55'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!GrandPrix methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:39'!
initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars

	track _ aTrack.
	numberOfLaps _ aNumberOfLaps.
	aCollectionOfCars do: [ :car | car runningInGrandPrix: self ].
! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 22:23:59'!
locationOf: aCar

	^ aCar traveledDistance.	! !
!GrandPrix methodsFor: 'car position' stamp: 'HAW 4/30/2022 19:15:32'!
put: aCar at: aDistance

	| distanceInTrack |
	
	aCar traveledDistance: aDistance.
	
	distanceInTrack _ aDistance \\ track length.
	track put: aCar at: distanceInTrack.
	! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:38:16'!
sectorOf: aCar 

	^ track sectorOf: aCar.! !
!GrandPrix methodsFor: 'length' stamp: 'HAW 4/30/2022 18:43:17'!
length

	^ track length * numberOfLaps! !
!GrandPrix methodsFor: 'simulation' stamp: 'FRT 5/1/2022 09:06:07'!
advance: aTimeLapse
	
	| ix cars |
	
	cars _ track cars asOrderedCollection.
	ix _ 1.
	[ix <= cars size] whileTrue: [ | car |
		car _ cars at: ix.
		self relocate: car after: aTimeLapse.
		ix _ ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'HAW 5/1/2022 17:35:43'!
relocate: aCar after: aTimeLapse 

	| distanceMoved distanceInTrack |
	
	distanceMoved _ aCar speed * aTimeLapse.
	aCar advance: distanceMoved.
	
	distanceInTrack _ aCar traveledDistance \\ track length.
	track put: aCar at: distanceInTrack.! !

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:55'!
GrandPrix class
	instanceVariableNames: ''!

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:55'!
GrandPrix class
	instanceVariableNames: ''!
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:05'!
on: aTrack running: aNumberOfLaps 

	^self on: aTrack running: aNumberOfLaps with: #()! !
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:16'!
on: aTrack running: aNumberOfLaps with: aCollectionOfCars

	^self new initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars! !
!GrandPrix class methodsFor: 'error message' stamp: 'ARM 4/28/2022 15:09:05'!
distanceOutSideRaceTrackLengthErrorMessage

	^'Distance outside Race Track length'! !
!GrandPrix class methodsFor: 'error message' stamp: 'FRT 5/1/2022 12:24:57'!
turboNotAllowedWithRainTiresErrorMessage

	^ 'Turbo not allowed with rain tires'! !

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:56'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:56'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 10:02:21'!
initializeOf: aLength 

	cars _ Dictionary new.
	length _ aLength.! !
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 09:59:49'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55'!
assertValidPosition: aPosition

	length < aPosition ifTrue: [ self error: self class cannotPlacedCarErrorDescription ]! !
!Sector methodsFor: 'car position' stamp: 'HAW 5/1/2022 16:59:05'!
atStartPut: aCar
 
	self put: aCar at: 0*kilometer! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 09:23:35'!
positionOf: aCar
 
	^ cars at: aCar.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55'!
put: aCar at: aPosition
 
	self assertValidPosition: aPosition.
	
	cars at: aCar put: aPosition.
	aCar atSector: self.! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:04:40'!
remove: aCar
 
	cars removeKey: aCar ifAbsent: [].
! !
!Sector methodsFor: 'accessing' stamp: 'FRT 4/30/2022 22:08:51'!
cars
	
	^ cars keys! !
!Sector methodsFor: 'accessing' stamp: 'HAW 5/2/2022 14:26:16'!
length

	^length! !
!Sector methodsFor: 'testing' stamp: 'HAW 5/1/2022 16:54:33'!
includes: aCar

	^ cars includesKey: aCar! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:21:14'!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:07:54'!
assertDriverIsOneSecondOrLess: aCarToActivateTurboTo ofDriverAt: positionOfCarAhead

	| carAhead |
	
	carAhead _ self carAtPosition: positionOfCarAhead.
	
	((positionOfCarAhead / carAhead speed) -
	((cars at: aCarToActivateTurboTo) / aCarToActivateTurboTo speed)) < (1 * second)
		ifFalse: [self error: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription ].! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:06:52'!
carAtPosition: positionOfDriver

	^cars keyAtValue: positionOfDriver! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:08:13'!
positionOfCarAheadOf: aCarToActiveTurboTo ifNone: alternativeClosure

	| sortedPositions carToActivateTurboToPosition |
	
	carToActivateTurboToPosition _ cars at: aCarToActiveTurboTo.
	sortedPositions _ cars asSortedCollection remove: carToActivateTurboToPosition; yourself.
	 
	^ sortedPositions 
		detect: [:aPosition | aPosition > carToActivateTurboToPosition ]
		ifNone: alternativeClosure ! !

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:57'!
Sector class
	instanceVariableNames: ''!

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:57'!
Sector class
	instanceVariableNames: ''!
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:32'!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ self new initializeOf: aLength; withTurbo: true; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:47'!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; withTurbo: false; yourself ! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:24:41'!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:13:07'!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 10:08:26'!
cannotPlacedCarErrorDescription

	^ 'Driver can not be placed outside section'! !
!Sector class methodsFor: 'error message' stamp: 'HAW 4/30/2022 17:05:20'!
lengthMustBePositiveErrorDescription

	^ 'Length must be positive'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 09:54:45'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:57'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:57'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Track methodsFor: 'initialization' stamp: 'HAW 4/30/2022 17:06:50'!
initializeWithSectors: aSectors

	sectors _ aSectors copy.! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18'!
carNotFoundErrorDescription

	^ 'Car not found'! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:03'!
positionOf: aCar
	| accumulatedLength ix sector |
	
	ix _ 1.
	sector _ (sectors at: ix).
	accumulatedLength _ 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength _ accumulatedLength + sector length.
		ix _ ix + 1.
		sector _ (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar).! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:26:38'!
put: aCar at: aPosition

	| ix sector acc |
	
	aPosition > self length ifTrue: [ self error: self class cannotPlacedCarErrorDescription ].

	self remove: aCar.

	ix _ 1.
	sector _ sectors at: ix. 
	acc _ 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc _ acc + sector length.
		ix _ ix + 1.
		sector _ sectors at: ix.
	].

	sector put: aCar at: aPosition - acc.! !
!Track methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:15:27'!
remove: aCar
	
	| currentSector |
	
	currentSector _ self sectorOf: aCar ifNone: [ ^ self ].
	currentSector remove: aCar.
	! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18'!
sectorOf: aCar
	
	^self sectorOf: aCar ifNone: [ self error: self carNotFoundErrorDescription ]! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:47'!
sectorOf: aCar ifNone: aBlock

	 | ix |
	
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | sector |
		sector _	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix _ ix + 1.
	].

	^ aBlock value.! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:10:09'!
cars
	| allCars ix |
	
	allCars _ Set new.
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | s |
		s _ sectors at: ix.
		allCars addAll: s cars.
		ix _ ix + 1.
	].

	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:31:32'!
length

	| acc ix |

	acc _ 0 * kilometer.
	ix _ 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector _ sectors at: ix.
		acc _ acc + sector length.
		ix _ ix + 1.		
	].

	^ acc.
! !
!Track methodsFor: 'testing' stamp: 'FRT 5/1/2022 09:26:52'!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix sector |
	inc _ false.
	ix _ 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector _ sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc _ true]
		ifFalse: [
			ix _ ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s _ sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix _ ix + 1
			]	
		]. 
	^ inc
	! !

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Track class
	instanceVariableNames: ''!

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Track class
	instanceVariableNames: ''!
!Track class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 17:10:08'!
withSectors: sectors

	sectors isEmpty ifTrue: [ self error: self mustHaveSectorsErrorDescription ].
	
	^ self new initializeWithSectors: sectors! !
!Track class methodsFor: 'error messages' stamp: 'FRT 4/29/2022 18:22:32'!
cannotPlacedCarErrorDescription

	^ 'Car cannot be placed in track'! !
!Track class methodsFor: 'error messages' stamp: 'HAW 4/30/2022 17:09:27'!
mustHaveSectorsErrorDescription

	^'Track must have sectors'! !

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 4/30/2022 18:38:56' prior: 50615064!
test01SectorLengthMustBePositive

	self 
		should: [ Sector withTurboOf: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07' prior: 50615072!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector _ Sector withTurboOf: 10 * kilometer.
	outside _ sector length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07' prior: 50615089!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector _ Sector withoutTurboOf: 10*kilometer.
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:20' prior: 50615104!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 20 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:26' prior: 50615125!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:35' prior: 50615143!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:40' prior: 50615168!
test07TrackMustHaveSectors

	self
		should: [ Track withSectors: #() ]
		raise: Error
		withMessageText: Track mustHaveSectorsErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:46' prior: 50615175!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	track _ Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:23:36' prior: 50615187!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	outside _ track length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:24:51' prior: 50615207!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	positionInSector2 _ 5 * kilometer.
	positionInTrack _ sectors first length + positionInSector2.
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:15' prior: 50615231!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	track _ Track withSectors: sectors.
	car1 _ FormulaOneCar drivenBy: #Schumacher.
	car2 _ FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:37' prior: 50615252!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:26:29' prior: 50615270!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track _ Track withSectors: (OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer)).
	numberOfLaps _ 100.
	
	grandPrix _ GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:14' prior: 50615285!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100.
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:18' prior: 50615305!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:27:57' prior: 50615323!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:28:20' prior: 50615345!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:29:34' prior: 50615365!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:40' prior: 50615388!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	sectorA _ Sector withTurboOf: 10 * kilometer.
	sectorB _ Sector withTurboOf: 30 * kilometer.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:48:08' prior: 50615415!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:31' prior: 50615435!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:58' prior: 50615455!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:19:06' prior: 50615476!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:24' prior: 50615498!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:59' prior: 50615519!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'initialization' stamp: 'HAW 5/2/2022 14:12:13' prior: 50615560!
initializeDrivenBy: aDriver 

	driver _ aDriver.
	turboActivated _ false.
	turboActivations _ 0.
	speed _ 0*kilometer/hour.
	traveledDistance _ 0.
	! !
!FormulaOneCar methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:28' prior: 50615568!
runningInGrandPrix: aGrandPrix
	
	grandPrix _ aGrandPrix! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:07' prior: 50615573!
advance: aDistance

	traveledDistance _ traveledDistance + aDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'FRT 4/30/2022 16:33:07' prior: 50615578!
atSector: aSector

	currentSector _ aSector.! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/2/2022 14:11:23' prior: 50615582!
speed

	turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	].

	^speed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/1/2022 17:34:26' prior: 50615591!
speed: newSpeed

	speed _ newSpeed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:19' prior: 50615595!
traveledDistance

	^ traveledDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:31' prior: 50615599!
traveledDistance: aDistance

	traveledDistance _ aDistance! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:23:56' prior: 50615604!
activateTurbo

	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:47' prior: 50615611!
deactivateTurbo
	
	turboActivated ifFalse: [ self error: self turboAlreadydeActivatedErrorDescription ].
	
	turboActivated _ false! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:13' prior: 50615618!
turboAlreadydeActivatedErrorDescription
	
	^'Turbo is already deactivated'! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 4/30/2022 19:10:34' prior: 50615623!
isTurboActivated
	
	^turboActivated! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 5/2/2022 14:23:06' prior: 50615627!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'HAW 5/2/2022 14:23:47' prior: 50615632!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 ! !

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
FormulaOneCar class
	instanceVariableNames: ''!

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
FormulaOneCar class
	instanceVariableNames: ''!
!FormulaOneCar class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 18:44:15' prior: 50615648!
drivenBy: aDriver 

	^self new initializeDrivenBy: aDriver ! !

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!GrandPrix methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:39' prior: 50615669!
initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars

	track _ aTrack.
	numberOfLaps _ aNumberOfLaps.
	aCollectionOfCars do: [ :car | car runningInGrandPrix: self ].
! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 22:23:59' prior: 50615678!
locationOf: aCar

	^ aCar traveledDistance.	! !
!GrandPrix methodsFor: 'car position' stamp: 'HAW 4/30/2022 19:15:32' prior: 50615682!
put: aCar at: aDistance

	| distanceInTrack |
	
	aCar traveledDistance: aDistance.
	
	distanceInTrack _ aDistance \\ track length.
	track put: aCar at: distanceInTrack.
	! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:38:16' prior: 50615690!
sectorOf: aCar 

	^ track sectorOf: aCar.! !
!GrandPrix methodsFor: 'length' stamp: 'HAW 4/30/2022 18:43:17' prior: 50615694!
length

	^ track length * numberOfLaps! !
!GrandPrix methodsFor: 'simulation' stamp: 'FRT 5/1/2022 09:06:07' prior: 50615698!
advance: aTimeLapse
	
	| ix cars |
	
	cars _ track cars asOrderedCollection.
	ix _ 1.
	[ix <= cars size] whileTrue: [ | car |
		car _ cars at: ix.
		self relocate: car after: aTimeLapse.
		ix _ ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'HAW 5/1/2022 17:35:43' prior: 50615707!
relocate: aCar after: aTimeLapse 

	| distanceMoved distanceInTrack |
	
	distanceMoved _ aCar speed * aTimeLapse.
	aCar advance: distanceMoved.
	
	distanceInTrack _ aCar traveledDistance \\ track length.
	track put: aCar at: distanceInTrack.! !

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
GrandPrix class
	instanceVariableNames: ''!

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
GrandPrix class
	instanceVariableNames: ''!
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:05' prior: 50615727!
on: aTrack running: aNumberOfLaps 

	^self on: aTrack running: aNumberOfLaps with: #()! !
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:16' prior: 50615733!
on: aTrack running: aNumberOfLaps with: aCollectionOfCars

	^self new initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars! !
!GrandPrix class methodsFor: 'error message' stamp: 'ARM 4/28/2022 15:09:05' prior: 50615741!
distanceOutSideRaceTrackLengthErrorMessage

	^'Distance outside Race Track length'! !
!GrandPrix class methodsFor: 'error message' stamp: 'FRT 5/1/2022 12:24:57' prior: 50615747!
turboNotAllowedWithRainTiresErrorMessage

	^ 'Turbo not allowed with rain tires'! !

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 10:02:21' prior: 50615768!
initializeOf: aLength 

	cars _ Dictionary new.
	length _ aLength.! !
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 09:59:49' prior: 50615773!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55' prior: 50615777!
assertValidPosition: aPosition

	length < aPosition ifTrue: [ self error: self class cannotPlacedCarErrorDescription ]! !
!Sector methodsFor: 'car position' stamp: 'HAW 5/1/2022 16:59:05' prior: 50615783!
atStartPut: aCar
 
	self put: aCar at: 0*kilometer! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 09:23:35' prior: 50615787!
positionOf: aCar
 
	^ cars at: aCar.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55' prior: 50615791!
put: aCar at: aPosition
 
	self assertValidPosition: aPosition.
	
	cars at: aCar put: aPosition.
	aCar atSector: self.! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:04:40' prior: 50615797!
remove: aCar
 
	cars removeKey: aCar ifAbsent: [].
! !
!Sector methodsFor: 'accessing' stamp: 'FRT 4/30/2022 22:08:51' prior: 50615801!
cars
	
	^ cars keys! !
!Sector methodsFor: 'accessing' stamp: 'HAW 5/2/2022 14:26:16' prior: 50615804!
length

	^length! !
!Sector methodsFor: 'testing' stamp: 'HAW 5/1/2022 16:54:33' prior: 50615807!
includes: aCar

	^ cars includesKey: aCar! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:21:14' prior: 50615811!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:07:54' prior: 50615828!
assertDriverIsOneSecondOrLess: aCarToActivateTurboTo ofDriverAt: positionOfCarAhead

	| carAhead |
	
	carAhead _ self carAtPosition: positionOfCarAhead.
	
	((positionOfCarAhead / carAhead speed) -
	((cars at: aCarToActivateTurboTo) / aCarToActivateTurboTo speed)) < (1 * second)
		ifFalse: [self error: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription ].! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:06:52' prior: 50615842!
carAtPosition: positionOfDriver

	^cars keyAtValue: positionOfDriver! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:08:13' prior: 50615847!
positionOfCarAheadOf: aCarToActiveTurboTo ifNone: alternativeClosure

	| sortedPositions carToActivateTurboToPosition |
	
	carToActivateTurboToPosition _ cars at: aCarToActiveTurboTo.
	sortedPositions _ cars asSortedCollection remove: carToActivateTurboToPosition; yourself.
	 
	^ sortedPositions 
		detect: [:aPosition | aPosition > carToActivateTurboToPosition ]
		ifNone: alternativeClosure ! !

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Sector class
	instanceVariableNames: ''!

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Sector class
	instanceVariableNames: ''!
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:32' prior: 50615871!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ self new initializeOf: aLength; withTurbo: true; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:47' prior: 50615880!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; withTurbo: false; yourself ! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:24:41' prior: 50615889!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:13:07' prior: 50615896!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 10:08:26' prior: 50615902!
cannotPlacedCarErrorDescription

	^ 'Driver can not be placed outside section'! !
!Sector class methodsFor: 'error message' stamp: 'HAW 4/30/2022 17:05:20' prior: 50615907!
lengthMustBePositiveErrorDescription

	^ 'Length must be positive'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 09:54:45' prior: 50615912!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Track methodsFor: 'initialization' stamp: 'HAW 4/30/2022 17:06:50' prior: 50615933!
initializeWithSectors: aSectors

	sectors _ aSectors copy.! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18' prior: 50615937!
carNotFoundErrorDescription

	^ 'Car not found'! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:03' prior: 50615941!
positionOf: aCar
	| accumulatedLength ix sector |
	
	ix _ 1.
	sector _ (sectors at: ix).
	accumulatedLength _ 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength _ accumulatedLength + sector length.
		ix _ ix + 1.
		sector _ (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar).! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:26:38' prior: 50615954!
put: aCar at: aPosition

	| ix sector acc |
	
	aPosition > self length ifTrue: [ self error: self class cannotPlacedCarErrorDescription ].

	self remove: aCar.

	ix _ 1.
	sector _ sectors at: ix. 
	acc _ 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc _ acc + sector length.
		ix _ ix + 1.
		sector _ sectors at: ix.
	].

	sector put: aCar at: aPosition - acc.! !
!Track methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:15:27' prior: 50615969!
remove: aCar
	
	| currentSector |
	
	currentSector _ self sectorOf: aCar ifNone: [ ^ self ].
	currentSector remove: aCar.
	! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18' prior: 50615976!
sectorOf: aCar
	
	^self sectorOf: aCar ifNone: [ self error: self carNotFoundErrorDescription ]! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:47' prior: 50615982!
sectorOf: aCar ifNone: aBlock

	 | ix |
	
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | sector |
		sector _	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix _ ix + 1.
	].

	^ aBlock value.! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:10:09' prior: 50615991!
cars
	| allCars ix |
	
	allCars _ Set new.
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | s |
		s _ sectors at: ix.
		allCars addAll: s cars.
		ix _ ix + 1.
	].

	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:31:32' prior: 50615999!
length

	| acc ix |

	acc _ 0 * kilometer.
	ix _ 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector _ sectors at: ix.
		acc _ acc + sector length.
		ix _ ix + 1.		
	].

	^ acc.
! !
!Track methodsFor: 'testing' stamp: 'FRT 5/1/2022 09:26:52' prior: 50616007!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix sector |
	inc _ false.
	ix _ 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector _ sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc _ true]
		ifFalse: [
			ix _ ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s _ sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix _ ix + 1
			]	
		]. 
	^ inc
	! !

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Track class
	instanceVariableNames: ''!

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Track class
	instanceVariableNames: ''!
!Track class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 17:10:08' prior: 50616031!
withSectors: sectors

	sectors isEmpty ifTrue: [ self error: self mustHaveSectorsErrorDescription ].
	
	^ self new initializeWithSectors: sectors! !
!Track class methodsFor: 'error messages' stamp: 'FRT 4/29/2022 18:22:32' prior: 50616038!
cannotPlacedCarErrorDescription

	^ 'Car cannot be placed in track'! !
!Track class methodsFor: 'error messages' stamp: 'HAW 4/30/2022 17:09:27' prior: 50616043!
mustHaveSectorsErrorDescription

	^'Track must have sectors'! !
!GrandPrix methodsFor: 'simulation' stamp: 'AS 4/26/2023 21:13:03' prior: 50616718!
advance: aTimeLapse
	
	| cars |
	
	cars := track cars asOrderedCollection.
	cars do: [ :car | self relocate: car after: aTimeLapse ]
	
	"
	| ix cars |
	
	cars := track cars asOrderedCollection.
	ix := 1.
	[ix <= cars size] whileTrue: [ | car |
		car := cars at: ix.
		self relocate: car after: aTimeLapse.
		ix := ix + 1.
	]
"! !
!GrandPrix methodsFor: 'simulation' stamp: 'AS 4/26/2023 21:13:16' prior: 50617090!
advance: aTimeLapse
	
	| cars |
	
	cars := track cars asOrderedCollection.
	cars do: [ :car | self relocate: car after: aTimeLapse ]
	! !
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:14:48' prior: 50617029!
cars
	| allCars |
	
	allCars := Set new.
	
	sectors do: [ :sector | allCars addAll: sector cars ].
	
	"
	
	ix := 1.
	[ix <= sectors size] whileTrue: [ | s |
		s := sectors at: ix.
		allCars addAll: s cars.
		ix := ix + 1.
	].
"
	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:16:16' prior: 50617110!
cars
	| allCars |
	
	allCars := Set new.
	
	"sectors do: [ :sector | allCars addAll: sector cars ]."
	
	^sectors inject: Set new into: [ :set :sector | set addAll: sector cars ].
	
	"^ allCars"
	! !
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:16:59' prior: 50617121!
cars
	| allCars |
	
	allCars := Set new.
	
	sectors do: [ :sector | allCars addAll: sector cars ].
	
	^ allCars
	! !
!Track class methodsFor: 'car position' stamp: 'AS 4/26/2023 21:19:50'!
carNotFoundErrorDescription

	^ 'Car not found'! !

!methodRemoval: Track #carNotFoundErrorDescription stamp: 'AS 4/26/2023 23:00:58'!
carNotFoundErrorDescription

	^ 'Car not found'!
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:23:10' prior: 50617037!
length	

	| acc ix |

	^sectors inject: 0 * kilometer into: [ :length :sector | length + sector length ].

"
	acc := 0 * kilometer.
	ix := 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector := sectors at: ix.
		acc := acc + sector length.
		ix := ix + 1.		
	].

	^ acc. "
! !
!Track methodsFor: 'accessing' stamp: 'AS 4/26/2023 21:23:25' prior: 50617145!
length	

	^sectors inject: 0 * kilometer into: [ :length :sector | length + sector length ].! !

!classDefinition: #SectorTurboAdmited category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #SectorTurboAdmited category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #SectorTurboNotAdmited category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #SectorTurboNotAdmited category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:00:58'!
Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 21:28:19' overrides: 50616839!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!SectorTurboNotAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 21:28:19' overrides: 50616839!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !

!methodRemoval: Sector #activateTurboTo: stamp: 'AS 4/26/2023 23:00:59'!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
!
!SectorTurboNotAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 22:49:47' prior: 50617213!
activateTurboTo: aCarToActivateTurboTo

	self error: Sector turboNotAllowedErrorDescription
! !
!Sector methodsFor: 'turbo' stamp: 'AS 4/26/2023 22:50:24'!
activateTurboTo: aCarToActivateTurboTo
	
	self subclassResponsibility! !
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 22:51:13' prior: 50617195 overrides: 50617252!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	positionOfCarAhead := self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:53:10' prior: 50616901!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ SectorTurboAdmited new initializeOf: aLength; withTurbo: true; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:54:47' prior: 50616910!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ SectorTurboNotAdmited new initializeOf: aLength; withTurbo: false; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:55:42' prior: 50617273!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ SectorTurboAdmited new initializeOf: aLength; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 4/26/2023 22:55:51' prior: 50617283!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ SectorTurboNotAdmited new initializeOf: aLength; yourself ! !

!methodRemoval: Sector #withTurbo: stamp: 'AS 4/26/2023 23:00:59'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
!
!SectorTurboAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 22:56:36' overrides: 50616946!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !
!SectorTurboNotAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 22:56:36' overrides: 50616946!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!methodRemoval: Sector class #turboNotAllowedErrorDescription stamp: 'AS 4/26/2023 23:00:59'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'!

!methodRemoval: SectorTurboNotAdmited class #turboNotAllowedErrorDescription stamp: 'AS 4/26/2023 23:00:59'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'!
!SectorTurboNotAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 22:57:09'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!methodRemoval: SectorTurboAdmited class #turboNotAllowedErrorDescription stamp: 'AS 4/26/2023 23:00:59'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:01:31' prior: 50616089!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector := Sector withoutTurboOf: 10*kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: SectorTurboNotAdmited turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:01:35'!
FAILURE!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:03:21'!
FAILURE!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:03:21'!
FAILURE!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:05:57' prior: 50617349!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector := SectorTurboNotAdmited withoutTurboOf: 10*kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: SectorTurboNotAdmited turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!SectorTurboNotAdmited class methodsFor: 'nil' stamp: 'AS 4/26/2023 23:06:48' overrides: 16785654!
new: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; yourself ! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:07:34' prior: 50617375!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector := SectorTurboNotAdmited new: 10*kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: SectorTurboNotAdmited turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:07:37'!
FAILURE!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:07:37'!
FAILURE!
!SectorTurboNotAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 23:09:02' prior: 50617247 overrides: 50617252!
activateTurboTo: aCarToActivateTurboTo

	self error: SectorTurboNotAdmited turboNotAllowedErrorDescription
! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 23:09:05'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 23:09:05'!
PASSED!
!Sector methodsFor: 'initialization' stamp: 'AS 4/26/2023 23:10:23' prior: 50616789!
initializeOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	cars := Dictionary new.
	length := aLength.! !

!methodRemoval: Sector class #withTurboOf: stamp: 'AS 4/26/2023 23:10:30'!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ SectorTurboAdmited new initializeOf: aLength; yourself !

!methodRemoval: Sector class #withoutTurboOf: stamp: 'AS 4/26/2023 23:10:34'!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ SectorTurboNotAdmited new initializeOf: aLength; yourself !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:10:41'!
FAILURE!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:10:41'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 23:10:41'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 23:10:41'!
ERROR!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:10:50'!
FAILURE!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:11:28' prior: 50616064!
test01SectorLengthMustBePositive

	self 
		should: [ SectorTurboAdmited new: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:11:31'!
FAILURE!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:11:35'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:11:38'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:11:56' prior: 50616072!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := SectorTurboAdmited new: 10 * kilometer.
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:11:58'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:12:08'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:12:36' prior: 50617654!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := SectorTurboAdmited new: (10 * kilometer).
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:12:38'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:12:58' prior: 50617679!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := (SectorTurboAdmited new): (10 * kilometer).
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:13:00'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:13:11' prior: 50617700!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := (SectorTurboAdmited new): 10 * kilometer.
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:13:14'!
ERROR!
!SectorTurboAdmited class methodsFor: 'nil' stamp: 'AS 4/26/2023 23:14:08' overrides: 16785654!
new: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; yourself ! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:14:15'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:14:15'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 23:14:15'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 23:14:15'!
ERROR!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 23:14:16'!
ERROR!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 23:14:16'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:14:26' prior: 50617721!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := SectorTurboAdmited new: 10 * kilometer.
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:14:28'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:14:47' prior: 50616104!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 20 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:14:49'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:15:04' prior: 50616125!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:15:05'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:15:20' prior: 50616144!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:15:21'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:15:43' prior: 50616177!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
	track := Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 23:15:44'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:16:00' prior: 50616189!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
	
	track := Track withSectors: sectors.
	outside := track length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 23:16:02'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:16:20' prior: 50616210!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
		
	positionInSector2 := 5 * kilometer.
	positionInTrack := sectors first length + positionInSector2.
	
	track := Track withSectors: sectors.
	car := FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 23:16:24'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:16:43' prior: 50616234!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
		
	track := Track withSectors: sectors.
	car1 := FormulaOneCar drivenBy: #Schumacher.
	car2 := FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 23:16:45'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:17:03' prior: 50616255!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
	
	track := Track withSectors: sectors.
	car := FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:17:17' prior: 50616274!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track := Track withSectors: (OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer)).
	numberOfLaps := 100.
	
	grandPrix := GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 23:17:20'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 23:17:22'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:17:37' prior: 50616289!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (SectorTurboAdmited new: 10 * kilometer)))
		running: 100.
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	hamilton := FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 23:17:38'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:17:47' prior: 50616310!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (SectorTurboAdmited new: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 23:17:48'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:17:59' prior: 50616328!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 23:18:06'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:18:19' prior: 50616350!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 23:18:21'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:18:35' prior: 50616370!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	
	sectors := OrderedCollection 
		with: (SectorTurboAdmited new: 10 * kilometer)
		with: (SectorTurboNotAdmited new: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 23:18:37'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:18:50' prior: 50616393!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	sectorA := SectorTurboAdmited new: 10 * kilometer.
	sectorB := SectorTurboAdmited new: 30 * kilometer.
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 23:18:51'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:18:59' prior: 50616421!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 23:19:00'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:19:06' prior: 50616441!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 23:19:07'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:19:12' prior: 50616462!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 23:19:14'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:19:22' prior: 50616484!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 23:19:23'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:19:29' prior: 50616507!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 23:19:30'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:19:36' prior: 50616529!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 23:19:36'!
PASSED!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 23:19:42'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 23:19:42'!
PASSED!
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 23:21:08' overrides: 50616856!
assertDriverIsOneSecondOrLess: aCarToActivateTurboTo ofDriverAt: positionOfCarAhead

	| carAhead |
	
	carAhead := self carAtPosition: positionOfCarAhead.
	
	((positionOfCarAhead / carAhead speed) -
	((cars at: aCarToActivateTurboTo) / aCarToActivateTurboTo speed)) < (1 * second)
		ifFalse: [self error: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription ].! !
!SectorTurboAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 23:21:51' overrides: 50616919!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'! !
!SectorTurboNotAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 23:21:51' overrides: 50616919!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'! !

!methodRemoval: Sector class #cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription stamp: 'AS 4/26/2023 23:21:51'!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'!
!SectorTurboAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 23:21:57' overrides: 50616927!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'! !
!SectorTurboNotAdmited class methodsFor: 'error message' stamp: 'AS 4/26/2023 23:21:57' overrides: 50616927!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'! !

!methodRemoval: Sector class #cannotActivateTurboWhenNoCarAheadErrorDescription stamp: 'AS 4/26/2023 23:21:57'!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'!

!methodRemoval: SectorTurboNotAdmited class #cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription stamp: 'AS 4/26/2023 23:22:05'!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'!

!methodRemoval: SectorTurboNotAdmited class #cannotActivateTurboWhenNoCarAheadErrorDescription stamp: 'AS 4/26/2023 23:22:07'!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'!
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 23:22:32' prior: 50617258 overrides: 50617252!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	positionOfCarAhead := self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: SectorTurboAdmited cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!SectorTurboAdmited methodsFor: 'turbo' stamp: 'AS 4/26/2023 23:22:38' prior: 50618466 overrides: 50616856!
assertDriverIsOneSecondOrLess: aCarToActivateTurboTo ofDriverAt: positionOfCarAhead

	| carAhead |
	
	carAhead := self carAtPosition: positionOfCarAhead.
	
	((positionOfCarAhead / carAhead speed) -
	((cars at: aCarToActivateTurboTo) / aCarToActivateTurboTo speed)) < (1 * second)
		ifFalse: [self error: SectorTurboAdmited cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription ].! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:22:40'!
ERROR!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:22:40'!
ERROR!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 4/26/2023 23:22:40'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:22:44'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:22:55' prior: 50617860!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 20 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: SectorTurboAdmited cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 4/26/2023 23:22:58'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 4/26/2023 23:23:17' prior: 50617908!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := SectorTurboAdmited new: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: SectorTurboAdmited cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 4/26/2023 23:23:18'!
PASSED!

Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Turbo category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:25:00'!
Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Turbo subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboActivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:25:25'!
Turbo subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRenamed: #TurboActivated as: #TurboActive stamp: 'AS 4/26/2023 23:25:46'!
Smalltalk renameClassNamed: #TurboActivated as: #TurboActive!

Turbo subclass: #TurboInactive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboInactive category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 4/26/2023 23:25:57'!
Turbo subclass: #TurboInactive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!TurboActive methodsFor: 'nil' stamp: 'AS 4/26/2023 23:26:39'!
isActive
	
	^true! !
!TurboInactive methodsFor: 'no messages' stamp: 'AS 4/26/2023 23:26:56'!
isActive
	
	^false! !
!Turbo methodsFor: 'no messages' stamp: 'AS 4/26/2023 23:27:10'!
isActive
	
	self subclassResponsibility ! !

----SNAPSHOT----(26 April 2023 23:29:54) CuisUniversity-5706.image priorSource: 8963121!

----End fileIn of E:\ISW1\Parciales\2021\2C\Primer Parcial\ISW1-2021-2C-1erParcial.st----!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/26/2023 23:31:15'!
PASSED!
!City methodsFor: 'nil' stamp: 'AS 4/26/2023 23:32:15' overrides: 16920235!
initialize
	
	services := OrderedCollection new! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:32:45' prior: 50619131!
addService: aService 

	services add: aService.! !
!City methodsFor: 'initialization' stamp: 'AS 4/26/2023 23:33:04' prior: 50619452 overrides: 16920235!
initialize
	
	services := OrderedCollection new.
	zones := OrderedCollection new! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:33:22' prior: 50619137!
addZone: aZone

	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #Commertial ifTrue: [
		self energyAvailable < (2 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (8 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !

Zone subclass: #Residential
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Residential category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/26/2023 23:33:41'!
Zone subclass: #Residential
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Zone subclass: #Commertial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Commertial category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/26/2023 23:33:49'!
Zone subclass: #Commertial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Zone subclass: #Industrial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Industrial category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/26/2023 23:33:53'!
Zone subclass: #Industrial
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!Residential methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:34:17' overrides: 50619333!
type
	
	^ type! !
!Commertial methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:34:17' overrides: 50619333!
type
	
	^ type! !
!Industrial methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:34:17' overrides: 50619333!
type
	
	^ type! !

!methodRemoval: Zone #type stamp: 'AS 4/26/2023 23:34:17'!
type
	
	^ type!
!Zone methodsFor: 'initialization' stamp: 'AS 4/26/2023 23:34:42'!
type
	
	self subclassResponsibility ! !
!Commertial methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:34:49' prior: 50619536 overrides: 50619546!
type
	
	^ #Commertial! !
!Industrial methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:34:58' prior: 50619540 overrides: 50619546!
type
	
	^ #Industrial! !
!Residential methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:35:07' prior: 50619532 overrides: 50619546!
type
	
	^ #Residential! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/26/2023 23:35:11'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/26/2023 23:35:11'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/26/2023 23:35:11'!
ERROR!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:36:27' prior: 50619468!
addZone: aZone

	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #Commertial ifTrue: [
		self energyAvailable < (8 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (2 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/26/2023 23:36:29'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/26/2023 23:36:29'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/26/2023 23:36:29'!
ERROR!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/26/2023 23:37:33'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/26/2023 23:37:33'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/26/2023 23:37:33'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/26/2023 23:37:34'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/26/2023 23:37:34'!
ERROR!
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:38:49' prior: 50618786!
commertialZone

	^ Commertial new withType: #Commertial! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:00' prior: 50618790!
industrialZone

	^ Industrial new withType: #Industrial! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:13' prior: 50618794!
residentialZone

	^ Residential new! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:18' prior: 50619896!
industrialZone

	^ Industrial new! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:22' prior: 50619891!
commertialZone

	^ Commertial new! !

!classRenamed: #Commertial as: #CommertialZone stamp: 'AS 4/26/2023 23:39:31'!
Smalltalk renameClassNamed: #Commertial as: #CommertialZone!
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:31' prior: 50619911!
commertialZone

	^ CommertialZone new! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:31' prior: 50619172!
energyConsumption
	
	| index total |
	
	zones ifNil: [zones _ OrderedCollection new].
	
	index _ 1.
	total _ 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #Residential ifTrue: [ total _ total + ((5 * ep) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total _ total +((8 * ep) * zone getNumberOfCells) ].	
		zone type = #Industrial ifTrue: [ total _ total + ((10 * ep) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:31' prior: 50619664!
addZone: aZone

	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #CommertialZone ifTrue: [
		self energyAvailable < (8 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (2 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #Industrial ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:31' prior: 50619222!
waterConsumption
	
	| index total |
	
	zones ifNil: [zones _ OrderedCollection new].
	
	index _ 1.
	total _ 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #Residential ifTrue: [ total _ total + ((9 * wp) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total _ total + ((2 * wp) * zone getNumberOfCells) ].	
		zone type = #Industrial ifTrue: [ total _ total + ((10 * wp) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:31' prior: 50619551 overrides: 50619546!
type
	
	^ #CommertialZone! !

!classRenamed: #Industrial as: #IndustrialZone stamp: 'AS 4/26/2023 23:39:57'!
Smalltalk renameClassNamed: #Industrial as: #IndustrialZone!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:57' prior: 50619925!
energyConsumption
	
	| index total |
	
	zones ifNil: [zones _ OrderedCollection new].
	
	index _ 1.
	total _ 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #Residential ifTrue: [ total _ total + ((5 * ep) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total _ total +((8 * ep) * zone getNumberOfCells) ].	
		zone type = #IndustrialZone ifTrue: [ total _ total + ((10 * ep) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:57' prior: 50619556 overrides: 50619546!
type
	
	^ #IndustrialZone! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:57' prior: 50619906!
industrialZone

	^ IndustrialZone new! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:57' prior: 50619944!
addZone: aZone

	aZone type = #Residential ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #CommertialZone ifTrue: [
		self energyAvailable < (8 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (2 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #IndustrialZone ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:39:57' prior: 50619973!
waterConsumption
	
	| index total |
	
	zones ifNil: [zones _ OrderedCollection new].
	
	index _ 1.
	total _ 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #Residential ifTrue: [ total _ total + ((9 * wp) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total _ total + ((2 * wp) * zone getNumberOfCells) ].	
		zone type = #IndustrialZone ifTrue: [ total _ total + ((10 * wp) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !

!classRenamed: #Residential as: #ResidentialZone stamp: 'AS 4/26/2023 23:40:08'!
Smalltalk renameClassNamed: #Residential as: #ResidentialZone!
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:40:08' prior: 50619561 overrides: 50619546!
type
	
	^ #ResidentialZone! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:40:08' prior: 50620002!
energyConsumption
	
	| index total |
	
	zones ifNil: [zones _ OrderedCollection new].
	
	index _ 1.
	total _ 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #ResidentialZone ifTrue: [ total _ total + ((5 * ep) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total _ total +((8 * ep) * zone getNumberOfCells) ].	
		zone type = #IndustrialZone ifTrue: [ total _ total + ((10 * ep) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:40:08' prior: 50620031!
addZone: aZone

	aZone type = #ResidentialZone ifTrue: [
		self energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	aZone type = #CommertialZone ifTrue: [
		self energyAvailable < (8 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (2 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
		self hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
	].

	aZone type = #IndustrialZone ifTrue: [
		self energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		self waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	].

	zones add: aZone.
! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:40:08' prior: 50620060!
waterConsumption
	
	| index total |
	
	zones ifNil: [zones _ OrderedCollection new].
	
	index _ 1.
	total _ 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #ResidentialZone ifTrue: [ total _ total + ((9 * wp) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total _ total + ((2 * wp) * zone getNumberOfCells) ].	
		zone type = #IndustrialZone ifTrue: [ total _ total + ((10 * wp) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:40:08' prior: 50619203!
hasResidentialZones

	| index |
	zones ifNil: [ ^ false ].

	index _ 1.
	
	[index <= zones size] whileTrue: [ | zone |
		zone _ zones at: index.
		zone type = #ResidentialZone ifTrue: [ ^ true].	
		index := index + 1.
	].

	^ false.
! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/26/2023 23:40:08' prior: 50619901!
residentialZone

	^ ResidentialZone new! !

Object subclass: #Zone
	instanceVariableNames: 'numberOfCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #Zone category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/26/2023 23:40:16'!
Object subclass: #Zone
	instanceVariableNames: 'numberOfCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/26/2023 23:40:19'!
PASSED!

Service subclass: #SolarPlant
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #SolarPlant category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/26/2023 23:43:09'!
Service subclass: #SolarPlant
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

Service subclass: #WaterTower
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #WaterTower category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/26/2023 23:43:21'!
Service subclass: #WaterTower
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!Service methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:43:34' prior: 50619291!
type
	
	self subclassResponsibility ! !

!methodRemoval: Service #initializeWithType: stamp: 'AS 4/26/2023 23:43:49'!
initializeWithType: aServiceType 

	type _ aServiceType.!

!methodRemoval: Zone #initializeWithType: stamp: 'AS 4/26/2023 23:43:53'!
initializeWithType: aZoneType 

	type := aZoneType.!
!SolarPlant methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:44:25' overrides: 50620307!
type
	
	^#SolarPlant! !
!WaterTower methodsFor: 'accessing' stamp: 'AS 4/26/2023 23:44:47' overrides: 50620307!
type
	
	^#WaterTower! !
!CityTest methodsFor: 'services' stamp: 'AS 4/26/2023 23:45:01' prior: 50618798!
solarPlant

	^ SolarPlant new! !
!CityTest methodsFor: 'services' stamp: 'AS 4/26/2023 23:45:08' prior: 50619094!
waterTower

	^ WaterTower new! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/26/2023 23:45:10'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:23:08'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:24:59' prior: 50620108!
addZone: aZone

	aZone assertIfCanNotAddToCity: self.
	zones add: aZone.
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
FAILURE!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
FAILURE!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
FAILURE!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:25:06'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:25:06'!
FAILURE!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:25:06'!
ERROR!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:25:11'!
ERROR!
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:25:33'!
assertIfCanNotAddToCity: aCity 
	self shouldBeImplemented.! !
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:26:10' prior: 50620643!
assertIfCanNotAddToCity: aCity 

	aCity energyAvailable < (5 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (9 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
! !

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:26:12'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:26:14'!
ERROR!
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:26:23'!
assertIfCanNotAddToCity: aCity 
	self shouldBeImplemented.! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:27:16' prior: 50620667!
assertIfCanNotAddToCity: aCity 

	aCity energyAvailable < (8 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (2 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
		
	aCity hasResidentialZones ifFalse: [ self error: City cannotAddCommertialZoneErrorDescription ].
! !

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:27:17'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:27:19'!
ERROR!
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:27:25'!
assertIfCanNotAddToCity: aCity 
	self shouldBeImplemented.! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:27:47' prior: 50620693!
assertIfCanNotAddToCity: aCity 

	aCity energyAvailable < (10 * ep) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
	aCity waterAvailable < (10 * wp) ifTrue: [ self error: City cannotAddZoneErrorDescription ].
! !

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:27:49'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:27:50'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:27:51'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:27:52'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:27:52'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:27:53'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:27:53'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:27:54'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:27:54'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:27:54'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:27:55'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:27:55'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:27:56'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:27:56'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:27:56'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:27:57'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:30:03' prior: 50620089!
energyConsumption
	
	| index total |
	
	index := 1.
	total := 0.
	
	
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #ResidentialZone ifTrue: [ total := total + ((5 * ep) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total := total +((8 * ep) * zone getNumberOfCells) ].	
		zone type = #IndustrialZone ifTrue: [ total := total + ((10 * ep) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !
!Zone methodsFor: 'nil' stamp: 'AS 4/27/2023 11:30:28'!
energyConsumption
	
	self subclassResponsibility ! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:31:34' overrides: 50620791!
energyConsumption
	
	^(8 * ep)! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:31:59' overrides: 50620791!
energyConsumption
		
	^(10 * ep)! !
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:32:20' overrides: 50620791!
energyConsumption
		
	^(5 * ep)! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:33:11' prior: 50620774!
energyConsumption
	
	| index total |
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		total := zone energyConsumption * zone getNumberOfCells.
		index := index + 1.
	].

	^ total.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
FAILURE!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
FAILURE!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
FAILURE!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:33:12'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:33:27' prior: 50620810!
energyConsumption
	
	| index total |
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		total := total + (zone energyConsumption * zone getNumberOfCells).
		index := index + 1.
	].

	^ total.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:33:29'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:34:41' prior: 50620920!
energyConsumption
		
	^zones sum: [:zone | (zone energyConsumption * zone getNumberOfCells)] ifEmpty: [0 * ep]
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:34:44'!
PASSED!
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:35:10'!
totalEnergyConsumption
	
	self subclassResponsibility ! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:35:35' overrides: 50621136!
totalEnergyConsumption
	
	^(8 * ep)! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:35:51' prior: 50621141 overrides: 50621136!
totalEnergyConsumption
	
	^(8 * ep) * numberOfCells ! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:36:05' overrides: 50621136!
totalEnergyConsumption
		
	^(10 * ep) * numberOfCells ! !
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:36:40' overrides: 50621136!
totalEnergyConsumption
		
	^(5 * ep) * numberOfCells ! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:39:48' prior: 50621030!
energyConsumption
		
	^zones sum: [:zone | zone totalEnergyConsumption] ifEmpty: [0 * ep]
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:39:50'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:40:36'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:40:59'!
ERROR!
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:41:35' prior: 50621157 overrides: 50621136!
totalEnergyConsumption
		
	^((5 * ep) * numberOfCells)! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:41:37'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:41:43'!
ERROR!
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:42:56' prior: 50621146 overrides: 50621136!
totalEnergyConsumption
	
	^(8 * ep) * self getNumberOfCells ! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:43:02' prior: 50621151 overrides: 50621136!
totalEnergyConsumption
		
	^(10 * ep) * self getNumberOfCells ! !
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:43:12' prior: 50621371 overrides: 50621136!
totalEnergyConsumption
		
	^(5 * ep) * self getNumberOfCells ! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:43:14'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:44:09' prior: 50619190!
energyProduced
	
	| index total |
	
	index := 1.
	total := 0 * ep.
	
	[index <= services size] whileTrue: [ | service |
		service := services at: index.
		service type = #SolarPlant ifTrue: [ total := total + (500 * ep)].	
		index := index + 1.
	].

	^ total.! !
!Service methodsFor: 'nil' stamp: 'AS 4/27/2023 11:45:05'!
energyProduced
	
	self subclassResponsibility ! !
!SolarPlant methodsFor: 'nil' stamp: 'AS 4/27/2023 11:45:25' overrides: 50621608!
energyProduced

	^(500 * ep)! !
!WaterTower methodsFor: 'nil' stamp: 'AS 4/27/2023 11:45:35' overrides: 50621608!
energyProduced

	^(0 * ep)! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:47:30' prior: 50621597!
energyProduced
	
	^services sum: [:service | service energyProduced] ifEmpty: [ 0 * ep]
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:47:32'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:53:12' prior: 50620156!
hasResidentialZones

	^zones anySatisfy: [:zone | zone isKindOf: ResidentialZone]
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:53:14'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:53:36' prior: 50620137!
waterConsumption
	
	| index total |
	
	index := 1.
	total := 0.
	
	[index <= zones size] whileTrue: [ | zone |
		zone := zones at: index.
		zone type = #ResidentialZone ifTrue: [ total := total + ((9 * wp) * zone getNumberOfCells) ].	
		zone type = #CommertialZone ifTrue: [ total := total + ((2 * wp) * zone getNumberOfCells) ].	
		zone type = #IndustrialZone ifTrue: [ total := total + ((10 * wp) * zone getNumberOfCells) ].	
		index := index + 1.
	].

	^ total.! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:53:37'!
PASSED!
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:54:17'!
waterConsumption
	
	self subclassResponsibility ! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:54:39' overrides: 50621948!
waterConsumption
	
	^(9 * wp)! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:54:58' overrides: 50621948!
waterConsumption
	
	^(10 * wp)! !
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:55:17' overrides: 50621948!
waterConsumption
	
	^(10 * wp)! !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:55:37'!
totalWaterConsumption
	
	self subclassResponsibility ! !
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:55:53' overrides: 50621967!
totalWaterConsumption
	
	^(9 * wp) * self getNumberOfCells ! !
!IndustrialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:56:06' overrides: 50621967!
totalWaterConsumption
	
	^(10 * wp) * self getNumberOfCells ! !
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:56:20' overrides: 50621967!
totalWaterConsumption
	
	^(10 * wp) * self getNumberOfCells ! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:57:16' prior: 50621831!
waterConsumption
	

	^zones sum: [:zone | zone totalWaterConsumption ] ifEmpty: [0 * wp]	! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:57:19' prior: 50621989!
waterConsumption
	
	^zones sum: [:zone | zone totalWaterConsumption ] ifEmpty: [0 * wp]	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:57:20'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:57:20'!
FAILURE!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:57:20'!
FAILURE!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
FAILURE!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
FAILURE!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
FAILURE!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:57:21'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:57:47'!
FAILURE!
!ResidentialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:58:46' prior: 50621963 overrides: 50621948!
waterConsumption
	
	^(9 * wp)! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
FAILURE!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
FAILURE!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
FAILURE!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
FAILURE!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
FAILURE!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:58:48'!
PASSED!
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:59:05' prior: 50621953 overrides: 50621948!
waterConsumption
	
	^(2 * wp)! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
FAILURE!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
FAILURE!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
FAILURE!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
FAILURE!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
FAILURE!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 11:59:07'!
PASSED!
!CommertialZone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 11:59:45' prior: 50621972 overrides: 50621967!
totalWaterConsumption
	
	^self waterConsumption * self getNumberOfCells ! !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:00:21' prior: 50621136!
totalEnergyConsumption
	
	self energyConsumption * self getNumberOfCells ! !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:00:44' prior: 50621948!
waterConsumption
	
	self waterConsumption * self getNumberOfCells ! !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:00:55' prior: 50622328!
waterConsumption
	
	self subclassResponsibility ! !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:01:14' prior: 50621967!
totalWaterConsumption
	
	self waterConsumption * self getNumberOfCells ! !

!methodRemoval: CommertialZone #totalEnergyConsumption stamp: 'AS 4/27/2023 12:01:21'!
totalEnergyConsumption
	
	^(8 * ep) * self getNumberOfCells !

!methodRemoval: CommertialZone #totalWaterConsumption stamp: 'AS 4/27/2023 12:01:23'!
totalWaterConsumption
	
	^self waterConsumption * self getNumberOfCells !

!methodRemoval: IndustrialZone #totalEnergyConsumption stamp: 'AS 4/27/2023 12:01:27'!
totalEnergyConsumption
		
	^(10 * ep) * self getNumberOfCells !

!methodRemoval: IndustrialZone #totalWaterConsumption stamp: 'AS 4/27/2023 12:01:29'!
totalWaterConsumption
	
	^(10 * wp) * self getNumberOfCells !

!methodRemoval: ResidentialZone #totalEnergyConsumption stamp: 'AS 4/27/2023 12:01:32'!
totalEnergyConsumption
		
	^(5 * ep) * self getNumberOfCells !

!methodRemoval: ResidentialZone #totalWaterConsumption stamp: 'AS 4/27/2023 12:01:34'!
totalWaterConsumption
	
	^(10 * wp) * self getNumberOfCells !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:01:40'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:01:40'!
ERROR!

city := City new.!

city addService: SolarPlant new.!

city addService: WaterTower new.!

r := ResidentialZone new.!

city addZone: r.!

r totalWaterConsumption !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:03:43' prior: 50622322!
totalEnergyConsumption
	
	^self energyConsumption * self getNumberOfCells ! !
!Zone methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:03:49' prior: 50622338!
totalWaterConsumption
	
	^self waterConsumption * self getNumberOfCells ! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:03:57'!
PASSED!
!SolarPlant methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:05:31'!
waterProduced

	^(0 * wp)! !
!WaterTower methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:05:45'!
waterProduced

	^(200 * wp)! !
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:06:32' prior: 50619240!
waterProduced

	^services sum: [:service | service waterProduced] ifEmpty: [0 * wp].
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:06:34'!
PASSED!
!City methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:06:44' prior: 50619252!
zones

	^ zones.
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:06:46'!
PASSED!

!methodRemoval: City #setName: stamp: 'AS 4/27/2023 12:08:46'!
setName: aName

	name _ aName.!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:08:52'!
PASSED!

!methodRemoval: Service #type stamp: 'AS 4/27/2023 12:09:18'!
type
	
	self subclassResponsibility !

!methodRemoval: SolarPlant #type stamp: 'AS 4/27/2023 12:09:23'!
type
	
	^#SolarPlant!

!methodRemoval: WaterTower #type stamp: 'AS 4/27/2023 12:09:27'!
type
	
	^#WaterTower!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:09:30'!
PASSED!
!Service methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:09:56'!
waterProduced
	
	self subclassResponsibility ! !

!methodRemoval: Zone #type stamp: 'AS 4/27/2023 12:11:09'!
type
	
	self subclassResponsibility !

!methodRemoval: CommertialZone #type stamp: 'AS 4/27/2023 12:12:48'!
type
	
	^ #CommertialZone!

!methodRemoval: IndustrialZone #type stamp: 'AS 4/27/2023 12:13:19'!
type
	
	^ #IndustrialZone!

!methodRemoval: ResidentialZone #type stamp: 'AS 4/27/2023 12:13:38'!
type
	
	^ #ResidentialZone!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:14:20'!
PASSED!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 12:17:22'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city2'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:17:20' overrides: 16961394!
setUp
	
	city2 := City new.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:18:01' prior: 50618802!
test01CityWithoutPowerServicesHaveZeroEnergyProduced

	self assert: 0 * ep equals: city2 energyProduced.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:18:26' prior: 50618809!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	city2 addService: self solarPlant.
	
	self assert: 500 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:26:34' prior: 50618818!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	city2 addService: self solarPlant.
	city2 addService: self waterTower.

	city2 addZone: self residentialZone.
	
	self assert: 500 - 5 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:26:56' prior: 50618829!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	city2 addService: self solarPlant.
	city2 addService: self waterTower.
	
	city2 addZone: self residentialZone.
	city2 addZone: self commertialZone.
	
	self assert: 500 - 5 - 8 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:27:13' prior: 50618841!
test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable

	city2 addService: self solarPlant.
	city2 addService: self waterTower.

	city2 addZone: self industrialZone.
	
	self assert: 500 - 10 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:31:25'!
createCityWithServices: anArrayOfServices andZones: anArrayOfZones
	
	| city |
	
	city := City new.
	anArrayOfServices do: [:service | city addService: service].
	anArrayOfZones do: [:zone | city addZone: zone].
	
	^city! !
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:32:11' prior: 50623187!
createCityWithServices: anArrayOfServices andZones: anArrayOfZones
		
	city2 := City new.
	anArrayOfServices do: [:service | city2 addService: service].
	anArrayOfZones do: [:zone | city2 addZone: zone].	! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:33:16' prior: 50623147!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithServices: #(solarPlant) andZones: #().
	
	"city2 addService: self solarPlant."
	
	self assert: 500 * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:33:18'!
ERROR!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:34:06'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:34:11'!
ERROR!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:34:11'!
ERROR!

city2 zones!

city2 services!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:36:01' prior: 50623206!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithServices: [self solarPlant] andZones: [].
	
	"city2 addService: self solarPlant."
	
	self assert: 500 * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:36:03'!
ERROR!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:36:21' prior: 50623232!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithServices: {self solarPlant} andZones: {}.
	
	"city2 addService: self solarPlant."
	
	self assert: 500 * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:36:23'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:36:47' prior: 50623246!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithServices: {self solarPlant}
				 andZones: {}.
	
	self assert: 500 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:39:31'!
createCityWithSolarPlant: anArrayOfZones
		
	self createCityWithServices: { self solarPlant } andZones: anArrayOfZones.
! !
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:39:44'!
createCityWithWaterTower: anArrayOfZones
		
	self createCityWithServices: { self waterTower } andZones: anArrayOfZones.
! !
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:40:00'!
createCityWithAllServices: anArrayOfZones
		
	self createCityWithServices: { self solarPlant, self waterTower } andZones: anArrayOfZones.
! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:40:53' prior: 50623359!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithSolarPlant: {}.
	
	self assert: 500 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:41:27' prior: 50623155!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	self createCityWithAllServices: {self residentialZone }.
	self assert: 500 - 5 * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:41:28'!
ERROR!
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:45:34' prior: 50623382!
createCityWithAllServices: anArrayOfZones
		
	self createCityWithServices: { (self solarPlant). (self waterTower) } andZones: anArrayOfZones.
! !

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:45:36'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:45:37'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:46:22' prior: 50623165!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServices: { self residentialZone. self commertialZone. }.
	
	self assert: 500 - 5 - 8 * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:46:23'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:46:35' prior: 50623521!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServices: { self residentialZone. self commertialZone. }.

	self assert: 500 - 5 - 8 * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:46:37'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:47:13' prior: 50623177!
test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable

	self createCityWithAllServices: { self industrialZone }.
	
	self assert: 500 - 10 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:48:20' prior: 50618852!
test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable

	self createCityWithAllServices: { self residentialZone.
								self commertialZone.
								self industrialZone.	
								self industrialZone. }.
	
	self assert: 500 - 5 - 8 - (10 * 2) * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:48:21'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:48:22'!
PASSED!
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 12:49:05'!
createCityWithAllServicesAndZones: anArrayOfZones
		
	self createCityWithServices: { (self solarPlant). (self waterTower) } andZones: anArrayOfZones.
! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:49:05' prior: 50623756!
test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZone.
								self commertialZone.
								self industrialZone.	
								self industrialZone. }.
	
	self assert: 500 - 5 - 8 - (10 * 2) * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:49:05' prior: 50623634!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZone. self commertialZone. }.

	self assert: 500 - 5 - 8 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:49:05' prior: 50623397!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	self createCityWithAllServicesAndZones: {self residentialZone }.
	self assert: 500 - 5 * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 12:49:05' prior: 50623747!
test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable

	self createCityWithAllServicesAndZones: { self industrialZone }.
	
	self assert: 500 - 10 * ep equals: city2 energyAvailable.! !

!methodRemoval: CityTest #createCityWithAllServices: stamp: 'AS 4/27/2023 12:49:05'!
createCityWithAllServices: anArrayOfZones
		
	self createCityWithServices: { (self solarPlant). (self waterTower) } andZones: anArrayOfZones.
!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:49:15' prior: 50623879!
test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZone.
										self commertialZone.
										self industrialZone.	
										self industrialZone. }.
	
	self assert: 500 - 5 - 8 - (10 * 2) * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:49:17'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:49:31' prior: 50618867!
test07CityWithoutWaterServicesHaveZeroWaterProduced

	self assert: 0 * wp equals: city2 waterProduced.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:50:14' prior: 50618874!
test08CityWithWaterTowerWithoutZonesHave200WaterAvailable

	self createCityWithWaterTower: {}.
	self assert: 200 * wp equals: city2 waterAvailable.! !

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:50:15'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:50:51' prior: 50618883!
test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable

	self createCityWithAllServicesAndZones: {self residentialZone }.
	self assert: 200 - 9 * wp equals: city2 waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:51:41' prior: 50618894!
test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable

	self createCityWithAllServicesAndZones: { self residentialZone. self commertialZone. }.
	self assert: 200 - 9 - 2 * wp equals: city2 waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:52:37' prior: 50618906!
test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable

	self createCityWithAllServicesAndZones: { self industrialZone }.
	self assert: 200 - 10 * wp equals: city2 waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:53:54' prior: 50618917!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndZones: {
			self residentialZone.
			self commertialZone.
			self industrialZone.
			self industrialZone.
		}.
	
	self assert: 200 - 31 * wp equals: city2 waterAvailable.! !

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:53:55'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:53:56'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:54:41' prior: 50618931!
test13CityWith2SolarPlantsHaveTwiceEnergyAvailable

	self createCityWithServices: {self solarPlant. self solarPlant } andZones: {}.
	self assert: (500 * 2) * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:54:43'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:55:20' prior: 50618941!
test14CityWith2WaterTowerHaveTwiceWaterAvailable

	self createCityWithServices: { self waterTower. self waterTower } andZones: {}.
	self assert: (200 * 2) * wp equals: city2 waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:55:47' prior: 50618951!
test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable

	self 
		should: [ city2 addZone: self residentialZone. ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddZoneErrorDescription.
			self assert: 0 equals: city2 zones size]
		! !

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:55:50'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:56:02' prior: 50618964!
test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable

	self 
		should: [ city2 addZone: self commertialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddZoneErrorDescription.
			self assert: 0 equals: city2 zones size ]
		! !

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:56:03'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:56:15' prior: 50618977!
test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable

	self 
		should: [ city2 addZone: self industrialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddZoneErrorDescription.
			self assert: 0 equals: city2 zones size ]
		! !

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:56:16'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:56:26' prior: 50618990!
test18CityWithoutZonesHaveZeroEnergyConsumption

	self assert: 0 * ep equals: city2 energyConsumption.! !

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:56:27'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:57:10' prior: 50618997!
test19CityWithoutResidentialZonesCannotAddCommertialZone

	self createCityWithAllServicesAndZones: {}.
		
	self 
		should: [ city2 addZone: self commertialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddCommertialZoneErrorDescription.
			self assert: 0 equals: city2 zones size ]! !

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:57:11'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:58:09' prior: 50619012!
test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable

	| zone |

	zone := self residentialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { zone }.
	
	self assert: 500 - (5 * 2) * ep equals: city2 energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:59:18' prior: 50619025!
test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable

	| zone |

	zone := self commertialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { self residentialZone , zone }.
	
	self assert: 500 - 5 - (8 * 2) * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:59:20'!
ERROR!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 12:59:46' prior: 50625009!
test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable

	| zone |

	zone := self commertialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { (self residentialZone). zone }.
	
	self assert: 500 - 5 - (8 * 2) * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:59:48'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 12:59:48'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 12:59:48'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 12:59:49'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:00:31' prior: 50619040!
test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable

	| zone |
	
	zone := self industrialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { zone }.
	
	self assert: 500 - (10 * 2) * ep equals: city2 energyAvailable.! !

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:00:32'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:01:20' prior: 50619053!
test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable

	| zone |

	zone := self residentialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones:  { zone }.
	
	self assert: 200 - (9 * 2) * wp equals: city2 waterAvailable.! !

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:01:31'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:02:07' prior: 50619066!
test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable

	| zone |
	
	zone := self commertialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones:  { (self residentialZone). zone }.	
	
	self assert: 200 - 9 - (2 * 2) * wp equals: city2 waterAvailable.! !

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:02:09'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:02:44' prior: 50619081!
test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable

	| zone |

	zone := self industrialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { zone }.
	
	self assert: 200 - (10 * 2) * wp equals: city2 waterAvailable.! !

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:02:46'!
PASSED!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:02:52'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623137 overrides: 16961394!
setUp
	
	city := City new.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50625026!
test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable

	| zone |

	zone := self commertialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { (self residentialZone). zone }.
	
	self assert: 500 - 5 - (8 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624160!
test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable

	self createCityWithAllServicesAndZones: {self residentialZone }.
	self assert: 200 - 9 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50625142!
test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable

	| zone |
	
	zone := self industrialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { zone }.
	
	self assert: 500 - (10 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624188!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndZones: {
			self residentialZone.
			self commertialZone.
			self industrialZone.
			self industrialZone.
		}.
	
	self assert: 200 - 31 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50625257!
test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable

	| zone |

	zone := self residentialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones:  { zone }.
	
	self assert: 200 - (9 * 2) * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624169!
test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable

	self createCityWithAllServicesAndZones: { self residentialZone. self commertialZone. }.
	self assert: 200 - 9 - 2 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624049!
test08CityWithWaterTowerWithoutZonesHave200WaterAvailable

	self createCityWithWaterTower: {}.
	self assert: 200 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50625372!
test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable

	| zone |
	
	zone := self commertialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones:  { (self residentialZone). zone }.	
	
	self assert: 200 - 9 - (2 * 2) * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624424!
test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable

	self 
		should: [ city addZone: self residentialZone. ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddZoneErrorDescription.
			self assert: 0 equals: city zones size]
		! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624179!
test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable

	self createCityWithAllServicesAndZones: { self industrialZone }.
	self assert: 200 - 10 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623927!
test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZone.
										self commertialZone.
										self industrialZone.	
										self industrialZone. }.
	
	self assert: 500 - 5 - 8 - (10 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624998!
test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable

	| zone |

	zone := self residentialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { zone }.
	
	self assert: 500 - (5 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624303!
test13CityWith2SolarPlantsHaveTwiceEnergyAvailable

	self createCityWithServices: {self solarPlant. self solarPlant } andZones: {}.
	self assert: (500 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624540!
test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable

	self 
		should: [ city addZone: self commertialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddZoneErrorDescription.
			self assert: 0 equals: city zones size ]
		! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624415!
test14CityWith2WaterTowerHaveTwiceWaterAvailable

	self createCityWithServices: { self waterTower. self waterTower } andZones: {}.
	self assert: (200 * 2) * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623911!
test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable

	self createCityWithAllServicesAndZones: { self industrialZone }.
	
	self assert: 500 - 10 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624881!
test19CityWithoutResidentialZonesCannotAddCommertialZone

	self createCityWithAllServicesAndZones: {}.
		
	self 
		should: [ city addZone: self commertialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddCommertialZoneErrorDescription.
			self assert: 0 equals: city zones size ]! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624043!
test07CityWithoutWaterServicesHaveZeroWaterProduced

	self assert: 0 * wp equals: city waterProduced.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623141!
test01CityWithoutPowerServicesHaveZeroEnergyProduced

	self assert: 0 * ep equals: city energyProduced.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624772!
test18CityWithoutZonesHaveZeroEnergyConsumption

	self assert: 0 * ep equals: city energyConsumption.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50625488!
test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable

	| zone |

	zone := self industrialZone.
	zone setNumberOfCells: 2.
	
	self createCityWithAllServicesAndZones: { zone }.
	
	self assert: 200 - (10 * 2) * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623892!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZone. self commertialZone. }.

	self assert: 500 - 5 - 8 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623389!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithSolarPlant: {}.
	
	self assert: 500 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623902!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	self createCityWithAllServicesAndZones: {self residentialZone }.
	self assert: 500 - 5 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50624656!
test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable

	self 
		should: [ city addZone: self industrialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddZoneErrorDescription.
			self assert: 0 equals: city zones size ]
		! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:02:52' prior: 50623197!
createCityWithServices: anArrayOfServices andZones: anArrayOfZones
		
	city := City new.
	anArrayOfServices do: [:service | city addService: service].
	anArrayOfZones do: [:zone | city addZone: zone].	! !

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:02:56'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:05:10'!
createCityWithOneSolarPlant

	^ self createCityWithSolarPlant: {}! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:05:10' prior: 50625849!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithOneSolarPlant.
	
	self assert: 500 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:06:28'!
createCityWithAllServicesAndOneResidentialZone

	^ self createCityWithAllServicesAndZones: {self residentialZone }! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:06:28' prior: 50625629!
test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable

	self createCityWithAllServicesAndOneResidentialZone.
	self assert: 200 - 9 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:06:28' prior: 50625857!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	self createCityWithAllServicesAndOneResidentialZone.
	self assert: 500 - 5 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:07:10'!
createCityWithAllServicesAndResidentialAndCommertialZones

	^ self createCityWithAllServicesAndZones: { self residentialZone. self commertialZone. }! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:07:10' prior: 50625839!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServicesAndResidentialAndCommertialZones.

	self assert: 500 - 5 - 8 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:07:10' prior: 50625674!
test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable

	self createCityWithAllServicesAndResidentialAndCommertialZones.
	self assert: 200 - 9 - 2 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:07:31' prior: 50626036!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServicesAndResidentialAndCommertialZones.
	self assert: 500 - 5 - 8 * ep equals: city energyAvailable.! !

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:07:33'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:08:07'!
createCityWithAllServicesAndOneIndustrialZone

	^ self createCityWithAllServicesAndZones: { self industrialZone }! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:08:08' prior: 50625783!
test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable

	self createCityWithAllServicesAndOneIndustrialZone.
	
	self assert: 500 - 10 * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:08:08' prior: 50625718!
test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable

	self createCityWithAllServicesAndOneIndustrialZone.
	self assert: 200 - 10 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:09:00'!
createCityWithOneWaterTower

	^ self createCityWithWaterTower: {}! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:09:00' prior: 50625684!
test08CityWithWaterTowerWithoutZonesHave200WaterAvailable

	self createCityWithOneWaterTower.
	self assert: 200 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:09:51'!
createCityWithTwoSolarPlants

	^ self createCityWithServices: {self solarPlant. self solarPlant } andZones: {}! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:09:51' prior: 50625752!
test13CityWith2SolarPlantsHaveTwiceEnergyAvailable

	self createCityWithTwoSolarPlants.
	self assert: (500 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:10:11'!
createCityWithTwoWaterTowers

	^ self createCityWithServices: { self waterTower. self waterTower } andZones: {}! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:10:11' prior: 50625774!
test14CityWith2WaterTowerHaveTwiceWaterAvailable

	self createCityWithTwoWaterTowers.
	self assert: (200 * 2) * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:11:14'!
createCityWithAllServicesAndWithoutZones

	^ self createCityWithAllServicesAndZones: {}! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:11:14' prior: 50625792!
test19CityWithoutResidentialZonesCannotAddCommertialZone

	self createCityWithAllServicesAndWithoutZones.
		
	self 
		should: [ city addZone: self commertialZone ] 
		raise: Error
		withExceptionDo: [ :error | 
			self assert: error messageText equals: City cannotAddCommertialZoneErrorDescription.
			self assert: 0 equals: city zones size ]! !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:13:34'!
commertialZoneWithTwoCells

	| zone |
	
	zone := CommertialZone new.
	zone cellSize: 2.
	
	^zone! !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:14:08'!
industrialZoneWithTwoCells

	| zone |
	
	zone := IndustrialZone new.
	zone cellSize: 2.
	
	^zone.! !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:14:27'!
residentialZoneWithTwoCells

	| zone |
	
	zone := ResidentialZone new.
	zone cellSize: 2.
	
	^zone.	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:14:30'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:16:16'!
createCityWithAllServicesAndOneResientialOneCommertialAndTwoIndustrialZones

	^ self createCityWithAllServicesAndZones: {
			self residentialZone.
			self commertialZone.
			self industrialZone.
			self industrialZone.
		}! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:16:16' prior: 50625650!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndOneResientialOneCommertialAndTwoIndustrialZones.
	
	self assert: 200 - 31 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:16:38'!
createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones

	^ self createCityWithAllServicesAndZones: {
			self residentialZone.
			self commertialZone.
			self industrialZone.
			self industrialZone.
		}! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:16:38' prior: 50626375!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones.
	
	self assert: 200 - 31 * wp equals: city waterAvailable.! !

!methodRemoval: CityTest #createCityWithAllServicesAndOneResientialOneCommertialAndTwoIndustrialZones stamp: 'AS 4/27/2023 13:16:38'!
createCityWithAllServicesAndOneResientialOneCommertialAndTwoIndustrialZones

	^ self createCityWithAllServicesAndZones: {
			self residentialZone.
			self commertialZone.
			self industrialZone.
			self industrialZone.
		}!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:16:49' prior: 50626394!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones.	
	self assert: 200 - 31 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:17:24' prior: 50625740!
test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZoneWithTwoCells }.	
	self assert: 500 - (5 * 2) * ep equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:17:49' prior: 50625616!
test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable
	
	self createCityWithAllServicesAndZones: { self residentialZone. self commertialZoneWithTwoCells }.	
	self assert: 500 - 5 - (8 * 2) * ep equals: city energyAvailable.! !

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:17:52'!
ERROR!
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:18:20' prior: 50626248!
commertialZoneWithTwoCells

	| zone |
	
	zone := CommertialZone new.
	zone setNumberOfCells: 2.
	
	^zone! !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:18:25' prior: 50626254!
industrialZoneWithTwoCells

	| zone |
	
	zone := IndustrialZone new.
	zone setNumberOfCells: 2.
	
	^zone.! !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:18:30' prior: 50626260!
residentialZoneWithTwoCells

	| zone |
	
	zone := ResidentialZone new.
	zone setNumberOfCells: 2.
	
	^zone.	! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:18:32'!
PASSED!
!Zone class methodsFor: 'instance creation' stamp: 'AS 4/27/2023 13:20:10'!
withNumberOfCells: aNumberOfCells

	^ self new withNumberOfCells: aNumberOfCells! !
!Zone class methodsFor: 'instance creation' stamp: 'AS 4/27/2023 13:20:40' prior: 50626567!
withNumberOfCells: aNumberOfCells

	^ self new initializeWithNumberOfCells: aNumberOfCells! !

!methodRemoval: Zone class #withType: stamp: 'AS 4/27/2023 13:20:46'!
withType: aZoneType 

	^ self new initializeWithType: aZoneType. !
!Zone methodsFor: 'initialization' stamp: 'AS 4/27/2023 13:21:38'!
intializeWithANumberOfCells: aNumberOfCells
	
	numberOfCells := aNumberOfCells.! !

c := CommertialZone withNumberOfCells: 2!
!Zone methodsFor: 'initialization' stamp: 'AS 4/27/2023 13:23:54'!
initializeWithANumberOfCells: aNumberOfCells
	
	numberOfCells := aNumberOfCells.! !

!methodRemoval: Zone #intializeWithANumberOfCells: stamp: 'AS 4/27/2023 13:23:54'!
intializeWithANumberOfCells: aNumberOfCells
	
	numberOfCells := aNumberOfCells.!
!Zone class methodsFor: 'instance creation' stamp: 'AS 4/27/2023 13:24:21' prior: 50626573!
withNumberOfCells: aNumberOfCells

	^ (self new) initializeWithANumberOfCells: aNumberOfCells! !

c := CommertialZone withNumberOfCells: 2!

c getNumberOfCells !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:25:16' prior: 50626449!
commertialZoneWithTwoCells

	^ CommertialZone withNumberOfCells:  2.
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:25:18'!
PASSED!
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:25:36' prior: 50626455!
industrialZoneWithTwoCells
	
	^ IndustrialZone withNumberOfCells: 2! !
!CityTest methodsFor: 'zones' stamp: 'AS 4/27/2023 13:25:54' prior: 50626461!
residentialZoneWithTwoCells

	^ ResidentialZone withNumberOfCells: 2
! !

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:25:57'!
PASSED!
!CityTest methodsFor: 'services' stamp: 'AS 4/27/2023 13:26:54'!
solarPlantEnergyPoints
	
	^(500 * ep)! !
!CityTest methodsFor: 'services' stamp: 'AS 4/27/2023 13:27:12'!
waterTowerWaterPoints
	
	^(200 * wp)! !

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:28:40'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:28:41'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 13:28:38' prior: 50625612 overrides: 16961394!
setUp

	solarPlantEnergyPoints := 500.
	waterTowerWaterPoints := 200.
	
	city := City new.
	
! !
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 13:29:04' prior: 50626849 overrides: 16961394!
setUp

	solarPlantEnergyPoints := 500 * ep.
	waterTowerWaterPoints := 200 * wp.
	
	city := City new.
	
! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:29:23' prior: 50625997!
test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable

	self createCityWithOneSolarPlant.	
	self assert: solarPlantEnergyPoints equals: city energyAvailable.! !

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:29:26'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:29:47' prior: 50626020!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	self createCityWithAllServicesAndOneResidentialZone.
	self assert: solarPlantEnergyPoints - 5 * ep equals: city energyAvailable.! !

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:31:24'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:31:26'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWayerConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:31:27'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWayerConsumption commertialZoneEnergyConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:31:28'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWayerConsumption commertialZoneEnergyConsumption commertialZoneWayerConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:31:30'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWayerConsumption commertialZoneEnergyConsumption commertialZoneWayerConsumption industrialZoneEnergyConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:31:31'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWayerConsumption commertialZoneEnergyConsumption commertialZoneWayerConsumption industrialZoneEnergyConsumption industrialZoneWayerConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'setUp/tearDown' stamp: 'AS 4/27/2023 13:31:22' prior: 50626856 overrides: 16961394!
setUp

	solarPlantEnergyPoints := 500 * ep.
	waterTowerWaterPoints := 200 * wp.
	
	residentialZoneEnergyConsumption := 5 * ep.
	residentialZoneWayerConsumption := 9 * wp.
	
	commertialZoneEnergyConsumption := 8 * ep.
	commertialZoneWayerConsumption := 2 * wp.
	
	industrialZoneEnergyConsumption := 10 * ep.
	industrialZoneWayerConsumption := 10 * wp.
			
	city := City new.
	
! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:31:53' prior: 50626973!
test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable

	self createCityWithAllServicesAndOneResidentialZone.
	self assert: solarPlantEnergyPoints - residentialZoneEnergyConsumption equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:32:43' prior: 50626054!
test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable

	self createCityWithAllServicesAndResidentialAndCommertialZones.
	self assert: solarPlantEnergyPoints 
				- residentialZoneEnergyConsumption
				- commertialZoneEnergyConsumption
		equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:33:16' prior: 50626173!
test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable

	self createCityWithAllServicesAndOneIndustrialZone.	
	self assert: solarPlantEnergyPoints - industrialZoneEnergyConsumption equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:34:46' prior: 50625727!
test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable

	self createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones
	self assert: solarPlantEnergyPoints 
				- commertialZoneEnergyConsumption 
				- residentialZoneEnergyConsumption 
				- (industrialZoneEnergyConsumption * 2) 
		equals: city energyAvailable.! !

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:34:48'!
ERROR!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:34:59' prior: 50627105!
test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable

	self createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones.
	self assert: solarPlantEnergyPoints 
				- commertialZoneEnergyConsumption 
				- residentialZoneEnergyConsumption 
				- (industrialZoneEnergyConsumption * 2) 
		equals: city energyAvailable.! !

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:35:00'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:35:39' prior: 50626195!
test08CityWithWaterTowerWithoutZonesHave200WaterAvailable

	self createCityWithOneWaterTower.
	self assert: waterTowerWaterPoints equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:35:58' prior: 50626011!
test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable

	self createCityWithAllServicesAndOneResidentialZone.
	self assert: waterTowerWaterPoints - residentialZoneWayerConsumption equals: city waterAvailable.! !

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:36:05'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWaterConsumption commertialZoneEnergyConsumption commertialZoneWayerConsumption industrialZoneEnergyConsumption industrialZoneWayerConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:36:05' prior: 50627248!
test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable

	self createCityWithAllServicesAndOneResidentialZone.
	self assert: waterTowerWaterPoints - residentialZoneWaterConsumption equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:36:05' prior: 50627058 overrides: 16961394!
setUp

	solarPlantEnergyPoints := 500 * ep.
	waterTowerWaterPoints := 200 * wp.
	
	residentialZoneEnergyConsumption := 5 * ep.
	residentialZoneWaterConsumption := 9 * wp.
	
	commertialZoneEnergyConsumption := 8 * ep.
	commertialZoneWayerConsumption := 2 * wp.
	
	industrialZoneEnergyConsumption := 10 * ep.
	industrialZoneWayerConsumption := 10 * wp.
			
	city := City new.
	
! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:36:40' prior: 50626045!
test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable

	self createCityWithAllServicesAndResidentialAndCommertialZones.
	self assert: waterTowerWaterPoints 
				- residentialZoneWaterConsumption 
				- commertialZoneWayerConsumption
		equals: city waterAvailable.! !

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:36:47'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWaterConsumption commertialZoneEnergyConsumption commertialZoneWaterConsumption industrialZoneEnergyConsumption industrialZoneWayerConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:36:47' prior: 50627299!
test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable

	self createCityWithAllServicesAndResidentialAndCommertialZones.
	self assert: waterTowerWaterPoints 
				- residentialZoneWaterConsumption 
				- commertialZoneWaterConsumption
		equals: city waterAvailable.! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:36:47' prior: 50627284 overrides: 16961394!
setUp

	solarPlantEnergyPoints := 500 * ep.
	waterTowerWaterPoints := 200 * wp.
	
	residentialZoneEnergyConsumption := 5 * ep.
	residentialZoneWaterConsumption := 9 * wp.
	
	commertialZoneEnergyConsumption := 8 * ep.
	commertialZoneWaterConsumption := 2 * wp.
	
	industrialZoneEnergyConsumption := 10 * ep.
	industrialZoneWayerConsumption := 10 * wp.
			
	city := City new.
	
! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:37:09' prior: 50626182!
test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable

	self createCityWithAllServicesAndOneIndustrialZone.
	self assert: waterTowerWaterPoints - industrialZoneWayerConsumption equals: city waterAvailable.! !

!classDefinition: #CityTest category: 'ISW1-2021-2C-1erParcial' stamp: 'AS 4/27/2023 13:37:17'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWaterConsumption commertialZoneEnergyConsumption commertialZoneWaterConsumption industrialZoneEnergyConsumption industrialZoneWaterConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:37:17' prior: 50627339 overrides: 16961394!
setUp

	solarPlantEnergyPoints := 500 * ep.
	waterTowerWaterPoints := 200 * wp.
	
	residentialZoneEnergyConsumption := 5 * ep.
	residentialZoneWaterConsumption := 9 * wp.
	
	commertialZoneEnergyConsumption := 8 * ep.
	commertialZoneWaterConsumption := 2 * wp.
	
	industrialZoneEnergyConsumption := 10 * ep.
	industrialZoneWaterConsumption := 10 * wp.
			
	city := City new.
	
! !
!CityTest methodsFor: 'as yet unclassified' stamp: 'AS 4/27/2023 13:37:17' prior: 50627354!
test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable

	self createCityWithAllServicesAndOneIndustrialZone.
	self assert: waterTowerWaterPoints - industrialZoneWaterConsumption equals: city waterAvailable.! !

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:37:20'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:37:50' prior: 50626415!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones.	
	self assert: waterTowerWaterPoints - 31 * wp equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:38:33' prior: 50627508!
test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable

	self createCityWithAllServicesAndOneResidentialOneCommertialAndTwoIndustrialZones.	
	self assert: waterTowerWaterPoints 
				- residentialZoneWaterConsumption 
				- commertialZoneWaterConsumption 
				- (industrialZoneWaterConsumption * 2)
		equals: city waterAvailable.! !

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:38:35'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:38:51' prior: 50626208!
test13CityWith2SolarPlantsHaveTwiceEnergyAvailable

	self createCityWithTwoSolarPlants.
	self assert: (solarPlantEnergyPoints * 2) equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:39:06' prior: 50626222!
test14CityWith2WaterTowerHaveTwiceWaterAvailable

	self createCityWithTwoWaterTowers.
	self assert: (waterTowerWaterPoints * 2) equals: city waterAvailable.! !

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:39:08'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:39:43' prior: 50626424!
test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable

	self createCityWithAllServicesAndZones: { self residentialZoneWithTwoCells }.	
	self assert: solarPlantEnergyPoints - (residentialZoneEnergyConsumption * 2) equals: city energyAvailable.! !

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:39:44'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:40:50' prior: 50626434!
test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable
	
	self createCityWithAllServicesAndZones: { self residentialZone. self commertialZoneWithTwoCells }.	
	self assert: solarPlantEnergyPoints 
				- residentialZoneEnergyConsumption 
				 - (commertialZoneEnergyConsumption * 2) 
		equals: city energyAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:41:28' prior: 50625638!
test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable

	self createCityWithAllServicesAndZones: { self industrialZoneWithTwoCells }.	
	self assert: solarPlantEnergyPoints - (industrialZoneEnergyConsumption * 2) equals: city energyAvailable.! !

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:41:29'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:42:03' prior: 50625662!
test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable
	
	self createCityWithAllServicesAndZones:  { self residentialZoneWithTwoCells }.	
	self assert: waterTowerWaterPoints - (residentialZoneWaterConsumption * 2) equals: city waterAvailable.! !

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:42:05'!
PASSED!
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:42:53' prior: 50625692!
test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable

	self createCityWithAllServicesAndZones:  { self residentialZone. self commertialZoneWithTwoCells }.		
	self assert: waterTowerWaterPoints 
				- residentialZoneWaterConsumption
				- (commertialZoneWaterConsumption * 2) 
		equals: city waterAvailable.! !
!CityTest methodsFor: 'tests' stamp: 'AS 4/27/2023 13:43:21' prior: 50625827!
test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable

	self createCityWithAllServicesAndZones: { self industrialZoneWithTwoCells }.	
	self assert: waterTowerWaterPoints - (industrialZoneWaterConsumption * 2) equals: city waterAvailable.! !

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/27/2023 13:43:22'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/27/2023 13:43:23'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/27/2023 13:43:23'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/27/2023 13:43:23'!
PASSED!

----SNAPSHOT----(27 April 2023 13:43:31) CuisUniversity-5706.image priorSource: 9187851!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/28/2023 07:50:01'!
PASSED!

!testRun: #CityTest #test01CityWithoutPowerServicesHaveZeroEnergyProduced stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test02CityWithSolarPlantWithoutZonesHave500EnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test03CityWithSolarPlantWithResidentialZonesHave495EnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test04CityWithSolarPlantWithCommertialZonesHave492EnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test05CityWithSolarPlantWithIndustrialZonesHave490EnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test06CityWithSolarPlantWithServeralZonesImpactEnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test07CityWithoutWaterServicesHaveZeroWaterProduced stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test08CityWithWaterTowerWithoutZonesHave200WaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test09CityWithWaterTowerWithResidentialZonesHave191WaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test10CityWithWaterTowerWithCommertialZonesHave198WaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test11CityWithWaterTowerWithIndustrialZonesHave190WaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test12CityWithWaterTowerWithServeralZonesImpactWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test13CityWith2SolarPlantsHaveTwiceEnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test14CityWith2WaterTowerHaveTwiceWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test15AResidentialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test16ACommertialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test17AnIndustrialZoneCannotBeAddedWithoutEnergyAndWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test18CityWithoutZonesHaveZeroEnergyConsumption stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test19CityWithoutResidentialZonesCannotAddCommertialZone stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test20CityWithSolarPlantWithResidentialZoneWithManyCellsHave10LessEnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test21CityWithSolarPlantWithCommertialZoneWithManyCellsHave16LessEnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test22CityWithSolarPlantWithIndustrialZoneWithManyCellsHave20LessEnergyAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test23CityWithWaterTowerWithResidentialZoneWithManyCellsHave18LessWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test24CityWithWaterTowerWithCommertialZoneWithManyCellsHave4LessWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

!testRun: #CityTest #test25CityWithWaterTowerWithIndustrialZoneWithManyCellsHave20LessWaterAvailable stamp: 'AS 4/28/2023 07:50:02'!
PASSED!

----End fileIn of E:\ISW1\Parciales\2021\1C\ISW1-2021-1C-1erParcial-11Parcial.st----!

Weapon subclass: #Claw
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 14:13:20'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 14:13:41'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 14:14:00'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50628909!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50628909!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50628909!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 4/28/2023 14:14:08'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50628982 overrides: 50628995!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50628986 overrides: 50628995!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50628990 overrides: 50628995!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50628869!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50628869!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50628869!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 4/28/2023 14:15:51'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50629012 overrides: 50629174!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50629053 overrides: 50629174!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50629094 overrides: 50629174!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 14:17:16'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 14:17:16'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:17:16'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 14:17:16'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:17:16'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 14:17:16'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:17:16'!
ERROR!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:17:27'!
ERROR!
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50628643!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50628647!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50628651!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 4/28/2023 14:23:33'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 14:23:39'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 14:23:39'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:23:39'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 14:23:39'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:23:39'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 14:23:39'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:23:39'!
ERROR!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:23:42'!
ERROR!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 14:25:25'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 14:25:25'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:25:25'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 14:25:25'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:25:25'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 14:25:25'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:25:25'!
ERROR!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:25:33'!
ERROR!

!methodRemoval: Weapon #initialize stamp: 'AS 4/28/2023 14:25:56'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50629318 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50629324 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50629330 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:26:32'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 14:26:32'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 14:26:32'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:26:32'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:26:35'!
ERROR!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:27:13'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 14:27:13'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 14:27:13'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:27:13'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:27:23'!
ERROR!
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50628695!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50628714!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:29:41'!
ERROR!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50628732!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !

claw := Claw new.!

claw type!

blaster := HSBlaster new.!

blaster type!

cannon := TurboLaserCannon new.!

cannon type!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:32:58'!
PASSED!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 14:33:01'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 14:33:01'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 14:33:01'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 14:33:01'!
ERROR!

weapons at: 1!

weapons size!

weapons at: 1!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50628726!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50628745!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50628758!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50628770!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 4/28/2023 20:10:13'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:10:29'!
ERROR!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:10:29'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:10:29'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:10:29'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:10:29'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:10:34'!
ERROR!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50629194 overrides: 50629174!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50629865 overrides: 50629174!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:13:51'!
FAILURE!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:14:09'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:15:21'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:15:21'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:15:22'!
ERROR!
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50629212 overrides: 50629174!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:16:59'!
FAILURE!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:17:03'!
FAILURE!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:17:24'!
PASSED!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:17:29'!
PASSED!

----STARTUP---- (28 April 2023 20:19:34) as F:\CUIS University ISW1\CuisUniversity-5706.image!


!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:37'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:37'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10'!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48'!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38'!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23'!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58'!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57'!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51'!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11'!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31'!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17'!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02'!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15'!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40'!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05'!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04'!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09'!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35'!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16'!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15'!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25'!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36'!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46'!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52'!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:39'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:39'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:39'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:39'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19'!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30'!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38'!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43'!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48'!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54'!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03'!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34'!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10'!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19'!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01'!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49'!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10'!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14'!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:40'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:40'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34'!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48'!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46'!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:40'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:40'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38'!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53'!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24'!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12'!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:19:41'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50630589!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50630589!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50630589!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 4/28/2023 20:19:41'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50630663 overrides: 50630676!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50630667 overrides: 50630676!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50630671 overrides: 50630676!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50630549!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50630549!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50630549!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 4/28/2023 20:19:41'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50630693 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50630734 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50630775 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50630314!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50630318!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50630322!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 4/28/2023 20:19:42'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 4/28/2023 20:19:42'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50630929 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50630935 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50630941 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50630371!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50630390!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50630408!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50630402!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50630421!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50630434!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50630446!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 4/28/2023 20:19:42'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50630875 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50631047 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50630893 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:20:09'!
PASSED!

Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:35:46'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 4/28/2023 20:36:01'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'AS 4/28/2023 20:36:19' prior: 50630368!
type

	self subclassResponsibility 	! !
!Aluminum3000 methodsFor: 'nil' stamp: 'AS 4/28/2023 20:36:42' overrides: 50631186!
type
	
	^#Aluminum3000! !
!TankRover methodsFor: 'no messages' stamp: 'AS 4/28/2023 20:36:54' overrides: 50631186!
type
	
	^#TankRover! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:38:43' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:39:20' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !

!methodRemoval: Robot class #ofType: stamp: 'AS 4/28/2023 20:39:35'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'!
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:48' prior: 50630305!
createAluminum3000

	^ Aluminum3000 new! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:58' prior: 50630310!
createTankRover

	^ TankRover new! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:40:04'!
ERROR!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:40:04'!
ERROR!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:40:04'!
ERROR!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:40:05'!
ERROR!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:40:07'!
ERROR!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:02' prior: 50631198 overrides: 16920235!
initialize
	
	weapons := OrderedCollection new.

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:07' prior: 50631205 overrides: 16920235!
initialize

	weapons := OrderedCollection new.
	
	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:42:27'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:42:27'!
PASSED!
!Robot methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:42:47' prior: 50630380!
attack: aVictim with: aWeapon

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !

!methodRemoval: Robot #initializeType:life:speed:maxWeaponWeight: stamp: 'AS 4/28/2023 20:43:20'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:43:33' prior: 50630415!
removeWeapon: aWeapon 
	
	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:45:01' prior: 50631024!
totalWeaponWeight
	
	^weapons sum: [:weapon | weapon weight] ifEmpty: [0 * kilogram].
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:45:02'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:45:02'!
PASSED!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:47:43' prior: 50631012!
totalSpeedImpact

	^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:47:44'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:47:45'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:47:45'!
PASSED!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:49:44' prior: 50631484!
totalSpeedImpact

	"^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]"
	
	
	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:49:45'!
PASSED!

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:49:56'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:49:56'!
PASSED!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:50:12' prior: 50630960 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 0 * kilometer / hour. "5"
	usedTimes := 0
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:50:14'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:50:14'!
PASSED!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:50:41' prior: 50631558!
totalSpeedImpact

	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:53:44' prior: 50631701 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 20:53:47'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 20:53:47'!
PASSED!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:55:10' prior: 50630861 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:56:35'!
attackedWithClaw
	
	life := life - (25 * year).! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:57:02'!
attackedWithClaw

	life := life - (5 * year).
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:59:47'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw stamp: 'AS 4/28/2023 20:59:52'!
attackedWithClaw
	
	life := life - (25 * year).!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:00:39' prior: 50631853 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:09:00' prior: 50631887 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker WithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:09:20'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw: stamp: 'AS 4/28/2023 21:09:25'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:10:18' prior: 50631919!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	anAttacker attackAluminum3000: self withClaw: aClaw	! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:12:46' prior: 50631931!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw isUsedBy: anAttacker againstAluminum3000: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:13:40'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 21:13:42'!
ERROR!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 21:13:42'!
ERROR!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 21:13:42'!
ERROR!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 21:13:42'!
ERROR!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 21:13:42'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 21:13:54'!
ERROR!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:14:37' prior: 50631903 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:15:03'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (5 * year).
	
	aClaw isUsedBy: anAttacker againstTankRover: self
! !

!methodRemoval: TankRover #attackedWithClaw stamp: 'AS 4/28/2023 21:15:09'!
attackedWithClaw

	life := life - (5 * year).
!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:15:49'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:04' prior: 50632023 overrides: 50630855!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:21' prior: 50632056 overrides: 50630855!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.

! !

!testRun: #RobotWarsTest #test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test02ShouldNotAddWeaponIfSpeedBelowZero stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test03ShouldHaveZeroWeightWhenNoWeaponsAdded stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test04ShouldAddWeightWhenAddingWeapon stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test05ShouldHaveZeroSpeedWhenNoWeaponsAdded stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test06ShouldAddSpeedImpactWhenAddingWeapons stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test07ClawReducesLifeOfAluminum3000By25 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test08ClawReducesLifeOfTankRoverBy5 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test09HSBlasterReducesLifeOfAluminum3000By5 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test10HSBlasterReducesLifeOfTankRoverBy50 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test11TurboLaserCannonReducesLifeOfAluminum3000By100 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test12TurboLaserCannonReducesLifeOfTankRoverBy100 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test13CanUseClawOnlyTwiceWhenAttackingAluminum3000 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test14CanUseClawOnlyOnceWhenAttackingTankRover stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000 stamp: 'AS 4/28/2023 21:16:23'!
PASSED!

!testRun: #RobotWarsTest #test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover stamp: 'AS 4/28/2023 21:16:23'!
PASSED!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:08'!
clawIsUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !

!methodRemoval: Claw #isUsedBy:againstAluminum3000: stamp: 'AS 4/28/2023 21:17:08'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:20'!
clawIsUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !

!methodRemoval: Claw #isUsedBy:againstTankRover: stamp: 'AS 4/28/2023 21:17:20'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 22:19:13' prior: 50631064 overrides: 50630855!
attack: aVictim by: anAttacker 	

	aVictim attackedBy: anAttacker withHSBlaster: self.
	
	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:19:46'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (25 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:20:14' prior: 50632190!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:21:11'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstTankRover: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50632072 overrides: 50630855!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

----End fileIn of E:\ISW1\Parciales\2020\2C\Primer Parcial\ISW1-2020-2C-Parcial-Enunciado.st----!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:49:25'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:49:26'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:49:26'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:49:26'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:04' prior: 50632678!
totalPoints
		


	^(container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points].
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:05'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:05'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:54:05'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:54:05'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:54:05'!
ERROR!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:54:05'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:54:05'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:25' prior: 50633324!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]).
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:26'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:26'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:54:26'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:54:26'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:54:26'!
ERROR!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:54:26'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:54:26'!
ERROR!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:29'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:46' prior: 50633386!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]) ifEmpty: [0].
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:47'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:47'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:54:47'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:54:47'!
ERROR!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:54:47'!
ERROR!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:54:47'!
ERROR!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:54:47'!
ERROR!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:54:52'!
ERROR!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:55:13' prior: 50633452!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points] ifEmpty: [0]).
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:55:13'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:55:13'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:08'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:52' prior: 50633518!
totalPoints
		


	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:56:54'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:56:54'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:57:30' prior: 50633586!
totalPoints
		
	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:24'!
points
	
	self subclassResponsibility ! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:45' overrides: 50633653!
points
	
	^0! !

!methodRemoval: Backpack #portableObjectThatAddPoints stamp: 'AS 4/28/2023 22:58:59'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:59:25' prior: 50633647!
totalPoints
		
	^ container sum: [:portableObject | portableObject points] ifEmpty: [0].
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 22:59:27'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 22:59:27'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 23:00:16' prior: 50632690!
totalWeight
	
	^container sum: [:portableObject | portableObject weight] ifEmpty: [0]
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 23:00:17'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 23:00:17'!
PASSED!
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:01:33' prior: 50632716!
add: aPortableObject
	
	aPortableObject addTo: self.
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:03:06' overrides: 50633098!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack add: self.! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:04:30' prior: 50633803 overrides: 50633098!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addNoPointPortableObject: self.! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:05:17'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
! !
!PointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:06:51' overrides: 50633098!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPointsPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:07:42'!
addPortableObject: aPortableObject
	
	container add: aPortableObject.
! !

!methodRemoval: Backpack #addNoPointPortableObject: stamp: 'AS 4/28/2023 23:07:47'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
!
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:07:58' prior: 50633810 overrides: 50633098!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addPortableObject: self.! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:08:07' prior: 50633822 overrides: 50633098!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPortableObject: self.
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 23:08:10'!
ERROR!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 23:08:10'!
ERROR!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 23:08:10'!
FAILURE!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 23:08:10'!
FAILURE!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 23:08:10'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'AS 4/28/2023 23:08:10'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 23:08:19'!
ERROR!
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:08:31' prior: 50633787!
add: aPortableObject
	
	aPortableObject addTo: self.
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 23:08:33'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 23:08:33'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 23:08:34'!
PASSED!

DoorState subclass: #DoorOpen
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 4/28/2023 23:10:54'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRenamed: #DoorOpen as: #DoorOpened stamp: 'AS 4/28/2023 23:11:11'!
Smalltalk renameClassNamed: #DoorOpen as: #DoorOpened!

DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 4/28/2023 23:11:17'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 4/28/2023 23:11:24'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:03' overrides: 50632845!
isOpen
	
	^false! !
!DoorKeyClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:13' overrides: 50632845!
isOpen
	
	^false! !
!DoorOpened methodsFor: 'no messages' stamp: 'AS 4/28/2023 23:12:20' overrides: 50632845!
isOpen
	
	^true! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:14:18' prior: 50632569!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:28' prior: 50632476!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:38' prior: 50632488!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:14:46' prior: 50632600!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !

!methodRemoval: Door class #closed stamp: 'AS 4/28/2023 23:14:52'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.!
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:15:26' prior: 50632462!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:15:35' prior: 50632557!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:15:43' prior: 50632612!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !

!methodRemoval: Door class #opened stamp: 'AS 4/28/2023 23:15:48'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.!
!DoorKeyClosed class methodsFor: 'no messages' stamp: 'AS 4/28/2023 23:17:32'!
with: aKey

	self initializeWith: aKey.
! !

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 4/28/2023 23:18:00'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:17:58'!
initializeWith: aKey
	
	key := aKey! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:18:52' prior: 50632583!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:11' prior: 50632505!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:21' prior: 50632522!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:29' prior: 50632541!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:19:36' prior: 50632624!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!methodRemoval: Door class #closedWith: stamp: 'AS 4/28/2023 23:19:43'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.!

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/28/2023 23:19:47'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/28/2023 23:19:47'!
PASSED!
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:17' prior: 50632962!
isOpen

	^ state isOpen
! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'AS 4/28/2023 23:20:19'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'AS 4/28/2023 23:20:19'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'AS 4/28/2023 23:20:19'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'AS 4/28/2023 23:20:19'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'AS 4/28/2023 23:20:19'!
ERROR!
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:29' prior: 50634341!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:10:50' prior: 50632976 overrides: 50632929!
toBeClosedBy: aPlayableCharacter

	state close
! !
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/29/2023 15:11:28' overrides: 50632833!
close

	self error: Door alreadyClosedErrorDescription
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:11:43' overrides: 50632833!
close
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:12:29' prior: 50634398 overrides: 50632833!
close

	self error: Door alreadyClosedErrorDescription
! !
!DoorOpened methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:22'!
close: aDoor

	aDoor close	
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:31'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
! !

!methodRemoval: DoorKeyClosed #close stamp: 'AS 4/29/2023 15:13:37'!
close

	self error: Door alreadyClosedErrorDescription
!
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:46'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
	! !

!methodRemoval: DoorClosed #close stamp: 'AS 4/29/2023 15:13:51'!
close

	self error: Door alreadyClosedErrorDescription
	!
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:14:33'!
close

	state = DoorClosed new
! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'AS 4/29/2023 15:14:35'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'AS 4/29/2023 15:14:35'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'AS 4/29/2023 15:14:35'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'AS 4/29/2023 15:14:35'!
ERROR!

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'AS 4/29/2023 15:14:42'!
FAILURE!
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:15:42'!
toBeOpenedBy: aPlayableCharacter

	open: aDoor
! !
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:17'!
open: aDoor

	aDoor open
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:44'!
open: aDoor

	self error: Door closedWithKeyErrorDescription

! !
!DoorOpened methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:17:03'!
open: aDoor

	self error: Door alreadyOpenedErrorDescription
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:17:22'!
open

	state = DoorOpened new
! !

!testRun: #DoorTest #test01ADoorOpenedCanNotBeOpenedAgain stamp: 'AS 4/29/2023 15:17:24'!
FAILURE!

!testRun: #DoorTest #test02ADoorOpenedCanBeClosed stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test03ADoorClosedCanNotBeClosedAgain stamp: 'AS 4/29/2023 15:17:24'!
FAILURE!

!testRun: #DoorTest #test04ADoorClosedCanBeOpened stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test05ADoorClosedCanNotBeOpenedWithAKey stamp: 'AS 4/29/2023 15:17:24'!
FAILURE!

!testRun: #DoorTest #test06ADoorKeyClosedCanNotBeClosedAgain stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test07ADoorKeyClosedCanNotBeOpenedWithoutAKey stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test08ADoorKeyClosedCanNotBeOpenWithAnyKey stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test09ADoorKeyClosedCanBeOpenWithTheCorrectKey stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test10WhenUsingADoorClosedGetsOpened stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test11WhenUsingADoorOpenedGetsClosed stamp: 'AS 4/29/2023 15:17:24'!
ERROR!

!testRun: #DoorTest #test12WhenUsingADoorKeyClosedCanNotBeOpened stamp: 'AS 4/29/2023 15:17:24'!
ERROR!
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:20:13' prior: 50633014 overrides: 50632945!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:20:41'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorOpened methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50634541!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50634541!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50634541!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!methodRemoval: DoorState #toBeUsedBy: stamp: 'AS 4/29/2023 15:21:01'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:00'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:44'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorOpened methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:29'!
use: aDoor by: aPlayableCharacter

	^door toBeClosedBy: aPlayableCharacter! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:38' prior: 50634604!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:44' prior: 50634599!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !

!methodRemoval: DoorClosed #toBeUsedBy: stamp: 'AS 4/29/2023 15:23:52'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!

!methodRemoval: DoorKeyClosed #toBeUsedBy: stamp: 'AS 4/29/2023 15:23:56'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!

!methodRemoval: DoorOpened #toBeUsedBy: stamp: 'AS 4/29/2023 15:24:00'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:24:26'!
use: aDoor by: aPlayableCharacter

	self subclassResponsibility! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:24:53' prior: 50634536 overrides: 50632945!
toBeUsedBy: aPlayableCharacter

	state use: self by: aPlayableCharacter
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:27:15' prior: 50633000 overrides: 50632939!
toBeOpenedBy: aPlayableCharacter using: aKey

	state open: self by: aPlayableCharacter using: aKey
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:27:42'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key | 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:31' prior: 50634677!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorOpened methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50634692!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50634692!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50634692!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !

!methodRemoval: DoorState #open:by:using: stamp: 'AS 4/29/2023 15:28:43'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:01' prior: 50634722!
open: aDoor by: aPlayableCharacter using: aKey

	self error: Door noNeedForAKeyErrorDescription! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:43' prior: 50634737!
open: aDoor by: aPlayableCharacter using: aKey

	(key == aKey) ifTrue: [ ^ aDoor open ].
	self error: Door notCorrectKeyErrorDescription. 
! !
!DoorOpened methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:30:00' prior: 50634707!
open: aDoor by: aPlayableCharacter using: aKey

	self error: Door alreadyOpenedErrorDescription! !
!Door methodsFor: 'testing' stamp: 'AS 4/29/2023 15:30:39' prior: 50634382!
isOpen

	^ state class == DoorOpened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 16:03:09' prior: 50632988 overrides: 50632934!
toBeOpenedBy: aPlayableCharacter

	state openby: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:37'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorOpened methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50634795!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50634795!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50634795!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !

!methodRemoval: DoorState #openby: stamp: 'AS 4/29/2023 16:03:49'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:10:57'!
open: aDoor by: aPlayableCharacter

	door open.! !

!methodRemoval: DoorClosed #openby: stamp: 'AS 4/29/2023 16:11:03'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:11:26'!
open: aDoor by: aPlayableCharacter

	self error: Door closedWithKeyErrorDescription.
! !

!classRemoval: #PointsPortableObject stamp: 'AS 4/29/2023 16:11:32'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 4/29/2023 16:11:32'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 4/29/2023 16:11:33'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 4/29/2023 16:11:33'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 4/29/2023 16:11:33'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 4/29/2023 16:11:33'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorOpened stamp: 'AS 4/29/2023 16:11:33'!
DoorState subclass: #DoorOpened
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorKeyClosed stamp: 'AS 4/29/2023 16:11:33'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorClosed stamp: 'AS 4/29/2023 16:11:34'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 4/29/2023 16:11:34'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 4/29/2023 16:11:34'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 4/29/2023 16:11:34'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 4/29/2023 16:11:34'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

----End fileIn of E:\ISW1\Parciales\2020\2C\Primer Parcial\ISW1-2020-2C-Parcial-Enunciado.st----!
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:12'!
points

	self subclassResponsibility
! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:39' overrides: 50635976!
points
	
	^0! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:19:40' prior: 50635396!
totalWeight
	
	^container sum: [:portableObject | portableObject weight ] ifEmpty: [0]
! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/29/2023 16:19:42'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/29/2023 16:19:42'!
PASSED!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:20:07' prior: 50635384!
totalPoints
		
	^container sum: [:portableObject | portableObject points ] ifEmpty: [0]! !

!testRun: #BackpackTest #test01CanNotCreateBackpackWithZeroMaxWeight stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test02CanNotCreateBackpackWithNegativeMaxWeight stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test03CanNotCreateBackpackWithZeroMaxPoints stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test04CanNotCreateBackpackWithNegativeMaxPoints stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test05CanNotCreateBackpackWithNoIntegerMaxWeight stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test06CanNotCreateBackpackWithNoIntegerMaxPoints stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test08ShouldNotAddPointsPortableObjectIfWeightExceeded stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test11ShouldAddZeroWeightWhenEmpty stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test12ShouldAddWeightWhenAddingPortableObjects stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test13ShouldAddZeroPointsWhenEmpty stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test14ShouldAddPointsWhenAddingPointsPortableObjects stamp: 'AS 4/29/2023 16:20:09'!
PASSED!

!testRun: #BackpackTest #test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects stamp: 'AS 4/29/2023 16:20:09'!
PASSED!
!Backpack methodsFor: 'adding' stamp: 'AS 4/29/2023 16:23:40' prior: 50635422!
add: aPortableObject
	
	"aPortableObject addTo: self."
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !

----End fileIn of E:\ISW1\Parciales\2020\2C\Primer Parcial\ISW1-2020-2C-Parcial-Solucion.st----!

!classRemoval: #PointsPortableObject stamp: 'AS 4/29/2023 16:24:56'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 4/29/2023 16:24:56'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 4/29/2023 16:24:56'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 4/29/2023 16:24:56'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 4/29/2023 16:24:57'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 4/29/2023 16:24:57'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #OpenedDoorState stamp: 'AS 4/29/2023 16:24:57'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #KeyClosedDoorState stamp: 'AS 4/29/2023 16:24:57'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #ClosedDoorState stamp: 'AS 4/29/2023 16:24:57'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 4/29/2023 16:24:57'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 4/29/2023 16:24:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 4/29/2023 16:24:58'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 4/29/2023 16:24:58'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

----End fileIn of E:\ISW1\Parciales\2020\2C\Primer Parcial\ISW1-2020-2C-Parcial-Enunciado.st----!

----End fileIn of E:\ISW1\Parciales\2019\2C\Primer Parcial\IngSof1-2019-2C-1Parcial.st----!

!testRun: #CoffeeShopTest #test01ThereAreNoSalesWhenSalesSystemIsCreated stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test02CanQuerySalesByCustomer stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test03SalesAreDistinguishedByCustomer stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test08NoRewardExpectedWhenCustomerHasNotBuyAnything stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!testRun: #CoffeeShopTest #test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds stamp: 'AS 4/29/2023 16:33:38'!
PASSED!

!classRemoval: #Combo2RewardRule stamp: 'AS 4/29/2023 18:33:03'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 4/29/2023 18:33:03'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 4/29/2023 18:33:03'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 4/29/2023 18:33:04'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 4/29/2023 18:33:04'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 4/29/2023 18:33:04'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 4/29/2023 18:33:04'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

----End fileIn of D:\Google Drive Personal\Ciencias Computacion\2023 1C - Ingenieria Software 1\Parciales viejos\Parciales-master\Parciales-master\2019-2c\1erParcial\IngSof1-2019-2C-1Parcial-SolucionMinima.st----!

!classRemoval: #Combo2RewardRule stamp: 'AS 4/29/2023 18:36:19'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 4/29/2023 18:36:20'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 4/29/2023 18:36:20'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 4/29/2023 18:36:20'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 4/29/2023 18:36:20'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo2 stamp: 'AS 4/29/2023 18:36:20'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo1 stamp: 'AS 4/29/2023 18:36:20'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 4/29/2023 18:36:21'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 4/29/2023 18:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 4/29/2023 18:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 4/29/2023 18:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 4/29/2023 18:36:21'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 4/29/2023 18:36:21'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

----End fileIn of D:\Google Drive Personal\Ciencias Computacion\2023 1C - Ingenieria Software 1\Parciales viejos\Parciales-master\Parciales-master\2019-2c\1erParcial\IngSof1-2019-2C-1Parcial-SolucionMaxima.st----!

!classRemoval: #Combo2RewardRule stamp: 'AS 4/29/2023 18:38:59'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 4/29/2023 18:38:59'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 4/29/2023 18:39:00'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 4/29/2023 18:39:00'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 4/29/2023 18:39:00'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 4/29/2023 18:39:00'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 4/29/2023 18:39:00'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 4/29/2023 18:39:00'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 4/29/2023 18:39:00'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'AS 4/29/2023 18:39:01'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 4/29/2023 18:39:01'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 4/29/2023 18:39:01'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

----End fileIn of E:\ISW1\Parciales\2020\1C\Primer Parcial\ISW1-2020-1C-Parcial-Enunciado.st----!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 4/30/2023 13:51:55'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 4/30/2023 13:51:55'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 4/30/2023 13:51:55'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 13:51:55'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'AS 4/30/2023 13:51:59'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'AS 4/30/2023 13:51:59'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'AS 4/30/2023 13:51:59'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'AS 4/30/2023 13:51:59'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 4/30/2023 13:52:02'!
PASSED!

!classRemoval: #TankRover stamp: 'AS 4/30/2023 13:53:30'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Aluminum3000 stamp: 'AS 4/30/2023 13:53:31'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #TurboLaserCannon stamp: 'AS 4/30/2023 13:53:31'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #HSBlaster stamp: 'AS 4/30/2023 13:53:31'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Claw stamp: 'AS 4/30/2023 13:53:31'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Weapon stamp: 'AS 4/30/2023 13:53:31'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #RobotWarsTest stamp: 'AS 4/30/2023 13:53:31'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Trailer stamp: 'AS 4/30/2023 13:53:43'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 4/30/2023 13:53:43'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 4/30/2023 13:53:44'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 4/30/2023 13:53:44'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 4/30/2023 13:53:44'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 4/30/2023 13:53:44'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 4/30/2023 13:53:44'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 4/30/2023 13:53:44'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 4/30/2023 13:53:45'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 4/30/2023 13:53:45'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

----End fileIn of E:\ISW1\Parciales\2020\1C\Primer Parcial\ISW1-2020-1C-Parcial-Enunciado.st----!
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:19:45' prior: 50642551!
totalProductsHeight

	^(container select: [ :product | product isStackable])
		sum: [ :product | product height ]
		ifEmpty: [0]

! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:19:47'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:19:47'!
PASSED!
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:41' prior: 50642563!
totalProductsWeight
	
	^container sum: [ :product | product weight ]
! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'AS 4/30/2023 14:20:43'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'AS 4/30/2023 14:20:43'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'AS 4/30/2023 14:20:43'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'AS 4/30/2023 14:20:43'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'AS 4/30/2023 14:20:43'!
FAILURE!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'AS 4/30/2023 14:20:43'!
FAILURE!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/30/2023 14:20:43'!
ERROR!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/30/2023 14:20:43'!
ERROR!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:20:43'!
ERROR!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:20:43'!
ERROR!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:20:43'!
ERROR!
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:56' prior: 50642750!
totalProductsWeight
	
	^container sum: [ :product | product weight ] ifEmpty: [0]
! !

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:20:57'!
PASSED!

Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 14:21:41'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 14:22:20'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 14:22:36'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 14:22:58'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 14:23:17'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotStatusMechanicalFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:25:40'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:27:46' prior: 50642441!
closeOrderUsing: aCashier
	
	"status from: self closeOrderTo: aCashier"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:32:10'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:33:45'!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	| aTrailer |
	
	aRobot outOfOrder.
		
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	^ true
! !
!RobotStatusOutOfOrder methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:35:08'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusOutOfOrderFrom: aRobot
	! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:36:44' prior: 50642963!
from: aRobot closeOrderTo: aCashier
	
	aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:37:14'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:37:42'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusWorkingNormal methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:38:11'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:38:45'!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	| aTrailer | 
	
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
	^ true
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:23' prior: 50642464!
outOfOrder

	status := RobotStatusOutOfOrder new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:37' prior: 50642468!
withMechanicalFailure

	status := RobotStatusMechanicalFailure new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:48' prior: 50642472!
withSensorsFailure

	status := RobotStatusSensorsFailure
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:40:10' prior: 50642925!
closeOrderUsing: aCashier
	
	status from: self closeOrderTo: aCashier.
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:41:38' prior: 50642453!
take: aProduct

	status take: aProduct into: trailer
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:43:37' prior: 50643023!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:46:01'!
take: aProduct into: trailer of: aRobot
	
	^trailer withMechanicalFailure carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:44'!
take: aProduct into: trailer of: aRobot
	
	^aRobot class signalOutOfOrder.! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:57' prior: 50643034!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:13'!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:20'!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/30/2023 14:48:46' prior: 50642482!
initializeWith: aTrailer

	trailer := aTrailer.
	status := RobotStatusWorkingNormal new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:49:01' prior: 50643013!
withSensorsFailure

	status := RobotStatusSensorsFailure new
! !

!methodRemoval: RobotStatusMechanicalFailure #closeOrderUsing: stamp: 'AS 4/30/2023 14:49:46'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"!
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:07' prior: 50642939!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:19' prior: 50642975!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:34' prior: 50642987!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:15' prior: 50643106!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:32' prior: 50643112!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:51:51'!
receiveOrderWithStatusSensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:51' prior: 50643131!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !

!methodRemoval: Cashier #receiveOrderWithStatusSeensorsFailureFrom: stamp: 'AS 4/30/2023 14:51:51'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
!
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:52:04' prior: 50643118!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 4/30/2023 14:52:13'!
FAILURE!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 4/30/2023 14:52:13'!
FAILURE!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 4/30/2023 14:52:13'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 14:52:13'!
FAILURE!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 4/30/2023 14:54:20'!
FAILURE!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:57:14' prior: 50642235!
receiveOrder: aRobot
	
	aRobot closeOrderUsing: self
! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 4/30/2023 14:57:25'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 4/30/2023 14:57:25'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 4/30/2023 14:57:25'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 14:57:25'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'AS 4/30/2023 14:57:28'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'AS 4/30/2023 14:57:28'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'AS 4/30/2023 14:57:28'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'AS 4/30/2023 14:57:28'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 14:57:34'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 14:57:34'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 4/30/2023 14:57:34'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 14:57:36'!
ERROR!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'AS 4/30/2023 14:58:58'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 14:59:01'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 14:59:01'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 4/30/2023 14:59:01'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 14:59:06'!
ERROR!
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:59:54' prior: 50643124!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:12' prior: 50642970!
from: aRobot closeOrderTo: aCashier
	
	^aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:17' prior: 50643144!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:24' prior: 50643157!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 15:00:29'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 15:00:29'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 4/30/2023 15:00:29'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 15:00:33'!
ERROR!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 15:00:48'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 15:01:04'!
ERROR!
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 15:01:59' prior: 50643018!
closeOrderUsing: aCashier
	
	^status from: self closeOrderTo: aCashier.
! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 4/30/2023 15:02:02'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 4/30/2023 15:02:04'!
PASSED!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:07:39' prior: 50642954!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:08:02' prior: 50642993!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	self assertTrailerNotEmpty: aRobot trailer.	
	"Comentario: en este punto el cashier realizaría el checkout de los productos."		
	^ true
! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:12'!
from: aRobot closeOrderTo: aCashier
	
	self subclassResponsibility ! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:38'!
take: aProduct into: trailer of: aRobot

	self subclassResponsibility ! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:01:25'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:17' prior: 50642591!
assertHeightAdding: aProduct
	
	self execute: [ self signalMaxHeightCapacityExceeded ]
		If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:32'!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !

!methodRemoval: Trailer #execute:If:exceed: stamp: 'AS 4/30/2023 16:02:37'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
!
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:14' prior: 50643435!
assertHeightAdding: aProduct
	
	self If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	
		execute: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:55' prior: 50643454!
assertHeightAdding: aProduct
	
	self if: (self totalProductsHeight + aProduct height)
		 exceed: heightCapacity	
		 execute: [ self signalMaxHeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:04:22' prior: 50642598!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 16:06:08'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 16:06:10'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 4/30/2023 16:06:12'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:06' overrides: 16961394!
setUp

	trailer := Trailer with: 20 and: 100.
	robot := Robot with: trailer.	
	cashier := Cashier new.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:55' prior: 50641826!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	self
		should: [ 
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:07:11' prior: 50641839!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	self
		should: [ 
			robot withMechanicalFailure.
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'AS 4/30/2023 16:07:28' prior: 50641854!
test03ShouldNotAcceptSensorsFailureRobot

	self
		should: [ 
			robot withSensorsFailure.
			cashier receiveOrder: robot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'AS 4/30/2023 16:07:55' prior: 50641868!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	self
		should: [ 
			robot take: (ProductA with: 1  and: 1).
			robot withMechanicalFailure.
			
			cashier receiveOrder: robot.
			
			robot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 4/30/2023 16:07:59'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 4/30/2023 16:07:59'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 4/30/2023 16:07:59'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:07:59'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:07:59'!
FAILURE!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 4/30/2023 16:08:29'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 4/30/2023 16:08:32'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 4/30/2023 16:08:34'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:08:37'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:08:37'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:09:17'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:09:48'!
PASSED!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:11:47' prior: 50643403!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self halt.
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:11:55'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:11:55'!
FAILURE!
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:13:52' prior: 50643028!
take: aProduct

	self halt.
	status take: aProduct into: trailer of: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:14:13' prior: 50643620!
take: aProduct

	status take: aProduct into: trailer of: self
! !

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:14:35'!
FAILURE!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:15:00' prior: 50643604!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:16:09' prior: 50643470!
assertWeightAdding: aProduct
	
	self halt.
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !

self totalProductsWeight !

aProduct weight!
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:17:09' prior: 50643642!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:18:21' prior: 50643443!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: [aBlock value].
! !

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:18:23'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 4/30/2023 16:18:28'!
PASSED!

----STARTUP---- (3 May 2023 14:35:29) as F:\CUIS University ISW1\CuisUniversity-5706.image!


!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:38'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:38'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10'!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48'!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38'!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23'!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58'!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57'!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51'!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11'!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31'!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17'!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02'!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15'!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40'!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05'!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04'!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09'!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35'!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16'!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15'!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25'!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36'!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46'!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52'!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:40'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:40'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:40'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:40'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19'!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30'!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38'!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43'!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48'!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54'!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03'!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34'!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10'!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19'!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01'!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49'!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10'!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14'!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:41'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:41'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34'!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48'!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46'!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:41'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:41'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38'!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53'!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24'!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12'!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:42'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50644251!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50644251!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50644251!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 5/3/2023 14:35:42'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50644325 overrides: 50644338!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50644329 overrides: 50644338!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50644333 overrides: 50644338!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50644211!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50644211!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50644211!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 5/3/2023 14:35:42'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50644355 overrides: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50644396 overrides: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50644437 overrides: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50643976!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50643980!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50643984!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 5/3/2023 14:35:43'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 5/3/2023 14:35:43'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50644591 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50644597 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50644603 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50644033!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50644052!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50644070!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50644064!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50644083!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50644096!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50644108!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 5/3/2023 14:35:43'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50644537 overrides: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50644709 overrides: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50644555 overrides: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10' prior: 50643693!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48' prior: 50643710!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38' prior: 50643732!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23' prior: 50643740!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58' prior: 50643750!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57' prior: 50643758!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51' prior: 50643772!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11' prior: 50643786!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31' prior: 50643800!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17' prior: 50643815!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02' prior: 50643830!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15' prior: 50643845!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40' prior: 50643860!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05' prior: 50643879!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04' prior: 50643897!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09' prior: 50643915!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35' prior: 50643934!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16' prior: 50643950!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15' prior: 50643967!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25' prior: 50643972!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36' prior: 50644571!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46' prior: 50644575!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52' prior: 50644580!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' prior: 50644000 overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19' prior: 50644030!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58' prior: 50644642!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30' prior: 50644042!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38' prior: 50644652!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43' prior: 50644669!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48' prior: 50644663!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54' prior: 50644077!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03' prior: 50644674!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34' prior: 50644686!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10' prior: 50644696!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19' prior: 50644113!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01' prior: 50644116!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49' prior: 50644120!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10' prior: 50644127!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14' prior: 50644133!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34' prior: 50644147!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48' prior: 50644154!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46' prior: 50644160!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10' prior: 50644166!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38' prior: 50644197!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53' prior: 50644200!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43' prior: 50644517!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24' prior: 50644338!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12' prior: 50644263!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50644343 overrides: 50645356!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50644347 overrides: 50645356!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50644351 overrides: 50645356!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 5/3/2023 14:35:43'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50645432 overrides: 50645445!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50645436 overrides: 50645445!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50645440 overrides: 50645445!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50644523 overrides: 50645316!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50644726 overrides: 50645316!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50644743 overrides: 50645316!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 5/3/2023 14:35:43'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50645462 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50645503 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50645545 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50645069!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50645074!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50645079!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' prior: 50644622 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' prior: 50644629 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' prior: 50644636 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 5/3/2023 14:35:43'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 5/3/2023 14:35:43'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50645699 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50645705 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50645711 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50645129!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50645148!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50645168!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50645161!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50645183!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50645197!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50645209!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 5/3/2023 14:35:43'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50645645 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50645817 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50645663 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/3/2023 14:35:43'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'AS 4/28/2023 20:36:19' prior: 50645125!
type

	self subclassResponsibility 	! !
!Aluminum3000 methodsFor: 'nil' stamp: 'AS 4/28/2023 20:36:42' overrides: 50645896!
type
	
	^#Aluminum3000! !
!TankRover methodsFor: 'no messages' stamp: 'AS 4/28/2023 20:36:54' overrides: 50645896!
type
	
	^#TankRover! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:38:43' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:39:20' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !

!methodRemoval: Robot class #ofType: stamp: 'AS 5/3/2023 14:35:44'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'!
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:48' prior: 50645059!
createAluminum3000

	^ Aluminum3000 new! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:58' prior: 50645064!
createTankRover

	^ TankRover new! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:02' prior: 50645908 overrides: 16920235!
initialize
	
	weapons := OrderedCollection new.

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:07' prior: 50645915 overrides: 16920235!
initialize

	weapons := OrderedCollection new.
	
	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !
!Robot methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:42:47' prior: 50645138!
attack: aVictim with: aWeapon

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !

!methodRemoval: Robot #initializeType:life:speed:maxWeaponWeight: stamp: 'AS 5/3/2023 14:35:44'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:43:33' prior: 50645176!
removeWeapon: aWeapon 
	
	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:45:01' prior: 50645794!
totalWeaponWeight
	
	^weapons sum: [:weapon | weapon weight] ifEmpty: [0 * kilogram].
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:47:43' prior: 50645782!
totalSpeedImpact

	^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:49:44' prior: 50645991!
totalSpeedImpact

	"^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]"
	
	
	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:50:12' prior: 50645730 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 0 * kilometer / hour. "5"
	usedTimes := 0
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:50:41' prior: 50645998!
totalSpeedImpact

	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:53:44' prior: 50646009 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:55:10' prior: 50645631 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:56:35'!
attackedWithClaw
	
	life := life - (25 * year).! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:57:02'!
attackedWithClaw

	life := life - (5 * year).
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:59:47'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw stamp: 'AS 5/3/2023 14:35:44'!
attackedWithClaw
	
	life := life - (25 * year).!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:00:39' prior: 50646029 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:09:00' prior: 50646063 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker WithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:09:20'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw: stamp: 'AS 5/3/2023 14:35:44'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:10:18' prior: 50646095!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	anAttacker attackAluminum3000: self withClaw: aClaw	! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:12:46' prior: 50646107!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw isUsedBy: anAttacker againstAluminum3000: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:13:40'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:14:37' prior: 50646079 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:15:03'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (5 * year).
	
	aClaw isUsedBy: anAttacker againstTankRover: self
! !

!methodRemoval: TankRover #attackedWithClaw stamp: 'AS 5/3/2023 14:35:44'!
attackedWithClaw

	life := life - (5 * year).
!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:15:49'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:04' prior: 50646129 overrides: 50645625!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:21' prior: 50646162 overrides: 50645625!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:08'!
clawIsUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !

!methodRemoval: Claw #isUsedBy:againstAluminum3000: stamp: 'AS 5/3/2023 14:35:44'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:20'!
clawIsUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !

!methodRemoval: Claw #isUsedBy:againstTankRover: stamp: 'AS 5/3/2023 14:35:44'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 22:19:13' prior: 50645834 overrides: 50645625!
attack: aVictim by: anAttacker 	

	aVictim attackedBy: anAttacker withHSBlaster: self.
	
	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:19:46'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (25 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:20:14' prior: 50646229!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:21:11'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstTankRover: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50646178 overrides: 50645625!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:45'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:45'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:46'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:46'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:47'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:47'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:47'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:47'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:48'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:48'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:48'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:48'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:48'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:48'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:49'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:49'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:49'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:49'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:49'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:49'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50646993!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50646998!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50647003!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50647009!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:50'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:50'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:50'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:50'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50646993!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50646998!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50647003!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50647009!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:51'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:51'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50647165!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50647178!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50647184!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50647190!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50647196!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:51'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:51'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:51'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:51'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50647165!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50647178!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50647184!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50647190!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50647196!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:04' prior: 50646726!
totalPoints
		


	^(container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:25' prior: 50647349!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]).
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:46' prior: 50647356!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]) ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:55:13' prior: 50647364!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points] ifEmpty: [0]).
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:08'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:52' prior: 50647372!
totalPoints
		


	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:57:30' prior: 50647385!
totalPoints
		
	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:24'!
points
	
	self subclassResponsibility ! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:45' overrides: 50647398!
points
	
	^0! !

!methodRemoval: Backpack #portableObjectThatAddPoints stamp: 'AS 5/3/2023 14:35:52'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:59:25' prior: 50647392!
totalPoints
		
	^ container sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 23:00:16' prior: 50646738!
totalWeight
	
	^container sum: [:portableObject | portableObject weight] ifEmpty: [0]
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:01:33' prior: 50646764!
add: aPortableObject
	
	aPortableObject addTo: self.
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:03:06' overrides: 50647169!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack add: self.! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:04:30' prior: 50647440 overrides: 50647169!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addNoPointPortableObject: self.! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:05:17'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
! !
!PointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:06:51' overrides: 50647169!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPointsPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:07:42'!
addPortableObject: aPortableObject
	
	container add: aPortableObject.
! !

!methodRemoval: Backpack #addNoPointPortableObject: stamp: 'AS 5/3/2023 14:35:52'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
!
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:07:58' prior: 50647447 overrides: 50647169!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addPortableObject: self.! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:08:07' prior: 50647459 overrides: 50647169!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:08:31' prior: 50647424!
add: aPortableObject
	
	aPortableObject addTo: self.
! !

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:03' overrides: 50646898!
isOpen
	
	^false! !
!DoorKeyClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:13' overrides: 50646898!
isOpen
	
	^false! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:14:18' prior: 50646614!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:28' prior: 50646521!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:38' prior: 50646533!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:14:46' prior: 50646645!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !

!methodRemoval: Door class #closed stamp: 'AS 5/3/2023 14:35:52'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.!
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:15:26' prior: 50646507!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:15:35' prior: 50646602!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:15:43' prior: 50646657!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !

!methodRemoval: Door class #opened stamp: 'AS 5/3/2023 14:35:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.!
!DoorKeyClosed class methodsFor: 'no messages' stamp: 'AS 4/28/2023 23:17:32'!
with: aKey

	self initializeWith: aKey.
! !

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:52'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:17:58'!
initializeWith: aKey
	
	key := aKey! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:18:52' prior: 50646628!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:11' prior: 50646550!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:21' prior: 50646567!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:29' prior: 50646586!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:19:36' prior: 50646669!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!methodRemoval: Door class #closedWith: stamp: 'AS 5/3/2023 14:35:53'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.!
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:17' prior: 50647029!
isOpen

	^ state isOpen
! !
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:29' prior: 50647771!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:10:50' prior: 50647043 overrides: 50646993!
toBeClosedBy: aPlayableCharacter

	state close
! !
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/29/2023 15:11:28' overrides: 50646886!
close

	self error: Door alreadyClosedErrorDescription
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:11:43' overrides: 50646886!
close
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:12:29' prior: 50647791 overrides: 50646886!
close

	self error: Door alreadyClosedErrorDescription
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:31'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
! !

!methodRemoval: DoorKeyClosed #close stamp: 'AS 5/3/2023 14:35:53'!
close

	self error: Door alreadyClosedErrorDescription
!
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:46'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
	! !

!methodRemoval: DoorClosed #close stamp: 'AS 5/3/2023 14:35:53'!
close

	self error: Door alreadyClosedErrorDescription
	!
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:14:33'!
close

	state = DoorClosed new
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:15:42'!
toBeOpenedBy: aPlayableCharacter

	open: aDoor
! !
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:17'!
open: aDoor

	aDoor open
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:44'!
open: aDoor

	self error: Door closedWithKeyErrorDescription

! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:17:22'!
open

	state = DoorOpened new
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:20:13' prior: 50647081 overrides: 50647009!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:20:41'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50647846!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50647846!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!methodRemoval: DoorState #toBeUsedBy: stamp: 'AS 5/3/2023 14:35:53'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:00'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:44'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:38' prior: 50647897!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:44' prior: 50647892!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !

!methodRemoval: DoorClosed #toBeUsedBy: stamp: 'AS 5/3/2023 14:35:53'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!

!methodRemoval: DoorKeyClosed #toBeUsedBy: stamp: 'AS 5/3/2023 14:35:53'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:24:26'!
use: aDoor by: aPlayableCharacter

	self subclassResponsibility! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:24:53' prior: 50647841 overrides: 50647009!
toBeUsedBy: aPlayableCharacter

	state use: self by: aPlayableCharacter
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:27:15' prior: 50647067 overrides: 50647003!
toBeOpenedBy: aPlayableCharacter using: aKey

	state open: self by: aPlayableCharacter using: aKey
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:27:42'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key | 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:31' prior: 50647954!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50647969!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50647969!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !

!methodRemoval: DoorState #open:by:using: stamp: 'AS 5/3/2023 14:35:54'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:01' prior: 50647984!
open: aDoor by: aPlayableCharacter using: aKey

	self error: Door noNeedForAKeyErrorDescription! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:43' prior: 50647999!
open: aDoor by: aPlayableCharacter using: aKey

	(key == aKey) ifTrue: [ ^ aDoor open ].
	self error: Door notCorrectKeyErrorDescription. 
! !
!Door methodsFor: 'testing' stamp: 'AS 4/29/2023 15:30:39' prior: 50647775!
isOpen

	^ state class == DoorOpened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 16:03:09' prior: 50647055 overrides: 50646998!
toBeOpenedBy: aPlayableCharacter

	state openby: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:37'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50648050!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50648050!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !

!methodRemoval: DoorState #openby: stamp: 'AS 5/3/2023 14:35:54'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:10:57'!
open: aDoor by: aPlayableCharacter

	door open.! !

!methodRemoval: DoorClosed #openby: stamp: 'AS 5/3/2023 14:35:54'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:11:26'!
open: aDoor by: aPlayableCharacter

	self error: Door closedWithKeyErrorDescription.
! !

!classRemoval: #PointsPortableObject stamp: 'AS 5/3/2023 14:35:54'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/3/2023 14:35:54'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/3/2023 14:35:55'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/3/2023 14:35:55'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/3/2023 14:35:55'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/3/2023 14:35:55'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorKeyClosed stamp: 'AS 5/3/2023 14:35:55'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorClosed stamp: 'AS 5/3/2023 14:35:55'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/3/2023 14:35:56'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/3/2023 14:35:56'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/3/2023 14:35:56'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/3/2023 14:35:56'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:56'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:56'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:57'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:57'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:59'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:35:59'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:01'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:01'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50648896!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50648901!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50648906!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50648912!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:01'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:01'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:02'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:02'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50648896!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50648901!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50648906!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50648912!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:02'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:02'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50649068!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50649081!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50649087!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50649093!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50649099!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50649068!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50649081!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50649087!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50649093!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50649099!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:12'!
points

	self subclassResponsibility
! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:39' overrides: 50649252!
points
	
	^0! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:19:40' prior: 50648641!
totalWeight
	
	^container sum: [:portableObject | portableObject weight ] ifEmpty: [0]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:20:07' prior: 50648629!
totalPoints
		
	^container sum: [:portableObject | portableObject points ] ifEmpty: [0]! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/29/2023 16:23:40' prior: 50648667!
add: aPortableObject
	
	"aPortableObject addTo: self."
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:03'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50648211!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50648225!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50648239!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50648256!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50648275!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50648284!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50648293!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50648302!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50648311!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50648320!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50648329!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50648338!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50648353!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50648362!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50648377!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48' prior: 50648410!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18' prior: 50648424!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30' prior: 50648436!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44' prior: 50648453!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52' prior: 50648470!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03' prior: 50648489!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40' prior: 50648505!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/18/2020 12:37:04' prior: 50648517!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25' prior: 50648531!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39' prior: 50648548!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50' prior: 50648560!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01' prior: 50648572!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50648607!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50648612!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50648617!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50648626 overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50649267!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50649261!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50648651!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50648659!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50649273!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50648682!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50648696!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50648701!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50648706!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50648711!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50648716!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50648722!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50648727!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50648733!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50648739!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50648745!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50648751!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58' prior: 50648785!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:10:33' prior: 50648789!
close 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:10:45' prior: 50648793!
open 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:11:19' prior: 50648797!
openUsing: aKey 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 12:58:22'!
toBeUsedBy: aPlayableCharacter 

	self subclassResponsibility ! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24' prior: 50648801!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25' prior: 50648815!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!ClosedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:43' overrides: 50649940!
isOpen
	
	^ false! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:13:18' overrides: 50649922!
close 
	
	door error: Door alreadyClosedErrorDescription
	! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:33' overrides: 50649927!
open 
	
	door open! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:46' overrides: 50649931!
openUsing: aKey 
	
	door error: Door noNeedForAKeyErrorDescription! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:29' overrides: 50649935!
toBeUsedBy: aPlayableCharacter 
	
	door toBeOpenedBy: aPlayableCharacter ! !

!classDefinition: #KeyClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #KeyClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:04'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!KeyClosedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:58' overrides: 50649940!
isOpen
	
	^false! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:13:36' overrides: 50649922!
close 
	
	door error: Door alreadyClosedErrorDescription
! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:02' overrides: 50649927!
open 
	
	door error: Door closedWithKeyErrorDescription
! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:18' overrides: 50649931!
openUsing: aKey 
	
	door openUsing: aKey ! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:44' overrides: 50649935!
toBeUsedBy: aPlayableCharacter 
	
	door toBeOpenedBy: aPlayableCharacter ! !

!classDefinition: #OpenedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #OpenedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!OpenedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:30' overrides: 50649940!
isOpen
	
	^true! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:24' overrides: 50649922!
close 
	
	door close! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:29' overrides: 50649927!
open 
	
	door error: Door alreadyOpenedErrorDescription
	! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:43' overrides: 50649931!
openUsing: aKey 
	
	door error: Door alreadyOpenedErrorDescription! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:59' overrides: 50649935!
toBeUsedBy: aPlayableCharacter 
	
	door toBeClosedBy: aPlayableCharacter ! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08' prior: 50648837!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35' prior: 50648842!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42' prior: 50648847!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51' prior: 50648852!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29' prior: 50648857!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11' prior: 50648874!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07' prior: 50648896!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25' prior: 50648901!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51' prior: 50648906!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39' prior: 50648912!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:56:34' prior: 50648932!
isOpen

	^ state isOpen! !
!Door methodsFor: 'initialization' stamp: 'HAW 10/18/2020 12:56:34' prior: 50648936!
initializeWith: aDoorStateClass

	state := aDoorStateClass for: self.
	! !
!Door methodsFor: 'initialization' stamp: 'HAW 10/18/2020 12:56:18' prior: 50648940!
initializeWith: aDoorStateClass using: aKey

	self initializeWith: aDoorStateClass.
	key := aKey.
	! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:10:33' prior: 50648946 overrides: 50650162!
toBeClosedBy: aPlayableCharacter

	state close! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:10:45' prior: 50648958 overrides: 50650168!
toBeOpenedBy: aPlayableCharacter

	state open! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:11:19' prior: 50648970 overrides: 50650174!
toBeOpenedBy: aPlayableCharacter using: aKey

	state openUsing: aKey! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 12:56:34' prior: 50648984 overrides: 50650180!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter ! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:14:24'!
close 
	
	state := ClosedDoorState for: self. 
	! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:14:33'!
open 
	
	state := OpenedDoorState for: self.
	! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:15:18'!
openUsing: aKey 
	
	key = aKey ifTrue: [ ^state := OpenedDoorState for: self ].
	self error: Door notCorrectKeyErrorDescription. 
! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:10' prior: 50649004!
closed

	^self new initializeWith: ClosedDoorState ! !
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:28' prior: 50649010!
closedWith: aKey

	^self new initializeWith: KeyClosedDoorState using: aKey.
	! !
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:40' prior: 50649016!
opened

	^self new initializeWith: OpenedDoorState ! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28' prior: 50649021!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28' prior: 50649026!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06' prior: 50649031!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40' prior: 50649036!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32' prior: 50649041!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16' prior: 50649046!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:05'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50649068!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50649076!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' prior: 50649081 overrides: 50650162!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' prior: 50649087 overrides: 50650168!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' prior: 50649093 overrides: 50650174!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' prior: 50649099 overrides: 50650180!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50649122!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50649128 overrides: 50650328!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' prior: 50649133 overrides: 50650342!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' prior: 50649139 overrides: 50650349!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' prior: 50649145 overrides: 50650356!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' prior: 50649152 overrides: 50650363!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50650332!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50649169!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50649193 overrides: 50650328!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50649197!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50649204 overrides: 50649252!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' prior: 50649209 overrides: 50650342!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' prior: 50649215 overrides: 50650349!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' prior: 50649221 overrides: 50650356!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' prior: 50649228 overrides: 50650363!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50650332!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:06'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50649245!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'AS 5/3/2023 14:36:06'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/3/2023 14:36:06'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/3/2023 14:36:06'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/3/2023 14:36:06'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/3/2023 14:36:07'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/3/2023 14:36:07'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #OpenedDoorState stamp: 'AS 5/3/2023 14:36:07'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #KeyClosedDoorState stamp: 'AS 5/3/2023 14:36:07'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #ClosedDoorState stamp: 'AS 5/3/2023 14:36:07'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/3/2023 14:36:07'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/3/2023 14:36:07'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/3/2023 14:36:08'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/3/2023 14:36:08'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:08'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:08'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:09'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:09'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:10'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:10'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:11'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:11'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:11'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:11'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:12'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50651330!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50651335!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50651340!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50651346!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:13'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:13'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:13'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:13'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50651330!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50651335!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50651340!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50651346!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:14'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:14'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50651502!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50651515!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50651521!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50651527!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50651533!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:14'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:14'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:14'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:14'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50651502!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50651515!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50651521!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50651527!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50651533!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:15'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:15'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:15'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:15'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:41:38' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: #Gold.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: #Silver.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: #Normal! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:15:53'!
combo1

	^#Combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:21:01'!
combo2

	^#Combo2! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test02CanQuerySalesByCustomer

	| salesToAdaLovelace |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test03SalesAreDistinguishedByCustomer

	| salesToAdaLovelace salesToAlanKay |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]).

	salesToAlanKay := salesSystem salesMadeTo: alanKay.
	self assert: 1 equals: salesToAlanKay size.
	self assert: 1 equals: (salesToAlanKay  count: [ :aProduct | aProduct = self combo2 ])! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:41:51'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:19'!
test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:07'!
test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:41'!
test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:48:39'!
test08NoRewardExpectedWhenCustomerHasNotBuyAnything

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self failWith: 'No reward expected when customer has not buy anything'! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 1 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo2.
	self assert: 60*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	| alaKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alaKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 1 equals: alaKayReward quantity.
	self assert: alaKayReward isForCombo2.
	self assert: 120*3/4*peso equals: alaKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 1 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo2.
	self assert: 120*9/10*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 2 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo1.
	self assert: 75*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	| alanKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alanKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 2 equals: alanKayReward quantity.
	self assert: alanKayReward isForCombo1.
	self assert: 83*peso equals: alanKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 2 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo1.
	self assert: 97*peso equals: billGatesReward price.
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:16'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:16'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'type' stamp: 'HAW 9/21/2019 13:05:10'!
type

	^type! !
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/21/2019 13:00:45'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType ! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:16'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:16'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/21/2019 13:00:21'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:16'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:16'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo1
	
	^product = #Combo1! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo2
	
	^product = #Combo2! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'product volume' stamp: 'HAW 9/22/2019 19:51:19'!
volumeOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^250*milliliter ].
	aProduct = #Combo2 ifTrue: [ ^100*milliliter ].

	self error: 'Invalid product'
	! !
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:51:19'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | self volumeOf: aProduct ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:50:03' overrides: 16904184!
initialize

	Smalltalk at: #milliliter put: (BaseUnit named: 'milliliter')! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:17'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:03:50'!
createRewardFor: aCustomer 
	
	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'product price' stamp: 'HAW 9/22/2019 21:43:12'!
priceOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^150*peso ].
	aProduct = #Combo2 ifTrue: [ ^120*peso ].

	self error: 'Invalid combo type'! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50652144!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := 75*peso ].
	aCustomer type = #Silver ifTrue: [ price := 83*peso ].
	aCustomer type = #Normal ifTrue: [ price := 97*peso ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50652149!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:01:41' overrides: 50652153!
rewardedProduct
	
	^#Combo1! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50652174!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50652144!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := (self priceOf: product)/2 ].
	aCustomer type = #Silver ifTrue: [ price := (self priceOf: product)*3/4 ].
	aCustomer type = #Normal ifTrue: [ price := (self priceOf: product)*9/10 ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50652149!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:00:28' overrides: 50652153!
rewardedProduct
	
	^#Combo2! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:18'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50652174!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/3/2023 14:36:18'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/3/2023 14:36:18'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/3/2023 14:36:19'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/3/2023 14:36:19'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/3/2023 14:36:19'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/3/2023 14:36:19'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/3/2023 14:36:19'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:19'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:19'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:30:01' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopGoldCustomer named: 'Ada Lovelace'.
	alanKay := CoffeeShopSilverCustomer named: 'Alan Kay'.
	billGates := CoffeeShopNormalCustomer named: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/22/2019 21:21:44'!
combo1

	^CoffeeShopCombo1 new! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/22/2019 21:21:54'!
combo2

	^CoffeeShopCombo2 new! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/22/2019 21:30:20'!
initializeNamed: aName 

	name := aName.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:37:51'!
rewardPriceFor: aReward

	self subclassResponsibility ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 21:30:29'!
named: aName 

	^self new initializeNamed: aName ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50652624!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50652624!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50652624!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:21'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'comparing' stamp: 'HAW 9/22/2019 21:22:35' overrides: 16901772!
= anObject

	^self class = anObject class! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:38:21'!
price

	self subclassResponsibility ! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:38:27'!
volume

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopCombo1 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCombo1 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCombo1 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:21' overrides: 50652734!
price

	^150*peso! !
!CoffeeShopCombo1 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:57' overrides: 50652738!
volume

	^250*milliliter ! !

!classDefinition: #CoffeeShopCombo2 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCombo2 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCombo2 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:34' overrides: 50652734!
price

	^120*peso! !
!CoffeeShopCombo2 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:45' overrides: 50652738!
volume

	^100*milliliter ! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 21:24:59'!
isForCombo1
	
	^product class = CoffeeShopCombo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 21:25:07'!
isForCombo2
	
	^product class = CoffeeShopCombo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:22'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16904184!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50652947!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:23:58' overrides: 50652951!
rewardedProduct
	
	^CoffeeShopCombo1 new! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50652955!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50652959!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50652963!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:23'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50652977!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:24'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:24'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50652947!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:24:09' overrides: 50652951!
rewardedProduct
	
	^CoffeeShopCombo2 new! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50652955!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50652959!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50652963!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:24'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:24'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50652977!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/3/2023 14:36:24'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/3/2023 14:36:24'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/3/2023 14:36:24'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/3/2023 14:36:25'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/3/2023 14:36:25'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo2 stamp: 'AS 5/3/2023 14:36:25'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo1 stamp: 'AS 5/3/2023 14:36:25'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 5/3/2023 14:36:25'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 5/3/2023 14:36:25'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 5/3/2023 14:36:25'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 5/3/2023 14:36:26'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/3/2023 14:36:26'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/3/2023 14:36:26'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:26'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:26'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/23/2019 08:55:28' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopCustomer goldNamed: 'Ada Lovelace'.
	alanKay := CoffeeShopCustomer silverNamed: 'Alan Kay'.
	billGates := CoffeeShopCustomer normalNamed: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:18'!
combo1

	^CoffeeShopProduct combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:25'!
combo2

	^CoffeeShopProduct combo2 ! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:27'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:27'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:54:02'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:17'!
rewardPriceFor: aReward

	^type rewardPriceFor: aReward ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:09'!
goldNamed: aName 

	^self named: aName ofType: CoffeeShopGoldCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:44'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:28'!
normalNamed: aName 

	^self named: aName ofType: CoffeeShopNormalCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:18'!
silverNamed: aName 

	^self named: aName ofType: CoffeeShopSilverCustomer new! !

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomerType methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:32'!
rewardPriceFor: aCustomer

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50653529!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50653529!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50653529!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:19'!
price

	^price! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:27'!
volume

	^volume ! !
!CoffeeShopProduct methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:02:56'!
initializeOf: aVolume at: aPrice

	volume := aVolume.
	price := aPrice.
! !

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:28'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:40'!
combo1

	^combo1! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:46'!
combo2

	^combo2 ! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:29'!
of: aVolume at: aPrice 

	^self new initializeOf: aVolume at: aPrice 
! !
!CoffeeShopProduct class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:03:14' overrides: 16904184!
initialize

	combo1 := self of: 250*milliliter at: 150*peso.
	combo2 := self of: 100*milliliter at: 120*peso! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:00:41'!
isForCombo1
	
	^product = CoffeeShopProduct combo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:01:02'!
isForCombo2
	
	^product = CoffeeShopProduct combo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:29'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16904184!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50653822!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:00:06' overrides: 50653826!
rewardedProduct
	
	^CoffeeShopProduct combo1 ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50653830!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50653834!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50653838!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50653852!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:30'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50653822!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:01:14' overrides: 50653826!
rewardedProduct
	
	^CoffeeShopProduct combo2 ! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50653830!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50653834!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50653838!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:31'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/3/2023 14:36:31'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50653852!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/3/2023 14:36:31'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/3/2023 14:36:31'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/3/2023 14:36:31'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/3/2023 14:36:31'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/3/2023 14:36:32'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 5/3/2023 14:36:32'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 5/3/2023 14:36:32'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 5/3/2023 14:36:32'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 5/3/2023 14:36:32'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'AS 5/3/2023 14:36:32'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/3/2023 14:36:32'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54'!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:33'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:34'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:34'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36'!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28'!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03'!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07'!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16'!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11'!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:35'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:36'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:36'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50654586!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50654582!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:36'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:36'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50654586!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50654582!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:36'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:36'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25'!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39'!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54'!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48'!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39'!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21'!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:37'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:37'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:37'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:37'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38'!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17'!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09'!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:38'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:38'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !

!classRemoval: #TankRover stamp: 'AS 5/3/2023 14:36:39'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Aluminum3000 stamp: 'AS 5/3/2023 14:36:39'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #TurboLaserCannon stamp: 'AS 5/3/2023 14:36:39'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #HSBlaster stamp: 'AS 5/3/2023 14:36:39'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Claw stamp: 'AS 5/3/2023 14:36:40'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Weapon stamp: 'AS 5/3/2023 14:36:40'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #RobotWarsTest stamp: 'AS 5/3/2023 14:36:40'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Trailer stamp: 'AS 5/3/2023 14:36:40'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/3/2023 14:36:40'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/3/2023 14:36:41'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/3/2023 14:36:41'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/3/2023 14:36:41'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/3/2023 14:36:41'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/3/2023 14:36:41'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/3/2023 14:36:41'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54'!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:42'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:43'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:43'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36'!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28'!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03'!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07'!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16'!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11'!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:44'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:45'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:45'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50655618!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50655614!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:45'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:45'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50655618!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50655614!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:45'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:45'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25'!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39'!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54'!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48'!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39'!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21'!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:46'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:46'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:46'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:46'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38'!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17'!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09'!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:47'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:47'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:19:45' prior: 50655870!
totalProductsHeight

	^(container select: [ :product | product isStackable])
		sum: [ :product | product height ]
		ifEmpty: [0]

! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:41' prior: 50655882!
totalProductsWeight
	
	^container sum: [ :product | product weight ]
! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:56' prior: 50656027!
totalProductsWeight
	
	^container sum: [ :product | product weight ] ifEmpty: [0]
! !

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:48'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotStatusMechanicalFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:25:40'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:27:46' prior: 50655755!
closeOrderUsing: aCashier
	
	"status from: self closeOrderTo: aCashier"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:32:10'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:33:45'!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	| aTrailer |
	
	aRobot outOfOrder.
		
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	^ true
! !
!RobotStatusOutOfOrder methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:35:08'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusOutOfOrderFrom: aRobot
	! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:36:44' prior: 50656177!
from: aRobot closeOrderTo: aCashier
	
	aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:37:14'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:37:42'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusWorkingNormal methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:38:11'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:38:45'!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	| aTrailer | 
	
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
	^ true
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:23' prior: 50655778!
outOfOrder

	status := RobotStatusOutOfOrder new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:37' prior: 50655782!
withMechanicalFailure

	status := RobotStatusMechanicalFailure new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:48' prior: 50655786!
withSensorsFailure

	status := RobotStatusSensorsFailure
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:40:10' prior: 50656139!
closeOrderUsing: aCashier
	
	status from: self closeOrderTo: aCashier.
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:41:38' prior: 50655767!
take: aProduct

	status take: aProduct into: trailer
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:43:37' prior: 50656237!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:46:01'!
take: aProduct into: trailer of: aRobot
	
	^trailer withMechanicalFailure carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:44'!
take: aProduct into: trailer of: aRobot
	
	^aRobot class signalOutOfOrder.! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:57' prior: 50656248!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:13'!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:20'!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/30/2023 14:48:46' prior: 50655796!
initializeWith: aTrailer

	trailer := aTrailer.
	status := RobotStatusWorkingNormal new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:49:01' prior: 50656227!
withSensorsFailure

	status := RobotStatusSensorsFailure new
! !

!methodRemoval: RobotStatusMechanicalFailure #closeOrderUsing: stamp: 'AS 5/3/2023 14:36:49'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"!
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:07' prior: 50656153!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:19' prior: 50656189!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:34' prior: 50656201!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:15' prior: 50656320!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:32' prior: 50656326!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:51:51'!
receiveOrderWithStatusSensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:51' prior: 50656345!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !

!methodRemoval: Cashier #receiveOrderWithStatusSeensorsFailureFrom: stamp: 'AS 5/3/2023 14:36:49'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
!
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:52:04' prior: 50656332!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:57:14' prior: 50655535!
receiveOrder: aRobot
	
	aRobot closeOrderUsing: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:59:54' prior: 50656338!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:12' prior: 50656184!
from: aRobot closeOrderTo: aCashier
	
	^aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:17' prior: 50656358!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:24' prior: 50656371!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 15:01:59' prior: 50656232!
closeOrderUsing: aCashier
	
	^status from: self closeOrderTo: aCashier.
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:07:39' prior: 50656168!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:08:02' prior: 50656207!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	self assertTrailerNotEmpty: aRobot trailer.	
	"Comentario: en este punto el cashier realizaría el checkout de los productos."		
	^ true
! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:12'!
from: aRobot closeOrderTo: aCashier
	
	self subclassResponsibility ! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:38'!
take: aProduct into: trailer of: aRobot

	self subclassResponsibility ! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:01:25'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:17' prior: 50655910!
assertHeightAdding: aProduct
	
	self execute: [ self signalMaxHeightCapacityExceeded ]
		If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:32'!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !

!methodRemoval: Trailer #execute:If:exceed: stamp: 'AS 5/3/2023 14:36:49'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
!
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:14' prior: 50656447!
assertHeightAdding: aProduct
	
	self If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	
		execute: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:55' prior: 50656466!
assertHeightAdding: aProduct
	
	self if: (self totalProductsHeight + aProduct height)
		 exceed: heightCapacity	
		 execute: [ self signalMaxHeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:04:22' prior: 50655917!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/3/2023 14:36:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:06' overrides: 16961394!
setUp

	trailer := Trailer with: 20 and: 100.
	robot := Robot with: trailer.	
	cashier := Cashier new.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:55' prior: 50655114!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	self
		should: [ 
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:07:11' prior: 50655127!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	self
		should: [ 
			robot withMechanicalFailure.
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'AS 4/30/2023 16:07:28' prior: 50655142!
test03ShouldNotAcceptSensorsFailureRobot

	self
		should: [ 
			robot withSensorsFailure.
			cashier receiveOrder: robot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'AS 4/30/2023 16:07:55' prior: 50655156!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	self
		should: [ 
			robot take: (ProductA with: 1  and: 1).
			robot withMechanicalFailure.
			
			cashier receiveOrder: robot.
			
			robot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:11:47' prior: 50656415!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self halt.
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:13:52' prior: 50656242!
take: aProduct

	self halt.
	status take: aProduct into: trailer of: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:14:13' prior: 50656575!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:15:00' prior: 50656568!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:16:09' prior: 50656482!
assertWeightAdding: aProduct
	
	self halt.
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:17:09' prior: 50656592!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:18:21' prior: 50656455!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: [aBlock value].
! !

!classRemoval: #TurboInactive stamp: 'AS 5/3/2023 14:38:00'!
Turbo subclass: #TurboInactive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboActive stamp: 'AS 5/3/2023 14:38:00'!
Turbo subclass: #TurboActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Turbo stamp: 'AS 5/3/2023 14:38:00'!
Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Track stamp: 'AS 5/3/2023 14:38:00'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #SectorTurboNotAdmited stamp: 'AS 5/3/2023 14:38:00'!
Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #SectorTurboAdmited stamp: 'AS 5/3/2023 14:38:00'!
Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Sector stamp: 'AS 5/3/2023 14:38:01'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #GrandPrix stamp: 'AS 5/3/2023 14:38:01'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneCar stamp: 'AS 5/3/2023 14:38:01'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneTest stamp: 'AS 5/3/2023 14:38:01'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Trailer stamp: 'AS 5/3/2023 14:38:21'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusWorkingNormal stamp: 'AS 5/3/2023 14:38:21'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusSensorsFailure stamp: 'AS 5/3/2023 14:38:21'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusOutOfOrder stamp: 'AS 5/3/2023 14:38:21'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusMechanicalFailure stamp: 'AS 5/3/2023 14:38:21'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatus stamp: 'AS 5/3/2023 14:38:21'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/3/2023 14:38:22'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/3/2023 14:38:22'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/3/2023 14:38:22'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/3/2023 14:38:22'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/3/2023 14:38:22'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/3/2023 14:38:22'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/3/2023 14:38:23'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/3/2023 14:38:23'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/3/2023 14:38:23'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #PointsPortableObject stamp: 'AS 5/3/2023 14:38:32'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/3/2023 14:38:33'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/3/2023 14:38:33'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/3/2023 14:38:33'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/3/2023 14:38:33'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/3/2023 14:38:33'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/3/2023 14:38:33'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/3/2023 14:38:34'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/3/2023 14:38:34'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/3/2023 14:38:34'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorOpen stamp: 'AS 5/3/2023 14:38:47'!
AnObsoleteDoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

----End fileIn of E:\ISW1\Parciales\2022\1C\Primer Parcial\ISW1-2022-1C-Parcial-1.st----!
!Track methodsFor: 'accessing' stamp: 'AS 5/3/2023 15:01:13' prior: 50657786!
cars
	| allCars |
	
	allCars := Set new.
	sectors do: [ :sector | allCars addAll: sector cars ].
	^ allCars
	! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:01:14'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:01:15'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:01:15'!
PASSED!
!Track methodsFor: 'accessing' stamp: 'AS 5/3/2023 15:34:15' prior: 50657845!
cars
	| allCars |
	
	allCars := Set new.
	sectors do: [ :sector | allCars addAll: sector cars ].
	^ allCars
! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:34:17'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:34:17'!
PASSED!
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:38:49' prior: 50657802!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix sector |
	
	^sectors includes: aCar.
	"
	inc := false.
	ix := 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector := sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc := true]
		ifFalse: [
			ix := ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s := sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix := ix + 1
			]	
		]. 
	^ inc
	"! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:38:55'!
FAILURE!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:38:55'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:38:55'!
FAILURE!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:40:00'!
FAILURE!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:40:00'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:40:00'!
FAILURE!

sectors size!
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:45:00' prior: 50658033!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix s |
	
	^sectors anySatisfy: [ :sector | sector includes: aCar].
	"
	inc := false.
	ix := 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector := sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc := true]
		ifFalse: [
			ix := ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s := sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix := ix + 1
			]	
		]. 
	^ inc
	"! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:45:07'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:45:07'!
PASSED!
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:45:29' prior: 50658232!
includes: aCar

	^sectors anySatisfy: [ :sector | sector includes: aCar].
! !
!Track methodsFor: 'accessing' stamp: 'AS 5/3/2023 15:46:43' prior: 50657794!
length

	^sectors sum: [ :sector | sector length] ifEmpty: [0 * kilometer].
! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:46:44'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:46:44'!
PASSED!
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:50:47' prior: 50657736!
positionOf: aCar
	| accumulatedLength ix s |

	^sectors sum: [ :sector | (sector includes: aCar) ifFalse: [sector length] ifTrue: [sector positionOf: aCar] ] ifEmpty: [ 0 * kilometer ].
	"
	ix := 1.
	sector := (sectors at: ix).
	accumulatedLength := 0 * kilometer.
	
	[sector includes: aCar] whileFalse: [
		accumulatedLength := accumulatedLength + sector length.
		ix := ix + 1.
		sector := (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar).
	"! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:50:54'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:50:54'!
PASSED!
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:51:23' prior: 50658435!
positionOf: aCar

	^sectors sum: [ :sector | (sector includes: aCar) 
					ifFalse: [sector length] 
					ifTrue: [sector positionOf: aCar] ]
		ifEmpty: [ 0 * kilometer ].
! !
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:55:14' prior: 50657777!
sectorOf: aCar ifNone: aBlock

	 | ix |
	
	^sectors detect: [ :sector | sector includes: aCar] ifNone: [aBlock value].
	"
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value.
	"! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 15:55:18'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 15:55:19'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 15:55:19'!
PASSED!
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:55:39' prior: 50658549!
sectorOf: aCar ifNone: aBlock
	
	^sectors detect: [ :sector | sector includes: aCar]
			ifNone: [aBlock value].
! !
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:57:02' prior: 50658337!
includes: aCar

	^sectors anySatisfy: [ :sector | sector includes: aCar].! !

Sector subclass: #TurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboSector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 15:57:42'!
Sector subclass: #TurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Sector subclass: #NoTurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #NoTurboSector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 15:57:48'!
Sector subclass: #NoTurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Object subclass: #TurboState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboState category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 15:59:23'!
Object subclass: #TurboState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

TurboState subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboActivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 15:59:42'!
TurboState subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

TurboState subclass: #TurboDeactivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboDeactivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 15:59:51'!
TurboState subclass: #TurboDeactivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Object subclass: #TurboState
	instanceVariableNames: 'activations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboState category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 16:00:52'!
Object subclass: #TurboState
	instanceVariableNames: 'activations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations turboState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/3/2023 16:01:33'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations turboState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'initialization' stamp: 'AS 5/3/2023 16:02:19' prior: 50657367!
initializeDrivenBy: aDriver 

	driver := aDriver.
	turboActivated := false.
	turboActivations := 0.
	speed := 0*kilometer/hour.
	traveledDistance := 0.
	turboState := TurboDeactivated new.
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:07:24'!
createSectorWithTurboOf: length

	^TurboSector of: 0 * kilometer.
! !
!TurboSector class methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:09:04'!
of: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	^ self new initializeOf: aLength
	"^ self new initializeOf: aLength; withTurbo: true; yourself "! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 5/3/2023 16:09:32'!
of: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	^ self new initializeOf: aLength! !

!methodRemoval: TurboSector class #of: stamp: 'AS 5/3/2023 16:09:39'!
of: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	^ self new initializeOf: aLength
	"^ self new initializeOf: aLength; withTurbo: true; yourself "!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:10:16'!
createSectorWithoutTurboOf: length

	^NoTurboSector of: 0 * kilometer.
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:10:38' prior: 50656874!
test01SectorLengthMustBePositive

	self 
		should: [ self createSectorWithTurboOf: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 16:10:41'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:11:11' prior: 50656882!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := self createSectorWithTurboOf: 10 * kilometer.
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:11:14'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:11:14'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:11:47'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:12:08' prior: 50658809!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := self createSectorWithTurboOf: (10 * kilometer).
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:12:12'!
ERROR!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:12:12'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:12:57' prior: 50658761!
createSectorWithTurboOf: aLength

	^TurboSector of: aLength
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:13:06' prior: 50658792!
createSectorWithoutTurboOf: aLength

	^NoTurboSector of: aLength
! !

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:13:09'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:13:25' prior: 50656899!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector :=  self createSectorWithoutTurboOf: 10*kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:13:27'!
FAILURE!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:13:34'!
FAILURE!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:13:34'!
FAILURE!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:13:44' prior: 50658877!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector :=  self createSectorWithoutTurboOf: 10 * kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:14:03'!
FAILURE!
!NoTurboSector methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:15:15' overrides: 50657609!
activateTurboTo: aCarToActivateTurboTo

	self error: Sector turboNotAllowedErrorDescription! !
!TurboSector methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:15:35' overrides: 50657609!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	positionOfCarAhead := self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo! !

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:15:43'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:16:15' prior: 50656914!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 20 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 16:16:17'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:16:31' prior: 50656935!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:16:37'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:16:50' prior: 50656953!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:16:55'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 16:17:01'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:17:05'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:17:29' prior: 50656997!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	track := Track withSectors: sectors.
	outside := track length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 16:17:32'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:17:52' prior: 50657017!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
		
	positionInSector2 := 5 * kilometer.
	positionInTrack := sectors first length + positionInSector2.
	
	track := Track withSectors: sectors.
	car := FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 16:17:55'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:18:19' prior: 50657041!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
		
	track := Track withSectors: sectors.
	car1 := FormulaOneCar drivenBy: #Schumacher.
	car2 := FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 16:18:22'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:18:40' prior: 50657062!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	track := Track withSectors: sectors.
	car := FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 16:18:44'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:19:02' prior: 50657080!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track := Track withSectors: (OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer)).
	numberOfLaps := 100.
	
	grandPrix := GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 16:19:06'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:19:20' prior: 50657095!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (self createSectorWithTurboOf: 10 * kilometer)))
		running: 100.
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	hamilton := FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 16:19:25'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:19:37' prior: 50657115!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (self createSectorWithTurboOf: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 16:19:40'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:20:01' prior: 50657133!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 16:20:06'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:20:26' prior: 50657155!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 16:20:29'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:20:48' prior: 50657175!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 16:20:51'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:11' prior: 50657198!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	sectorA := self createSectorWithTurboOf: 10 * kilometer.
	sectorB := self createSectorWithTurboOf: 30 * kilometer.
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 16:21:15'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:27' prior: 50657225!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 16:21:32'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:42' prior: 50657245!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 16:21:44'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 16:21:44'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:59' prior: 50657265!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 16:22:05'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:22:15' prior: 50657286!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 16:22:18'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:22:28' prior: 50657308!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 16:22:32'!
PASSED!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:22:42' prior: 50657329!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 16:22:44'!
PASSED!

!methodRemoval: Sector class #withTurboOf: stamp: 'AS 5/3/2023 16:23:15'!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ self new initializeOf: aLength; withTurbo: true; yourself !

!methodRemoval: Sector class #withoutTurboOf: stamp: 'AS 5/3/2023 16:23:18'!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; withTurbo: false; yourself !

!methodRemoval: Sector #withTurbo: stamp: 'AS 5/3/2023 16:23:37'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:23:41'!
ERROR!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 16:23:41'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 16:23:42'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:23:42'!
ERROR!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:24:05' prior: 50656985!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	track := Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:24:07'!
PASSED!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 16:24:11'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 16:24:11'!
PASSED!
!Sector methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:24:34' prior: 50657609!
activateTurboTo: aCarToActivateTurboTo

	self subclassResponsibility 
! !

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 16:24:38'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 16:24:38'!
PASSED!
!TurboState methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:26:27'!
activateIn: aCar
	
	self subclassResponsibility! !
!TurboActivated methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:26:39' overrides: 50659853!
activateIn: aCar
	
	self subclassResponsibility! !
!TurboDeactivated methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:26:44' overrides: 50659853!
activateIn: aCar
	
	self subclassResponsibility! !
!TurboActivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:27:24' prior: 50659858 overrides: 50659853!
activateIn: aCar
	
	self error: aCar turboAlreadyActivatedErrorDescription.! !
!TurboActivated class methodsFor: 'errorDescriptions' stamp: 'AS 5/3/2023 16:28:40'!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!TurboActivated methodsFor: 'actions' stamp: 'AS 5/3/2023 16:28:54' prior: 50659869 overrides: 50659853!
activateIn: aCar
	
	self error: self class turboAlreadyActivatedErrorDescription.! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:29:34' prior: 50657411!
activateTurbo

	turboState activateIn: self.
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:30:48' prior: 50659887!
activateTurbo

	turboState activateIn: currentSector To: self.
"	currentSector activateTurboTo: self."
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:30:59' prior: 50659893!
activateTurbo

	turboState activateAt: currentSector To: self.
"	currentSector activateTurboTo: self."
! !
!TurboState methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:31:31'!
activateAt: currentSector To: aCar
	
	self subclassResponsibility! !

!methodRemoval: TurboState #activateIn: stamp: 'AS 5/3/2023 16:31:37'!
activateIn: aCar
	
	self subclassResponsibility!
!TurboActivated methodsFor: 'actions' stamp: 'AS 5/3/2023 16:31:53' overrides: 50659905!
activateAt: currentSector To: aCar

	self error: self class turboAlreadyActivatedErrorDescription.! !

!methodRemoval: TurboActivated #activateIn: stamp: 'AS 5/3/2023 16:31:56'!
activateIn: aCar
	
	self error: self class turboAlreadyActivatedErrorDescription.!
!TurboDeactivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:32:05' overrides: 50659905!
activateAt: currentSector To: aCar
	
	! !

!methodRemoval: TurboDeactivated #activateIn: stamp: 'AS 5/3/2023 16:32:27'!
activateIn: aCar
	
	self subclassResponsibility!
!TurboDeactivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:33:51' prior: 50659926 overrides: 50659905!
activateAt: currentSector To: aCar
	
	aCar turboActivated.
	currentSector activateTurboTo: aCar.
	! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'AS 5/3/2023 16:34:15' prior: 50657439!
activateTurboInSectorWithTurbo
	
	turboActivated := TurboActivated new.
	turboActivations := turboActivations + 1 ! !
!TurboDeactivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:34:40' prior: 50659935 overrides: 50659905!
activateAt: currentSector To: aCar
	
	currentSector activateTurboTo: aCar.
	! !

!classRemoval: #TurboDeactivated stamp: 'AS 5/3/2023 16:55:05'!
TurboState subclass: #TurboDeactivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboActivated stamp: 'AS 5/3/2023 16:55:05'!
TurboState subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboState stamp: 'AS 5/3/2023 16:55:05'!
Object subclass: #TurboState
	instanceVariableNames: 'activations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Track stamp: 'AS 5/3/2023 16:55:05'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboSector stamp: 'AS 5/3/2023 16:55:06'!
Sector subclass: #TurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #NoTurboSector stamp: 'AS 5/3/2023 16:55:06'!
Sector subclass: #NoTurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Sector stamp: 'AS 5/3/2023 16:55:06'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #GrandPrix stamp: 'AS 5/3/2023 16:55:06'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneCar stamp: 'AS 5/3/2023 16:55:06'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations turboState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneTest stamp: 'AS 5/3/2023 16:55:06'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

----End fileIn of E:\ISW1\Parciales\2022\1C\Primer Parcial\ISW1-2022-1C-Parcial-1.st----!

!testRun: #FormulaOneTest #test01SectorLengthMustBePositive stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test03CarCannotActivateTurboInNonTurboSector stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test04CarCannotActivateTurboWhenNoCarAhead stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test07TrackMustHaveSectors stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test08TheLengthOfATrackShouldBeTheSumOfItsSectors stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test10TrackShouldPlaceCarInKilometerWithinSector stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test11TrackShouldKnowCarsInRunning stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test12CarCannotBeInMoreThanOneSectorAtATime stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test14TwoCarsCanBeAtTheSameDistanceFromStart stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test15ACarStoppedShouldNotMoveAfterSomeTime stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test16ACarSpeedingShouldMoveAfterSomeTime stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test17GrandPrixKnowsSectorOfCar stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test18GrandPrixKnowsSectorOfCarAfterSomeTime stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test19GrandPrixMovesCarsBetweenSectors stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test20FirstTurboIncrementsSpeedByTwentyPercent stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test21SecondTurboSpeedsByTenPercent stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test22ThirdTurboSpeedsByFivePercent stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test23AfterThridTurbo_TurboIsExhausted stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test24CanNotActivateTurboWhenTurboIsActivated stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

!testRun: #FormulaOneTest #test25CanNotDeactivateTurboWhenIsDeactivated stamp: 'AS 5/3/2023 17:15:17'!
PASSED!

----STARTUP---- (6 May 2023 12:18:41) as F:\CUIS University ISW1\CuisUniversity-5706.image!


!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:50'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:50'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10'!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48'!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38'!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23'!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58'!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57'!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51'!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11'!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31'!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17'!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02'!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15'!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40'!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05'!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04'!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09'!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35'!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16'!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15'!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25'!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36'!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46'!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52'!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:52'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:52'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:52'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:52'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19'!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30'!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38'!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43'!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48'!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54'!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03'!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34'!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10'!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19'!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01'!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49'!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10'!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14'!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34'!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48'!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46'!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38'!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53'!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24'!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12'!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:53'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50661670!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50661670!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50661670!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 5/6/2023 12:18:53'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50661744 overrides: 50661757!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50661748 overrides: 50661757!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50661752 overrides: 50661757!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50661630!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50661630!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50661630!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 5/6/2023 12:18:54'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50661774 overrides: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50661815 overrides: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50661856 overrides: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50661395!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50661399!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50661403!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 5/6/2023 12:18:54'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 5/6/2023 12:18:54'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50662010 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50662016 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50662022 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50661452!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50661471!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50661489!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50661483!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50661502!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50661515!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50661527!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 5/6/2023 12:18:54'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50661956 overrides: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50662128 overrides: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50661974 overrides: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10' prior: 50661112!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48' prior: 50661129!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38' prior: 50661151!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23' prior: 50661159!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58' prior: 50661169!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57' prior: 50661177!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51' prior: 50661191!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11' prior: 50661205!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31' prior: 50661219!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17' prior: 50661234!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02' prior: 50661249!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15' prior: 50661264!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40' prior: 50661279!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05' prior: 50661298!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04' prior: 50661316!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09' prior: 50661334!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35' prior: 50661353!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16' prior: 50661369!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15' prior: 50661386!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25' prior: 50661391!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36' prior: 50661990!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46' prior: 50661994!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52' prior: 50661999!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' prior: 50661419 overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19' prior: 50661449!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58' prior: 50662061!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30' prior: 50661461!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38' prior: 50662071!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43' prior: 50662088!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48' prior: 50662082!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54' prior: 50661496!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03' prior: 50662093!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34' prior: 50662105!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10' prior: 50662115!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19' prior: 50661532!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01' prior: 50661535!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49' prior: 50661539!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10' prior: 50661546!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14' prior: 50661552!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34' prior: 50661566!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48' prior: 50661573!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46' prior: 50661579!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10' prior: 50661585!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38' prior: 50661616!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53' prior: 50661619!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43' prior: 50661936!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24' prior: 50661757!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:54'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12' prior: 50661682!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50661762 overrides: 50662775!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50661766 overrides: 50662775!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50661770 overrides: 50662775!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 5/6/2023 12:18:55'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50662851 overrides: 50662864!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50662855 overrides: 50662864!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50662859 overrides: 50662864!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50661942 overrides: 50662735!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50662145 overrides: 50662735!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50662162 overrides: 50662735!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 5/6/2023 12:18:55'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50662881 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50662922 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50662964 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50662488!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50662493!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50662498!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' prior: 50662041 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' prior: 50662048 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' prior: 50662055 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 5/6/2023 12:18:55'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 5/6/2023 12:18:55'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50663118 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50663124 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50663130 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50662548!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50662567!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50662587!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50662580!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50662602!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50662616!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50662628!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 5/6/2023 12:18:55'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50663064 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50663236 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50663082 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:18:55'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'AS 4/28/2023 20:36:19' prior: 50662544!
type

	self subclassResponsibility 	! !
!Aluminum3000 methodsFor: 'nil' stamp: 'AS 4/28/2023 20:36:42' overrides: 50663315!
type
	
	^#Aluminum3000! !
!TankRover methodsFor: 'no messages' stamp: 'AS 4/28/2023 20:36:54' overrides: 50663315!
type
	
	^#TankRover! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:38:43' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:39:20' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !

!methodRemoval: Robot class #ofType: stamp: 'AS 5/6/2023 12:18:55'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'!
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:48' prior: 50662478!
createAluminum3000

	^ Aluminum3000 new! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:58' prior: 50662483!
createTankRover

	^ TankRover new! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:02' prior: 50663327 overrides: 16920235!
initialize
	
	weapons := OrderedCollection new.

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:07' prior: 50663334 overrides: 16920235!
initialize

	weapons := OrderedCollection new.
	
	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !
!Robot methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:42:47' prior: 50662557!
attack: aVictim with: aWeapon

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !

!methodRemoval: Robot #initializeType:life:speed:maxWeaponWeight: stamp: 'AS 5/6/2023 12:18:55'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:43:33' prior: 50662595!
removeWeapon: aWeapon 
	
	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:45:01' prior: 50663213!
totalWeaponWeight
	
	^weapons sum: [:weapon | weapon weight] ifEmpty: [0 * kilogram].
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:47:43' prior: 50663201!
totalSpeedImpact

	^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:49:44' prior: 50663410!
totalSpeedImpact

	"^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]"
	
	
	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:50:12' prior: 50663149 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 0 * kilometer / hour. "5"
	usedTimes := 0
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:50:41' prior: 50663417!
totalSpeedImpact

	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:53:44' prior: 50663428 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:55:10' prior: 50663050 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:56:35'!
attackedWithClaw
	
	life := life - (25 * year).! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:57:02'!
attackedWithClaw

	life := life - (5 * year).
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:59:47'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw stamp: 'AS 5/6/2023 12:18:55'!
attackedWithClaw
	
	life := life - (25 * year).!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:00:39' prior: 50663448 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:09:00' prior: 50663482 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker WithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:09:20'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw: stamp: 'AS 5/6/2023 12:18:56'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:10:18' prior: 50663514!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	anAttacker attackAluminum3000: self withClaw: aClaw	! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:12:46' prior: 50663526!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw isUsedBy: anAttacker againstAluminum3000: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:13:40'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:14:37' prior: 50663498 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:15:03'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (5 * year).
	
	aClaw isUsedBy: anAttacker againstTankRover: self
! !

!methodRemoval: TankRover #attackedWithClaw stamp: 'AS 5/6/2023 12:18:56'!
attackedWithClaw

	life := life - (5 * year).
!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:15:49'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:04' prior: 50663548 overrides: 50663044!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:21' prior: 50663581 overrides: 50663044!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:08'!
clawIsUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !

!methodRemoval: Claw #isUsedBy:againstAluminum3000: stamp: 'AS 5/6/2023 12:18:56'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:20'!
clawIsUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !

!methodRemoval: Claw #isUsedBy:againstTankRover: stamp: 'AS 5/6/2023 12:18:56'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 22:19:13' prior: 50663253 overrides: 50663044!
attack: aVictim by: anAttacker 	

	aVictim attackedBy: anAttacker withHSBlaster: self.
	
	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:19:46'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (25 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:20:14' prior: 50663648!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:21:11'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstTankRover: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50663597 overrides: 50663044!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:56'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:56'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:57'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:57'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:58'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:59'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:59'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:59'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:18:59'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:00'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50664412!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50664417!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50664422!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50664428!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:01'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:01'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:01'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:01'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50664412!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50664417!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50664422!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50664428!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:02'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:02'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50664584!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50664597!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50664603!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50664609!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50664615!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:02'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:02'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:02'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:02'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50664584!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50664597!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50664603!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50664609!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50664615!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:04' prior: 50664145!
totalPoints
		


	^(container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:25' prior: 50664768!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]).
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:46' prior: 50664775!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]) ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:55:13' prior: 50664783!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points] ifEmpty: [0]).
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:08'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:52' prior: 50664791!
totalPoints
		


	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:57:30' prior: 50664804!
totalPoints
		
	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:24'!
points
	
	self subclassResponsibility ! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:45' overrides: 50664817!
points
	
	^0! !

!methodRemoval: Backpack #portableObjectThatAddPoints stamp: 'AS 5/6/2023 12:19:03'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:59:25' prior: 50664811!
totalPoints
		
	^ container sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 23:00:16' prior: 50664157!
totalWeight
	
	^container sum: [:portableObject | portableObject weight] ifEmpty: [0]
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:01:33' prior: 50664183!
add: aPortableObject
	
	aPortableObject addTo: self.
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:03:06' overrides: 50664588!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack add: self.! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:04:30' prior: 50664859 overrides: 50664588!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addNoPointPortableObject: self.! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:05:17'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
! !
!PointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:06:51' overrides: 50664588!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPointsPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:07:42'!
addPortableObject: aPortableObject
	
	container add: aPortableObject.
! !

!methodRemoval: Backpack #addNoPointPortableObject: stamp: 'AS 5/6/2023 12:19:03'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
!
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:07:58' prior: 50664866 overrides: 50664588!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addPortableObject: self.! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:08:07' prior: 50664878 overrides: 50664588!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:08:31' prior: 50664843!
add: aPortableObject
	
	aPortableObject addTo: self.
! !

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:03'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:03' overrides: 50664317!
isOpen
	
	^false! !
!DoorKeyClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:13' overrides: 50664317!
isOpen
	
	^false! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:14:18' prior: 50664033!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:28' prior: 50663940!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:38' prior: 50663952!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:14:46' prior: 50664064!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !

!methodRemoval: Door class #closed stamp: 'AS 5/6/2023 12:19:03'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.!
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:15:26' prior: 50663926!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:15:35' prior: 50664021!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:15:43' prior: 50664076!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !

!methodRemoval: Door class #opened stamp: 'AS 5/6/2023 12:19:04'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.!
!DoorKeyClosed class methodsFor: 'no messages' stamp: 'AS 4/28/2023 23:17:32'!
with: aKey

	self initializeWith: aKey.
! !

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:04'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:17:58'!
initializeWith: aKey
	
	key := aKey! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:18:52' prior: 50664047!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:11' prior: 50663969!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:21' prior: 50663986!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:29' prior: 50664005!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:19:36' prior: 50664088!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!methodRemoval: Door class #closedWith: stamp: 'AS 5/6/2023 12:19:04'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.!
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:17' prior: 50664448!
isOpen

	^ state isOpen
! !
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:29' prior: 50665190!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:10:50' prior: 50664462 overrides: 50664412!
toBeClosedBy: aPlayableCharacter

	state close
! !
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/29/2023 15:11:28' overrides: 50664305!
close

	self error: Door alreadyClosedErrorDescription
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:11:43' overrides: 50664305!
close
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:12:29' prior: 50665210 overrides: 50664305!
close

	self error: Door alreadyClosedErrorDescription
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:31'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
! !

!methodRemoval: DoorKeyClosed #close stamp: 'AS 5/6/2023 12:19:04'!
close

	self error: Door alreadyClosedErrorDescription
!
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:46'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
	! !

!methodRemoval: DoorClosed #close stamp: 'AS 5/6/2023 12:19:04'!
close

	self error: Door alreadyClosedErrorDescription
	!
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:14:33'!
close

	state = DoorClosed new
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:15:42'!
toBeOpenedBy: aPlayableCharacter

	open: aDoor
! !
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:17'!
open: aDoor

	aDoor open
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:44'!
open: aDoor

	self error: Door closedWithKeyErrorDescription

! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:17:22'!
open

	state = DoorOpened new
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:20:13' prior: 50664500 overrides: 50664428!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:20:41'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50665265!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50665265!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!methodRemoval: DoorState #toBeUsedBy: stamp: 'AS 5/6/2023 12:19:05'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:00'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:44'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:38' prior: 50665316!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:44' prior: 50665311!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !

!methodRemoval: DoorClosed #toBeUsedBy: stamp: 'AS 5/6/2023 12:19:05'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!

!methodRemoval: DoorKeyClosed #toBeUsedBy: stamp: 'AS 5/6/2023 12:19:05'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:24:26'!
use: aDoor by: aPlayableCharacter

	self subclassResponsibility! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:24:53' prior: 50665260 overrides: 50664428!
toBeUsedBy: aPlayableCharacter

	state use: self by: aPlayableCharacter
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:27:15' prior: 50664486 overrides: 50664422!
toBeOpenedBy: aPlayableCharacter using: aKey

	state open: self by: aPlayableCharacter using: aKey
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:27:42'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key | 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:31' prior: 50665373!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50665388!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50665388!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !

!methodRemoval: DoorState #open:by:using: stamp: 'AS 5/6/2023 12:19:05'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:01' prior: 50665403!
open: aDoor by: aPlayableCharacter using: aKey

	self error: Door noNeedForAKeyErrorDescription! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:43' prior: 50665418!
open: aDoor by: aPlayableCharacter using: aKey

	(key == aKey) ifTrue: [ ^ aDoor open ].
	self error: Door notCorrectKeyErrorDescription. 
! !
!Door methodsFor: 'testing' stamp: 'AS 4/29/2023 15:30:39' prior: 50665194!
isOpen

	^ state class == DoorOpened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 16:03:09' prior: 50664474 overrides: 50664417!
toBeOpenedBy: aPlayableCharacter

	state openby: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:37'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50665469!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50665469!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !

!methodRemoval: DoorState #openby: stamp: 'AS 5/6/2023 12:19:05'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:10:57'!
open: aDoor by: aPlayableCharacter

	door open.! !

!methodRemoval: DoorClosed #openby: stamp: 'AS 5/6/2023 12:19:05'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:11:26'!
open: aDoor by: aPlayableCharacter

	self error: Door closedWithKeyErrorDescription.
! !

!classRemoval: #PointsPortableObject stamp: 'AS 5/6/2023 12:19:05'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/6/2023 12:19:06'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/6/2023 12:19:06'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/6/2023 12:19:06'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/6/2023 12:19:06'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/6/2023 12:19:06'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorKeyClosed stamp: 'AS 5/6/2023 12:19:06'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorClosed stamp: 'AS 5/6/2023 12:19:06'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/6/2023 12:19:07'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/6/2023 12:19:07'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/6/2023 12:19:07'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/6/2023 12:19:07'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:07'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:07'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:08'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:08'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:09'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:09'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:10'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:10'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:11'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:12'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:12'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50666315!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50666320!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50666325!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50666331!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:12'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:12'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50666315!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50666320!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50666325!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50666331!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50666487!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50666500!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50666506!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50666512!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50666518!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:13'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50666487!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50666500!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50666506!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50666512!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50666518!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:12'!
points

	self subclassResponsibility
! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:39' overrides: 50666671!
points
	
	^0! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:19:40' prior: 50666060!
totalWeight
	
	^container sum: [:portableObject | portableObject weight ] ifEmpty: [0]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:20:07' prior: 50666048!
totalPoints
		
	^container sum: [:portableObject | portableObject points ] ifEmpty: [0]! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/29/2023 16:23:40' prior: 50666086!
add: aPortableObject
	
	"aPortableObject addTo: self."
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50665630!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50665644!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50665658!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50665675!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50665694!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50665703!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50665712!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50665721!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50665730!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50665739!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50665748!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50665757!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50665772!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50665781!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50665796!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48' prior: 50665829!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18' prior: 50665843!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30' prior: 50665855!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44' prior: 50665872!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52' prior: 50665889!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03' prior: 50665908!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40' prior: 50665924!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/18/2020 12:37:04' prior: 50665936!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25' prior: 50665950!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39' prior: 50665967!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50' prior: 50665979!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01' prior: 50665991!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:14'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50666026!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50666031!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50666036!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50666045 overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50666686!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50666680!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50666070!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50666078!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50666692!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50666101!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50666115!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50666120!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50666125!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50666130!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50666135!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50666141!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50666146!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50666152!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50666158!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50666164!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50666170!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58' prior: 50666204!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:10:33' prior: 50666208!
close 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:10:45' prior: 50666212!
open 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:11:19' prior: 50666216!
openUsing: aKey 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 12:58:22'!
toBeUsedBy: aPlayableCharacter 

	self subclassResponsibility ! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24' prior: 50666220!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25' prior: 50666234!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!ClosedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:43' overrides: 50667359!
isOpen
	
	^ false! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:13:18' overrides: 50667341!
close 
	
	door error: Door alreadyClosedErrorDescription
	! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:33' overrides: 50667346!
open 
	
	door open! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:46' overrides: 50667350!
openUsing: aKey 
	
	door error: Door noNeedForAKeyErrorDescription! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:29' overrides: 50667354!
toBeUsedBy: aPlayableCharacter 
	
	door toBeOpenedBy: aPlayableCharacter ! !

!classDefinition: #KeyClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #KeyClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!KeyClosedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:58' overrides: 50667359!
isOpen
	
	^false! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:13:36' overrides: 50667341!
close 
	
	door error: Door alreadyClosedErrorDescription
! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:02' overrides: 50667346!
open 
	
	door error: Door closedWithKeyErrorDescription
! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:18' overrides: 50667350!
openUsing: aKey 
	
	door openUsing: aKey ! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:44' overrides: 50667354!
toBeUsedBy: aPlayableCharacter 
	
	door toBeOpenedBy: aPlayableCharacter ! !

!classDefinition: #OpenedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #OpenedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:15'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!OpenedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:30' overrides: 50667359!
isOpen
	
	^true! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:24' overrides: 50667341!
close 
	
	door close! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:29' overrides: 50667346!
open 
	
	door error: Door alreadyOpenedErrorDescription
	! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:43' overrides: 50667350!
openUsing: aKey 
	
	door error: Door alreadyOpenedErrorDescription! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:59' overrides: 50667354!
toBeUsedBy: aPlayableCharacter 
	
	door toBeClosedBy: aPlayableCharacter ! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08' prior: 50666256!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35' prior: 50666261!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42' prior: 50666266!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51' prior: 50666271!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29' prior: 50666276!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11' prior: 50666293!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07' prior: 50666315!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25' prior: 50666320!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51' prior: 50666325!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39' prior: 50666331!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:56:34' prior: 50666351!
isOpen

	^ state isOpen! !
!Door methodsFor: 'initialization' stamp: 'HAW 10/18/2020 12:56:34' prior: 50666355!
initializeWith: aDoorStateClass

	state := aDoorStateClass for: self.
	! !
!Door methodsFor: 'initialization' stamp: 'HAW 10/18/2020 12:56:18' prior: 50666359!
initializeWith: aDoorStateClass using: aKey

	self initializeWith: aDoorStateClass.
	key := aKey.
	! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:10:33' prior: 50666365 overrides: 50667581!
toBeClosedBy: aPlayableCharacter

	state close! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:10:45' prior: 50666377 overrides: 50667587!
toBeOpenedBy: aPlayableCharacter

	state open! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:11:19' prior: 50666389 overrides: 50667593!
toBeOpenedBy: aPlayableCharacter using: aKey

	state openUsing: aKey! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 12:56:34' prior: 50666403 overrides: 50667599!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter ! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:14:24'!
close 
	
	state := ClosedDoorState for: self. 
	! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:14:33'!
open 
	
	state := OpenedDoorState for: self.
	! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:15:18'!
openUsing: aKey 
	
	key = aKey ifTrue: [ ^state := OpenedDoorState for: self ].
	self error: Door notCorrectKeyErrorDescription. 
! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:10' prior: 50666423!
closed

	^self new initializeWith: ClosedDoorState ! !
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:28' prior: 50666429!
closedWith: aKey

	^self new initializeWith: KeyClosedDoorState using: aKey.
	! !
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:40' prior: 50666435!
opened

	^self new initializeWith: OpenedDoorState ! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28' prior: 50666440!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28' prior: 50666445!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06' prior: 50666450!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40' prior: 50666455!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32' prior: 50666460!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16' prior: 50666465!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50666487!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50666495!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' prior: 50666500 overrides: 50667581!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' prior: 50666506 overrides: 50667587!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' prior: 50666512 overrides: 50667593!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' prior: 50666518 overrides: 50667599!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50666541!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50666547 overrides: 50667747!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' prior: 50666552 overrides: 50667761!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' prior: 50666558 overrides: 50667768!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' prior: 50666564 overrides: 50667775!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' prior: 50666571 overrides: 50667782!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50667751!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50666588!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50666612 overrides: 50667747!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50666616!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50666623 overrides: 50666671!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' prior: 50666628 overrides: 50667761!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' prior: 50666634 overrides: 50667768!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' prior: 50666640 overrides: 50667775!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' prior: 50666647 overrides: 50667782!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50667751!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:16'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50666664!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'AS 5/6/2023 12:19:17'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/6/2023 12:19:17'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/6/2023 12:19:17'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/6/2023 12:19:17'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/6/2023 12:19:17'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/6/2023 12:19:17'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #OpenedDoorState stamp: 'AS 5/6/2023 12:19:18'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #KeyClosedDoorState stamp: 'AS 5/6/2023 12:19:18'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #ClosedDoorState stamp: 'AS 5/6/2023 12:19:18'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/6/2023 12:19:18'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/6/2023 12:19:18'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/6/2023 12:19:18'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/6/2023 12:19:18'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:19'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:19'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:20'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:20'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:21'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:21'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:21'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:21'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:22'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:22'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:22'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:22'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:22'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:22'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50668749!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50668754!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50668759!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50668765!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:23'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:24'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:24'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50668749!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50668754!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50668759!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50668765!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:24'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:24'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50668921!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50668934!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50668940!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50668946!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50668952!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:25'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:25'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:25'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:25'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50668921!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50668934!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50668940!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50668946!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50668952!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:25'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:25'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:25'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:25'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:41:38' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: #Gold.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: #Silver.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: #Normal! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:15:53'!
combo1

	^#Combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:21:01'!
combo2

	^#Combo2! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test02CanQuerySalesByCustomer

	| salesToAdaLovelace |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test03SalesAreDistinguishedByCustomer

	| salesToAdaLovelace salesToAlanKay |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]).

	salesToAlanKay := salesSystem salesMadeTo: alanKay.
	self assert: 1 equals: salesToAlanKay size.
	self assert: 1 equals: (salesToAlanKay  count: [ :aProduct | aProduct = self combo2 ])! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:41:51'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:19'!
test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:07'!
test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:41'!
test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:48:39'!
test08NoRewardExpectedWhenCustomerHasNotBuyAnything

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self failWith: 'No reward expected when customer has not buy anything'! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 1 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo2.
	self assert: 60*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	| alaKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alaKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 1 equals: alaKayReward quantity.
	self assert: alaKayReward isForCombo2.
	self assert: 120*3/4*peso equals: alaKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 1 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo2.
	self assert: 120*9/10*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 2 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo1.
	self assert: 75*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	| alanKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alanKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 2 equals: alanKayReward quantity.
	self assert: alanKayReward isForCombo1.
	self assert: 83*peso equals: alanKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 2 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo1.
	self assert: 97*peso equals: billGatesReward price.
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:26'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'type' stamp: 'HAW 9/21/2019 13:05:10'!
type

	^type! !
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/21/2019 13:00:45'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType ! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/21/2019 13:00:21'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo1
	
	^product = #Combo1! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo2
	
	^product = #Combo2! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:27'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'product volume' stamp: 'HAW 9/22/2019 19:51:19'!
volumeOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^250*milliliter ].
	aProduct = #Combo2 ifTrue: [ ^100*milliliter ].

	self error: 'Invalid product'
	! !
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:51:19'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | self volumeOf: aProduct ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:50:03' overrides: 16904184!
initialize

	Smalltalk at: #milliliter put: (BaseUnit named: 'milliliter')! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:03:50'!
createRewardFor: aCustomer 
	
	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'product price' stamp: 'HAW 9/22/2019 21:43:12'!
priceOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^150*peso ].
	aProduct = #Combo2 ifTrue: [ ^120*peso ].

	self error: 'Invalid combo type'! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50669563!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := 75*peso ].
	aCustomer type = #Silver ifTrue: [ price := 83*peso ].
	aCustomer type = #Normal ifTrue: [ price := 97*peso ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50669568!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:01:41' overrides: 50669572!
rewardedProduct
	
	^#Combo1! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50669593!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50669563!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := (self priceOf: product)/2 ].
	aCustomer type = #Silver ifTrue: [ price := (self priceOf: product)*3/4 ].
	aCustomer type = #Normal ifTrue: [ price := (self priceOf: product)*9/10 ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50669568!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:00:28' overrides: 50669572!
rewardedProduct
	
	^#Combo2! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:28'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50669593!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/6/2023 12:19:29'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/6/2023 12:19:29'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/6/2023 12:19:29'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/6/2023 12:19:29'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/6/2023 12:19:29'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/6/2023 12:19:29'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/6/2023 12:19:30'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:30'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:30'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:30:01' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopGoldCustomer named: 'Ada Lovelace'.
	alanKay := CoffeeShopSilverCustomer named: 'Alan Kay'.
	billGates := CoffeeShopNormalCustomer named: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/22/2019 21:21:44'!
combo1

	^CoffeeShopCombo1 new! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/22/2019 21:21:54'!
combo2

	^CoffeeShopCombo2 new! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/22/2019 21:30:20'!
initializeNamed: aName 

	name := aName.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:37:51'!
rewardPriceFor: aReward

	self subclassResponsibility ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 21:30:29'!
named: aName 

	^self new initializeNamed: aName ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50670043!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50670043!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:31'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50670043!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'comparing' stamp: 'HAW 9/22/2019 21:22:35' overrides: 16901772!
= anObject

	^self class = anObject class! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:38:21'!
price

	self subclassResponsibility ! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:38:27'!
volume

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopCombo1 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCombo1 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCombo1 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:21' overrides: 50670153!
price

	^150*peso! !
!CoffeeShopCombo1 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:57' overrides: 50670157!
volume

	^250*milliliter ! !

!classDefinition: #CoffeeShopCombo2 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCombo2 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCombo2 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:34' overrides: 50670153!
price

	^120*peso! !
!CoffeeShopCombo2 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:45' overrides: 50670157!
volume

	^100*milliliter ! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 21:24:59'!
isForCombo1
	
	^product class = CoffeeShopCombo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 21:25:07'!
isForCombo2
	
	^product class = CoffeeShopCombo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:32'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16904184!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:33'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50670366!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:23:58' overrides: 50670370!
rewardedProduct
	
	^CoffeeShopCombo1 new! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50670374!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50670378!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50670382!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:34'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:34'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50670396!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:34'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:34'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50670366!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:24:09' overrides: 50670370!
rewardedProduct
	
	^CoffeeShopCombo2 new! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50670374!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50670378!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50670382!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:34'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:34'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50670396!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/6/2023 12:19:34'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/6/2023 12:19:34'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/6/2023 12:19:34'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/6/2023 12:19:35'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/6/2023 12:19:35'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo2 stamp: 'AS 5/6/2023 12:19:35'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo1 stamp: 'AS 5/6/2023 12:19:35'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 5/6/2023 12:19:35'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 5/6/2023 12:19:35'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 5/6/2023 12:19:35'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 5/6/2023 12:19:36'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/6/2023 12:19:36'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/6/2023 12:19:36'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:36'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:36'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/23/2019 08:55:28' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopCustomer goldNamed: 'Ada Lovelace'.
	alanKay := CoffeeShopCustomer silverNamed: 'Alan Kay'.
	billGates := CoffeeShopCustomer normalNamed: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:18'!
combo1

	^CoffeeShopProduct combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:25'!
combo2

	^CoffeeShopProduct combo2 ! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:37'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:37'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:54:02'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:17'!
rewardPriceFor: aReward

	^type rewardPriceFor: aReward ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:09'!
goldNamed: aName 

	^self named: aName ofType: CoffeeShopGoldCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:44'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:28'!
normalNamed: aName 

	^self named: aName ofType: CoffeeShopNormalCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:18'!
silverNamed: aName 

	^self named: aName ofType: CoffeeShopSilverCustomer new! !

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomerType methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:32'!
rewardPriceFor: aCustomer

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50670948!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50670948!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50670948!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:19'!
price

	^price! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:27'!
volume

	^volume ! !
!CoffeeShopProduct methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:02:56'!
initializeOf: aVolume at: aPrice

	volume := aVolume.
	price := aPrice.
! !

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:38'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:40'!
combo1

	^combo1! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:46'!
combo2

	^combo2 ! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:29'!
of: aVolume at: aPrice 

	^self new initializeOf: aVolume at: aPrice 
! !
!CoffeeShopProduct class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:03:14' overrides: 16904184!
initialize

	combo1 := self of: 250*milliliter at: 150*peso.
	combo2 := self of: 100*milliliter at: 120*peso! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:00:41'!
isForCombo1
	
	^product = CoffeeShopProduct combo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:01:02'!
isForCombo2
	
	^product = CoffeeShopProduct combo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16904184!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:39'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50671241!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:00:06' overrides: 50671245!
rewardedProduct
	
	^CoffeeShopProduct combo1 ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50671249!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50671253!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50671257!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50671271!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:40'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50671241!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:01:14' overrides: 50671245!
rewardedProduct
	
	^CoffeeShopProduct combo2 ! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50671249!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50671253!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50671257!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:41'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:19:41'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50671271!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/6/2023 12:19:41'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/6/2023 12:19:41'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/6/2023 12:19:41'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/6/2023 12:19:41'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/6/2023 12:19:41'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 5/6/2023 12:19:42'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 5/6/2023 12:19:42'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 5/6/2023 12:19:42'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 5/6/2023 12:19:42'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'AS 5/6/2023 12:19:42'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/6/2023 12:19:42'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/6/2023 12:19:42'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:42'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:42'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54'!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:43'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:43'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:43'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:43'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:44'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:44'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36'!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28'!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03'!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07'!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16'!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:44'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:44'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11'!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:45'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:45'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:45'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:45'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:45'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:45'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:46'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:46'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50672005!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50672001!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:46'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:46'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50672005!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50672001!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:46'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:46'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25'!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39'!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54'!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48'!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39'!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21'!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:47'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:47'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:47'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:47'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38'!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17'!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09'!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:48'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:48'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !

!classRemoval: #TankRover stamp: 'AS 5/6/2023 12:19:49'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Aluminum3000 stamp: 'AS 5/6/2023 12:19:49'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #TurboLaserCannon stamp: 'AS 5/6/2023 12:19:49'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #HSBlaster stamp: 'AS 5/6/2023 12:19:49'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Claw stamp: 'AS 5/6/2023 12:19:49'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Weapon stamp: 'AS 5/6/2023 12:19:49'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #RobotWarsTest stamp: 'AS 5/6/2023 12:19:49'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Trailer stamp: 'AS 5/6/2023 12:19:50'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/6/2023 12:19:50'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/6/2023 12:19:50'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/6/2023 12:19:50'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/6/2023 12:19:50'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/6/2023 12:19:51'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54'!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:51'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:52'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:52'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:52'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:52'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36'!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28'!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03'!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07'!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16'!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:53'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:53'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11'!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:53'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:53'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:54'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:54'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:54'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:54'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:54'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:54'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50673037!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50673033!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:55'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:55'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50673037!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50673033!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:55'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:55'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25'!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39'!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54'!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48'!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39'!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21'!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:55'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:55'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:56'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:56'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38'!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17'!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09'!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:56'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:56'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:19:45' prior: 50673289!
totalProductsHeight

	^(container select: [ :product | product isStackable])
		sum: [ :product | product height ]
		ifEmpty: [0]

! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:41' prior: 50673301!
totalProductsWeight
	
	^container sum: [ :product | product weight ]
! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:56' prior: 50673446!
totalProductsWeight
	
	^container sum: [ :product | product weight ] ifEmpty: [0]
! !

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:57'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotStatusMechanicalFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:25:40'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:27:46' prior: 50673174!
closeOrderUsing: aCashier
	
	"status from: self closeOrderTo: aCashier"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:32:10'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:33:45'!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	| aTrailer |
	
	aRobot outOfOrder.
		
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	^ true
! !
!RobotStatusOutOfOrder methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:35:08'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusOutOfOrderFrom: aRobot
	! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:36:44' prior: 50673596!
from: aRobot closeOrderTo: aCashier
	
	aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:37:14'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:37:42'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusWorkingNormal methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:38:11'!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:38:45'!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	| aTrailer | 
	
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
	^ true
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:23' prior: 50673197!
outOfOrder

	status := RobotStatusOutOfOrder new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:37' prior: 50673201!
withMechanicalFailure

	status := RobotStatusMechanicalFailure new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:48' prior: 50673205!
withSensorsFailure

	status := RobotStatusSensorsFailure
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:40:10' prior: 50673558!
closeOrderUsing: aCashier
	
	status from: self closeOrderTo: aCashier.
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:41:38' prior: 50673186!
take: aProduct

	status take: aProduct into: trailer
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:43:37' prior: 50673656!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:46:01'!
take: aProduct into: trailer of: aRobot
	
	^trailer withMechanicalFailure carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:44'!
take: aProduct into: trailer of: aRobot
	
	^aRobot class signalOutOfOrder.! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:57' prior: 50673667!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:13'!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:20'!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/30/2023 14:48:46' prior: 50673215!
initializeWith: aTrailer

	trailer := aTrailer.
	status := RobotStatusWorkingNormal new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:49:01' prior: 50673646!
withSensorsFailure

	status := RobotStatusSensorsFailure new
! !

!methodRemoval: RobotStatusMechanicalFailure #closeOrderUsing: stamp: 'AS 5/6/2023 12:19:58'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"!
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:07' prior: 50673572!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:19' prior: 50673608!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:34' prior: 50673620!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:15' prior: 50673739!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:32' prior: 50673745!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:51:51'!
receiveOrderWithStatusSensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:51' prior: 50673764!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !

!methodRemoval: Cashier #receiveOrderWithStatusSeensorsFailureFrom: stamp: 'AS 5/6/2023 12:19:58'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
!
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:52:04' prior: 50673751!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:57:14' prior: 50672954!
receiveOrder: aRobot
	
	aRobot closeOrderUsing: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:59:54' prior: 50673757!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:12' prior: 50673603!
from: aRobot closeOrderTo: aCashier
	
	^aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:17' prior: 50673777!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:24' prior: 50673790!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 15:01:59' prior: 50673651!
closeOrderUsing: aCashier
	
	^status from: self closeOrderTo: aCashier.
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:07:39' prior: 50673587!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:08:02' prior: 50673626!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	self assertTrailerNotEmpty: aRobot trailer.	
	"Comentario: en este punto el cashier realizaría el checkout de los productos."		
	^ true
! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:12'!
from: aRobot closeOrderTo: aCashier
	
	self subclassResponsibility ! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:38'!
take: aProduct into: trailer of: aRobot

	self subclassResponsibility ! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:01:25'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:17' prior: 50673329!
assertHeightAdding: aProduct
	
	self execute: [ self signalMaxHeightCapacityExceeded ]
		If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:32'!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !

!methodRemoval: Trailer #execute:If:exceed: stamp: 'AS 5/6/2023 12:19:58'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
!
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:14' prior: 50673866!
assertHeightAdding: aProduct
	
	self If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	
		execute: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:55' prior: 50673885!
assertHeightAdding: aProduct
	
	self if: (self totalProductsHeight + aProduct height)
		 exceed: heightCapacity	
		 execute: [ self signalMaxHeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:04:22' prior: 50673336!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:58'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:58'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:19:58'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:06' overrides: 16961394!
setUp

	trailer := Trailer with: 20 and: 100.
	robot := Robot with: trailer.	
	cashier := Cashier new.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:55' prior: 50672533!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	self
		should: [ 
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:07:11' prior: 50672546!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	self
		should: [ 
			robot withMechanicalFailure.
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'AS 4/30/2023 16:07:28' prior: 50672561!
test03ShouldNotAcceptSensorsFailureRobot

	self
		should: [ 
			robot withSensorsFailure.
			cashier receiveOrder: robot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'AS 4/30/2023 16:07:55' prior: 50672575!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	self
		should: [ 
			robot take: (ProductA with: 1  and: 1).
			robot withMechanicalFailure.
			
			cashier receiveOrder: robot.
			
			robot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:11:47' prior: 50673834!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self halt.
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:13:52' prior: 50673661!
take: aProduct

	self halt.
	status take: aProduct into: trailer of: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:14:13' prior: 50673994!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:15:00' prior: 50673987!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:16:09' prior: 50673901!
assertWeightAdding: aProduct
	
	self halt.
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:17:09' prior: 50674011!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:18:21' prior: 50673874!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: [aBlock value].
! !

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:19:59'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:19:59'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10'!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48'!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38'!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23'!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58'!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57'!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51'!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11'!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31'!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17'!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02'!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15'!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40'!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05'!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04'!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09'!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35'!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16'!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15'!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25'!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36'!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46'!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52'!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:00'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:00'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:00'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:00'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19'!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30'!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38'!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43'!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48'!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54'!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03'!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34'!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10'!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19'!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01'!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49'!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10'!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14'!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:01'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:01'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34'!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48'!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46'!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38'!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53'!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24'!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12'!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:02'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50674608!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50674608!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' overrides: 50674608!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 5/6/2023 12:20:02'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50674682 overrides: 50674695!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50674686 overrides: 50674695!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50674690 overrides: 50674695!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50674568!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50674568!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' overrides: 50674568!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 5/6/2023 12:20:02'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50674712 overrides: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50674753 overrides: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50674794 overrides: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50674333!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50674337!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50674341!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 5/6/2023 12:20:03'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 5/6/2023 12:20:03'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50674948 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50674954 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50674960 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50674390!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50674409!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50674427!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50674421!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50674440!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50674453!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50674465!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 5/6/2023 12:20:03'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50674894 overrides: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50675066 overrides: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50674912 overrides: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #RobotWarsTest category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:10' prior: 50674050!
test01ShouldNotAddWeaponIfMaxWeaponWeightExceeded
	
	| robot addedWeapon |
	
	robot := self createAluminum3000.
	addedWeapon := self createTurboLaserCannon.
	robot addWeapon: addedWeapon.
	
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot maxWeaponWeightExceededErrorDescription.
		
	self assert: 1 equals: robot weaponsCount.
	self assert: (robot includesWeapon: addedWeapon)

	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:31:48' prior: 50674067!
test02ShouldNotAddWeaponIfSpeedBelowZero
	
	| robot firstAddedWeapon secondAddedWeapon |
	
	robot := self createTankRover.
	firstAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: firstAddedWeapon.
	secondAddedWeapon := self createTurboLaserCannon.
	robot addWeapon: secondAddedWeapon.
		
	self
		should: [ robot addWeapon: self createTurboLaserCannon ]
		raise: Error
		withMessageText: Robot speedBelowZeroErrorDescription .
		
	self assert: 2 equals: (robot weaponsCount).
	self assert: (robot includesWeapon: firstAddedWeapon).
	self assert: (robot includesWeapon: secondAddedWeapon)
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:38' prior: 50674089!
test03ShouldHaveZeroWeightWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilogram equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:23' prior: 50674097!
test04ShouldAddWeightWhenAddingWeapon
	
	| robot weapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.

	robot addWeapon: weapon.

	self assert: weapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 5/2/2021 15:49:58' prior: 50674107!
test05ShouldHaveZeroSpeedWhenNoWeaponsAdded
	
	| robot |
	
	robot := self createTankRover.

	self assert: 0 * kilometer / hour equals: robot totalSpeedImpact.
	
	

	! !
!RobotWarsTest methodsFor: 'robot creation tests' stamp: 'HAW 4/30/2021 17:32:57' prior: 50674115!
test06ShouldAddSpeedImpactWhenAddingWeapons

	| robot weapon anotherWeapon |
	
	robot := self createTankRover.
	weapon := self createTurboLaserCannon.
	anotherWeapon := self createClaw.

	robot addWeapon: weapon.
	robot addWeapon: anotherWeapon.

	self assert: weapon weight + anotherWeapon weight equals: robot totalWeaponWeight.
	
	

	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:51' prior: 50674129!
test07ClawReducesLifeOfAluminum3000By25

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (25 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:11' prior: 50674143!
test08ClawReducesLifeOfTankRoverBy5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:48:31' prior: 50674157!
test09HSBlasterReducesLifeOfAluminum3000By5

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (5 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:47:17' prior: 50674172!
test10HSBlasterReducesLifeOfTankRoverBy50

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (50 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:02' prior: 50674187!
test11TurboLaserCannonReducesLifeOfAluminum3000By100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'victim life after attacking tests' stamp: 'HAW 5/2/2021 15:49:15' prior: 50674202!
test12TurboLaserCannonReducesLifeOfTankRoverBy100

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: (100 * year) - (100 * year) equals: attacked life
	
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:41:40' prior: 50674217!
test13CanUseClawOnlyTwiceWhenAttackingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	2 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:42:05' prior: 50674236!
test14CanUseClawOnlyOnceWhenAttackingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createClaw.
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self 
		should: [ attacker attack: attacked with: attackerWeapon ]
		raise: Error
		withMessageText: Robot canNotAttackWithWeaponNotBelongingToRobotErrorDescription 
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:04' prior: 50674254!
test15AfterUsing5TimesHSBlasterAgainstAluminum3000RemovesItselfAndAddTurboLaserCannon
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createHSBlaster.
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #TurboLaserCannon).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:09' prior: 50674272!
test16AddsClawWhenAttakingTankRoverWithHSBlasterAndVictingLiveLessOrEqualTo50
	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createHSBlaster .
	attacker addWeapon: attackerWeapon.
	
	attacker attack: attacked with: attackerWeapon.
	
	self assert: 2 equals: attacker weaponsCount.
	self assert: (attacker includesWeapon: attackerWeapon).
	self assert: (attacker includesWeaponOfType: #Claw).
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 17:43:35' prior: 50674291!
test17CanUseOnlyTurboLaserCannon10TimesWhenAttakingAluminum3000

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createAluminum3000.
	attackerWeapon := self createTurboLaserCannon.
	attacker addWeapon: attackerWeapon.
	
	10 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 0 equals: attacker weaponsCount.
	! !
!RobotWarsTest methodsFor: 'weapon use after attacking tests' stamp: 'HAW 4/30/2021 19:38:16' prior: 50674307!
test18CanUseOnlyTurboLaserCannon10TimesWhenAttakingTankRover

	| attacker attacked attackerWeapon |
	
	attacker := self createAluminum3000.
	attacked := self createTankRover.
	attackerWeapon := self createTurboLaserCannon .
	attacker addWeapon: attackerWeapon.
	
	5 timesRepeat: [ attacker attack: attacked with: attackerWeapon ].
	
	self assert: 1 equals: attacker weaponsCount.
	self assert: (attacker includesWeaponOfType: #HSBlaster)
	! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:15' prior: 50674324!
createAluminum3000

	^ Robot ofType: #Aluminum3000 ! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'HAW 4/30/2021 19:37:25' prior: 50674329!
createTankRover

	^ Robot ofType: #TankRover ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:36' prior: 50674928!
createClaw

	^ Weapon ofType: #Claw ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:46' prior: 50674932!
createHSBlaster

	^ Weapon ofType: #HSBlaster ! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'HAW 4/30/2021 19:37:52' prior: 50674937!
createTurboLaserCannon

	^ Weapon ofType: #TurboLaserCannon ! !

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
RobotWarsTest class
	instanceVariableNames: ''!

!classDefinition: 'RobotWarsTest class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
RobotWarsTest class
	instanceVariableNames: ''!
!RobotWarsTest class methodsFor: 'class initialization' stamp: 'HAW 5/2/2021 15:40:59' prior: 50674357 overrides: 16904184!
initialize

	"Este método está para crear una unidad que falta, no lo deben tocar ni darle importancia durante 
	el parcial - Hernan"
	| kilogram |
	gram := BaseUnit named: 'gram' sign: 'g'.
	kilogram := ProportionalDerivedUnit baseUnit: gram conversionFactor: 1000  named: 'kilogram' sign: 'kg'.
	
	Smalltalk at: #kilogram put: kilogram
	! !

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Robot category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Object subclass: #Robot
	instanceVariableNames: 'type life speed maxWeaponWeight weapons'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'HAW 4/29/2021 17:46:19' prior: 50674387!
type

	^ type	! !
!Robot methodsFor: 'initialization' stamp: 'FRT 4/28/2021 15:36:58' prior: 50674999!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'attacking' stamp: 'HAW 4/30/2021 16:57:30' prior: 50674399!
attack: aVictim with: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:38' prior: 50675009!
addWeapon: aWeapon

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:43' prior: 50675026!
includesWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:48' prior: 50675020!
includesWeaponOfType: aWeaponType

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:56:54' prior: 50674434!
removeWeapon: aWeapon 
	
	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:03' prior: 50675031!
totalSpeedImpact

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'HAW 5/2/2021 15:51:34' prior: 50675043!
totalWeaponWeight

	| total index |

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'HAW 4/30/2021 16:57:10' prior: 50675053!
weaponsCount

	weapons isNil ifTrue: [ weapons := OrderedCollection new ].

	^ weapons size 	! !
!Robot methodsFor: 'life' stamp: 'FRT 4/28/2021 20:33:19' prior: 50674470!
life

	^ life! !
!Robot methodsFor: 'life' stamp: 'HAW 5/2/2021 15:52:01' prior: 50674473!
life: newLife

	life := newLife! !
!Robot methodsFor: 'exceptions' stamp: 'HAW 4/29/2021 20:49:49' prior: 50674477!
signalCanNotAttackWithWeaponNotBelongingToRobot
	
	self error: self class canNotAttackWithWeaponNotBelongingToRobotErrorDescription! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 16:02:10' prior: 50674484!
signalMaxWeaponWeightExceeded

	self error: self class maxWeaponWeightExceededErrorDescription 	! !
!Robot methodsFor: 'exceptions' stamp: 'FRT 4/28/2021 22:53:14' prior: 50674490!
signalSpeedBelowZero

	self error: self class speedBelowZeroErrorDescription 	! !

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'error description' stamp: 'HAW 4/29/2021 20:50:34' prior: 50674504!
canNotAttackWithWeaponNotBelongingToRobotErrorDescription
	
	^'Cannot attack with weapon not belonging to robot'! !
!Robot class methodsFor: 'error description' stamp: 'FRT 4/28/2021 16:04:48' prior: 50674511!
maxWeaponWeightExceededErrorDescription

	^ 'Maximum weapon weight has been exceeded'! !
!Robot class methodsFor: 'error description' stamp: 'HAW 5/2/2021 15:52:46' prior: 50674517!
speedBelowZeroErrorDescription

	^ 'Speed cannot be below zero kilometer per hour'! !
!Robot class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:43:10' prior: 50674523!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'! !

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Weapon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:38' prior: 50674554!
speedImpact
	
	^ speedImpact! !
!Weapon methodsFor: 'accesing' stamp: 'FRT 4/28/2021 22:43:53' prior: 50674557!
weight
	
	^ weight! !
!Weapon methodsFor: 'initialization' stamp: 'HAW 4/30/2021 17:03:09'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Weapon methodsFor: 'attacking' stamp: 'HAW 5/2/2021 15:46:43' prior: 50674874!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!Weapon methodsFor: 'type' stamp: 'HAW 4/30/2021 16:45:24' prior: 50674695!
type
	
	^type! !

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon class
	instanceVariableNames: ''!

!classDefinition: 'Weapon class' category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon class
	instanceVariableNames: ''!
!Weapon class methodsFor: 'instance creation' stamp: 'HAW 5/2/2021 15:44:12' prior: 50674620!
ofType: aWeaponType

	aWeaponType = #Claw ifTrue: [ ^self new 
		initializeType: aWeaponType weight: 10 * kilogram speedImpact: 5 * kilometer / hour ].
	aWeaponType = #HSBlaster ifTrue: [ ^ self new 
		initializeType: aWeaponType weight: 20 * kilogram speedImpact: 10 * kilometer / hour ].
	aWeaponType = #TurboLaserCannon ifTrue: [^ self new 
		initializeType: aWeaponType weight: 40 * kilogram speedImpact: 15 * kilometer / hour ].

	self error: 'Invalid Weapon Type'! !

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Claw category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #HSBlaster category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TurboLaserCannon category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:03'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50674700 overrides: 50675713!
type
	
	^type! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50674704 overrides: 50675713!
type
	
	^type! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:08' prior: 50674708 overrides: 50675713!
type
	
	^type! !

!methodRemoval: Weapon #type stamp: 'AS 5/6/2023 12:20:03'!
type
	
	^type!
!Weapon methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:25'!
type
	
	self subclassResponsibility ! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:36' prior: 50675789 overrides: 50675802!
type
	
	^#Claw! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:14:49' prior: 50675793 overrides: 50675802!
type
	
	^#HSBlaster! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:15:03' prior: 50675797 overrides: 50675802!
type
	
	^#TurboLaserCannon! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50674880 overrides: 50675673!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50675083 overrides: 50675673!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50675100 overrides: 50675673!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!methodRemoval: Weapon #attack:by: stamp: 'AS 5/6/2023 12:20:03'!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].!
!Weapon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:11'!
attack: aVictim by: anAttacker 	

	self subclassResponsibility ! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:40' prior: 50675819 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:16:58' prior: 50675860 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:17:15' prior: 50675902 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
	].
! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:45' prior: 50675426!
createClaw

	^ Claw new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:19:53' prior: 50675431!
createHSBlaster

	^ HSBlaster new! !
!RobotWarsTest methodsFor: 'weapon creation' stamp: 'AS 4/28/2023 14:20:03' prior: 50675436!
createTurboLaserCannon

	^ TurboLaserCannon new! !
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:20:47'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:18' prior: 50674979 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:22:56' prior: 50674986 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:23:27' prior: 50674993 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour! !

!methodRemoval: Weapon #initializeWeight:speedImpact: stamp: 'AS 5/6/2023 12:20:04'!
initializeWeight: aWeight speedImpact: aSpeedImpact 
	
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!Weapon methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:25:19' overrides: 16920235!
initialize

	usedTimes := 0.! !

!methodRemoval: Weapon #initialize stamp: 'AS 5/6/2023 12:20:04'!
initialize

	usedTimes := 0.!
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:09' prior: 50676056 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!HSBlaster methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:16' prior: 50676062 overrides: 16920235!
initialize

	weight := 20 * kilogram.
	speedImpact := 10 * kilometer / hour.
	usedTimes := 0
! !
!TurboLaserCannon methodsFor: 'type' stamp: 'AS 4/28/2023 14:26:31' prior: 50676068 overrides: 16920235!
initialize

	weight := 40 * kilogram.
	speedImpact := 15 * kilometer / hour.
	usedTimes := 0! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/28/2023 14:28:55' prior: 50675486!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:29:06' prior: 50675505!
addWeapon: aWeapon
	
	(self totalWeaponWeight + aWeapon weight) > maxWeaponWeight ifTrue: [ self signalMaxWeaponWeightExceeded ].
	
	(self totalSpeedImpact + aWeapon speedImpact) > speed ifTrue: [ self signalSpeedBelowZero ].
	
	weapons add: aWeapon.
	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:30:45' prior: 50675525!
includesWeaponOfType: aWeaponType

	^weapons anySatisfy: [ :weapon | weapon type = aWeaponType ]! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:39:50' prior: 50675518!
includesWeapon: aWeapon 
	
	^weapons includes: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:22' prior: 50675540!
totalSpeedImpact

	| total index |

	total := 0 * kilometer / hour.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		(weapon weight > (10 * kilogram)) ifTrue: [ total := total +  weapon speedImpact ].
		index := index + 1.	
	].

	^ total.! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:29' prior: 50675554!
totalWeaponWeight

	| total index |

	total := 0 * kilogram.
	index := 1.
	
	[index <= weapons size] whileTrue: [ | weapon |
		weapon := (weapons at: index).
		total := total + weapon weight.
		index := index + 1.	
	].

	^ total.	! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 14:40:35' prior: 50675566!
weaponsCount

	^ weapons size 	! !

!methodRemoval: Weapon #initializeType:weight:speedImpact: stamp: 'AS 5/6/2023 12:20:04'!
initializeType: aWeaponType weight: aWeight speedImpact: aSpeedImpact 
	
	type := aWeaponType.
	weight := aWeight.
	speedImpact := aSpeedImpact.
	usedTimes := 0.!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:16' prior: 50676002 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: (TurboLaserCannon new) ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Claw new) ].
	].
! !
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:13:48' prior: 50676174 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!TurboLaserCannon methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:16:57' prior: 50676020 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (100 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: HSBlaster new ]
	].
! !

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:04'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #Aluminum3000 category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:04'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:04'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classDefinition: #TankRover category: 'ISW1-2021-1C-1erParcial' stamp: 'AS 5/6/2023 12:20:04'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!
!Robot methodsFor: 'type' stamp: 'AS 4/28/2023 20:36:19' prior: 50675482!
type

	self subclassResponsibility 	! !
!Aluminum3000 methodsFor: 'nil' stamp: 'AS 4/28/2023 20:36:42' overrides: 50676253!
type
	
	^#Aluminum3000! !
!TankRover methodsFor: 'no messages' stamp: 'AS 4/28/2023 20:36:54' overrides: 50676253!
type
	
	^#TankRover! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:38:43' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:39:20' overrides: 16920235!
initialize

	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !

!methodRemoval: Robot class #ofType: stamp: 'AS 5/6/2023 12:20:04'!
ofType: aRobotType

	aRobotType = #Aluminum3000 ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 90 * kilometer / hour
		maxWeaponWeight: 50 * kilogram ].
	aRobotType = #TankRover ifTrue: [ ^ self new 
		initializeType: aRobotType 
		life: 100 * year
		speed: 40 * kilometer / hour
		maxWeaponWeight: 200 * kilogram ].

	self error: 'Invalid Robot Type'!
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:48' prior: 50675416!
createAluminum3000

	^ Aluminum3000 new! !
!RobotWarsTest methodsFor: 'robot creation' stamp: 'AS 4/28/2023 20:39:58' prior: 50675421!
createTankRover

	^ TankRover new! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:02' prior: 50676265 overrides: 16920235!
initialize
	
	weapons := OrderedCollection new.

	life := 100 * year.
	speed := 90 * kilometer / hour.
	maxWeaponWeight := 50 * kilogram
! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:41:07' prior: 50676272 overrides: 16920235!
initialize

	weapons := OrderedCollection new.
	
	life := 100 * year.
	speed := 40 * kilometer / hour.
	maxWeaponWeight := 200 * kilogram
	! !
!Robot methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:42:47' prior: 50675495!
attack: aVictim with: aWeapon

	(weapons includes: aWeapon) 
		ifTrue: [ aWeapon attack: aVictim by: self ]
		ifFalse: [ self signalCanNotAttackWithWeaponNotBelongingToRobot ]! !

!methodRemoval: Robot #initializeType:life:speed:maxWeaponWeight: stamp: 'AS 5/6/2023 12:20:04'!
initializeType: aRobotType life: lifePoints speed: aSpeed maxWeaponWeight: aMaxWeaponWeight

	weapons := OrderedCollection new.
	
	type := aRobotType.
	life := lifePoints.
	speed := aSpeed.
	maxWeaponWeight := aMaxWeaponWeight.

	!
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:43:33' prior: 50675533!
removeWeapon: aWeapon 
	
	weapons remove: aWeapon ! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:45:01' prior: 50676151!
totalWeaponWeight
	
	^weapons sum: [:weapon | weapon weight] ifEmpty: [0 * kilogram].
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:47:43' prior: 50676139!
totalSpeedImpact

	^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:49:44' prior: 50676348!
totalSpeedImpact

	"^weapons sum: [:weapon | (weapon weight > (10 * kilogram)) ifTrue: [weapon speedImpact]] ifEmpty: [0 * kilometer / hour]"
	
	
	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:50:12' prior: 50676087 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 0 * kilometer / hour. "5"
	usedTimes := 0
! !
!Robot methodsFor: 'weapons' stamp: 'AS 4/28/2023 20:50:41' prior: 50676355!
totalSpeedImpact

	^weapons sum: [:weapon | weapon speedImpact] ifEmpty: [0 * kilometer / hour]
! !
!Claw methodsFor: 'type' stamp: 'AS 4/28/2023 20:53:44' prior: 50676366 overrides: 16920235!
initialize

	weight := 10 * kilogram.
	speedImpact := 5 * kilometer / hour.
	usedTimes := 0
! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 20:55:10' prior: 50675988 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:56:35'!
attackedWithClaw
	
	life := life - (25 * year).! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:57:02'!
attackedWithClaw

	life := life - (5 * year).
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 20:59:47'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw stamp: 'AS 5/6/2023 12:20:04'!
attackedWithClaw
	
	life := life - (25 * year).!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:00:39' prior: 50676386 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedWithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:09:00' prior: 50676420 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker WithClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:09:20'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.! !

!methodRemoval: Aluminum3000 #attackedWithClaw: stamp: 'AS 5/6/2023 12:20:04'!
attackedWithClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw attackToAluminum3000: self.!
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:10:18' prior: 50676452!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	anAttacker attackAluminum3000: self withClaw: aClaw	! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:12:46' prior: 50676464!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (25 * year).
	
	aClaw isUsedBy: anAttacker againstAluminum3000: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:13:40'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:14:37' prior: 50676436 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 21:15:03'!
attackedBy: anAttacker withClaw: aClaw
	
	life := life - (5 * year).
	
	aClaw isUsedBy: anAttacker againstTankRover: self
! !

!methodRemoval: TankRover #attackedWithClaw stamp: 'AS 5/6/2023 12:20:04'!
attackedWithClaw

	life := life - (5 * year).
!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:15:49'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:04' prior: 50676486 overrides: 50675982!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.
	
	aVictim attackedWithClaw.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (25 * year).
		usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
	].
	
	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (5 * year).
		anAttacker removeWeapon: self.
	].

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:16:21' prior: 50676519 overrides: 50675982!
attack: aVictim by: anAttacker 	
	
	aVictim attackedBy: anAttacker withClaw: self.

! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:08'!
clawIsUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

! !

!methodRemoval: Claw #isUsedBy:againstAluminum3000: stamp: 'AS 5/6/2023 12:20:05'!
isUsedBy: anAttacker againstAluminum3000: anAluminum3000

	usedTimes := usedTimes + 1.
	usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].

!
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 21:17:20'!
clawIsUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

! !

!methodRemoval: Claw #isUsedBy:againstTankRover: stamp: 'AS 5/6/2023 12:20:05'!
isUsedBy: anAttacker againstTankRover: aTankRover

	usedTimes := usedTimes + 1.
	anAttacker removeWeapon: self

!
!HSBlaster methodsFor: 'attacking' stamp: 'AS 4/28/2023 22:19:13' prior: 50676191 overrides: 50675982!
attack: aVictim by: anAttacker 	

	aVictim attackedBy: anAttacker withHSBlaster: self.
	
	usedTimes := usedTimes + 1.
	aVictim type = #Aluminum3000 ifTrue: [
		aVictim life: aVictim life - (5 * year).
		usedTimes = 5 ifTrue: [ 
			anAttacker removeWeapon: self.
			anAttacker addWeapon: TurboLaserCannon new ].
	].

	aVictim type = #TankRover ifTrue: [
		aVictim life: aVictim life - (50 * year).
		aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: Claw new ].
	].
! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:19:46'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (25 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!Aluminum3000 methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:20:14' prior: 50676586!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstAluminum3000: self! !
!TankRover methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 22:21:11'!
attackedBy: anAttacker withHSBlaster: aHSBlaster
	
	life := life - (5 * year).
	
	aHSBlaster isUsedBy: anAttacker againstTankRover: self! !
!Claw methodsFor: 'attacking' stamp: 'AS 4/28/2023 14:15:51' prior: 50676535 overrides: 50675982!
attack: aVictim by: anAttacker 	

	usedTimes := usedTimes + 1.
	type = #Claw ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (25 * year).
			usedTimes = 2 ifTrue: [ anAttacker removeWeapon: self ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (5 * year).
			anAttacker removeWeapon: self.
		].
	
	].

	type = #HSBlaster ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (5 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #TurboLaserCannon) ].
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (50 * year).
			aVictim life <= (50 * year) ifTrue: [ anAttacker addWeapon: (Weapon ofType: #Claw) ].
		].
	].

	type = #TurboLaserCannon ifTrue: [
		aVictim type = #Aluminum3000 ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 10 ifTrue: [ anAttacker removeWeapon: self ]
		].
	
		aVictim type = #TankRover ifTrue: [
			aVictim life: aVictim life - (100 * year).
			usedTimes = 5 ifTrue: [ 
				anAttacker removeWeapon: self.
				anAttacker addWeapon: (Weapon ofType: #HSBlaster) ]
		].
	].! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22' prior: 50668064!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55' prior: 50668078!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57' prior: 50668092!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57' prior: 50668109!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50668128!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50668137!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50668146!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50668155!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50668164!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50668173!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50668182!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50668191!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50668206!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50668215!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50668230!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48' prior: 50668263!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18' prior: 50668277!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30' prior: 50668289!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44' prior: 50668306!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52' prior: 50668323!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03' prior: 50668342!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40' prior: 50668358!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16' prior: 50668370!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25' prior: 50668384!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39' prior: 50668401!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50' prior: 50668413!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01' prior: 50668425!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50668460!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50668465!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50668470!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50668479 overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37' prior: 50668482!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21' prior: 50668494!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50668504!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50668512!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12' prior: 50668520!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50668535!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50668549!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50668554!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50668559!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50668564!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50668569!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50668575!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50668580!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50668586!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50668592!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50668598!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50668604!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58' prior: 50668638!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14' prior: 50668642!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36' prior: 50668646!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48' prior: 50668650!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24' prior: 50668654!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25' prior: 50668668!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08' prior: 50668690!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35' prior: 50668695!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42' prior: 50668700!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51' prior: 50668705!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29' prior: 50668710!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11' prior: 50668727!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07' prior: 50668749!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25' prior: 50668754!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51' prior: 50668759!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39' prior: 50668765!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03' prior: 50668785!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44' prior: 50668789!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34' prior: 50668793!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' prior: 50668799 overrides: 50677380!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' prior: 50668811 overrides: 50677386!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' prior: 50668823 overrides: 50677392!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' prior: 50668837 overrides: 50677398!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27' prior: 50668857!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20' prior: 50668863!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52' prior: 50668869!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28' prior: 50668874!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28' prior: 50668879!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06' prior: 50668884!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40' prior: 50668889!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32' prior: 50668894!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16' prior: 50668899!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50668921!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17' prior: 50668925!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50668929!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' prior: 50668934 overrides: 50677380!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' prior: 50668940 overrides: 50677386!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' prior: 50668946 overrides: 50677392!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' prior: 50668952 overrides: 50677398!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50668975!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50668981 overrides: 50677561!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' prior: 50668986 overrides: 50677576!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' prior: 50668992 overrides: 50677583!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' prior: 50668998 overrides: 50677590!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' prior: 50669005 overrides: 50677597!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50669022!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50669046 overrides: 50677561!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50669050!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50669057!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' prior: 50669062 overrides: 50677576!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' prior: 50669068 overrides: 50677583!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' prior: 50669074 overrides: 50677590!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' prior: 50669081 overrides: 50677597!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:05'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50669098!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:04' prior: 50677103!
totalPoints
		


	^(container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:25' prior: 50677758!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]).
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:54:46' prior: 50677765!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points]) ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:55:13' prior: 50677773!
totalPoints
		


	^((container select: [:portableObject | portableObject doesItAddPoints]) sum: [:portableObject | portableObject points] ifEmpty: [0]).
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:08'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:56:52' prior: 50677781!
totalPoints
		


	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:57:30' prior: 50677794!
totalPoints
		
	^ (self portableObjectThatAddPoints) sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:24'!
points
	
	self subclassResponsibility ! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:58:45' overrides: 50677807!
points
	
	^0! !

!methodRemoval: Backpack #portableObjectThatAddPoints stamp: 'AS 5/6/2023 12:20:06'!
portableObjectThatAddPoints

	^container select: [:portableObject | portableObject doesItAddPoints]
!
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 22:59:25' prior: 50677801!
totalPoints
		
	^ container sum: [:portableObject | portableObject points] ifEmpty: [0].
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/28/2023 23:00:16' prior: 50677115!
totalWeight
	
	^container sum: [:portableObject | portableObject weight] ifEmpty: [0]
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:01:33' prior: 50677143!
add: aPortableObject
	
	aPortableObject addTo: self.
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!NoPointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:03:06' overrides: 50677566!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack add: self.! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:04:30' prior: 50677849 overrides: 50677566!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addNoPointPortableObject: self.! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:05:17'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
! !
!PointsPortableObject methodsFor: 'nil' stamp: 'AS 4/28/2023 23:06:51' overrides: 50677566!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPointsPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:07:42'!
addPortableObject: aPortableObject
	
	container add: aPortableObject.
! !

!methodRemoval: Backpack #addNoPointPortableObject: stamp: 'AS 5/6/2023 12:20:06'!
addNoPointPortableObject: aNoPointPortableObject
	
	container add: aNoPointPortableObject.
!
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:07:58' prior: 50677856 overrides: 50677566!
addTo: aBackpack

	aBackpack assertWeightAdding: self tolerating: 0.
	aBackpack addPortableObject: self.! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:08:07' prior: 50677868 overrides: 50677566!
addTo: aBackpack	
	
	aBackpack assertWeightAdding: self tolerating: 5.
	aBackpack assertPointsAdding: self.
		
	aBackpack addPortableObject: self.
! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/28/2023 23:08:31' prior: 50677833!
add: aPortableObject
	
	aPortableObject addTo: self.
! !

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorOpen category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:03' overrides: 50677284!
isOpen
	
	^false! !
!DoorKeyClosed methodsFor: 'nil' stamp: 'AS 4/28/2023 23:12:13' overrides: 50677284!
isOpen
	
	^false! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:14:18' prior: 50676985!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:28' prior: 50676889!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:14:38' prior: 50676901!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:14:46' prior: 50677017!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorClosed new.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !

!methodRemoval: Door class #closed stamp: 'AS 5/6/2023 12:20:06'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.!
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:15:26' prior: 50676875!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:15:35' prior: 50676973!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:15:43' prior: 50677029!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := DoorOpened new.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !

!methodRemoval: Door class #opened stamp: 'AS 5/6/2023 12:20:06'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.!
!DoorKeyClosed class methodsFor: 'no messages' stamp: 'AS 4/28/2023 23:17:32'!
with: aKey

	self initializeWith: aKey.
! !

!classDefinition: #DoorKeyClosed category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:06'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/28/2023 23:17:58'!
initializeWith: aKey
	
	key := aKey! !
!DoorTest methodsFor: 'closing' stamp: 'AS 4/28/2023 23:18:52' prior: 50676999!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:11' prior: 50676919!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:21' prior: 50676937!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'AS 4/28/2023 23:19:29' prior: 50676957!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'AS 4/28/2023 23:19:36' prior: 50677041!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := DoorKeyClosed with: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!methodRemoval: Door class #closedWith: stamp: 'AS 5/6/2023 12:20:06'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.!
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:17' prior: 50677419!
isOpen

	^ state isOpen
! !
!Door methodsFor: 'testing' stamp: 'AS 4/28/2023 23:20:29' prior: 50678180!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:10:50' prior: 50677435 overrides: 50677380!
toBeClosedBy: aPlayableCharacter

	state close
! !
!DoorClosed methodsFor: 'nil' stamp: 'AS 4/29/2023 15:11:28' overrides: 50677271!
close

	self error: Door alreadyClosedErrorDescription
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:11:43' overrides: 50677271!
close
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:12:29' prior: 50678200 overrides: 50677271!
close

	self error: Door alreadyClosedErrorDescription
! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:31'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
! !

!methodRemoval: DoorKeyClosed #close stamp: 'AS 5/6/2023 12:20:06'!
close

	self error: Door alreadyClosedErrorDescription
!
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:13:46'!
close: aDoor

	self error: Door alreadyClosedErrorDescription
	! !

!methodRemoval: DoorClosed #close stamp: 'AS 5/6/2023 12:20:07'!
close

	self error: Door alreadyClosedErrorDescription
	!
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:14:33'!
close

	state = DoorClosed new
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:15:42'!
toBeOpenedBy: aPlayableCharacter

	open: aDoor
! !
!DoorClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:17'!
open: aDoor

	aDoor open
	! !
!DoorKeyClosed methodsFor: 'as yet unclassified' stamp: 'AS 4/29/2023 15:16:44'!
open: aDoor

	self error: Door closedWithKeyErrorDescription

! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:17:22'!
open

	state = DoorOpened new
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:20:13' prior: 50677474 overrides: 50677398!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:20:41'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50678255!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:21:01' overrides: 50678255!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!methodRemoval: DoorState #toBeUsedBy: stamp: 'AS 5/6/2023 12:20:07'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:00'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:22:44'!
use: aDoor by: aPlayableCharacter

	aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:38' prior: 50678306!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:23:44' prior: 50678301!
use: aDoor by: aPlayableCharacter

	^aDoor toBeOpenedBy: aPlayableCharacter
! !

!methodRemoval: DoorClosed #toBeUsedBy: stamp: 'AS 5/6/2023 12:20:07'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!

!methodRemoval: DoorKeyClosed #toBeUsedBy: stamp: 'AS 5/6/2023 12:20:07'!
toBeUsedBy: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].!
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:24:26'!
use: aDoor by: aPlayableCharacter

	self subclassResponsibility! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:24:53' prior: 50678250 overrides: 50677398!
toBeUsedBy: aPlayableCharacter

	state use: self by: aPlayableCharacter
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 15:27:15' prior: 50677459 overrides: 50677392!
toBeOpenedBy: aPlayableCharacter using: aKey

	state open: self by: aPlayableCharacter using: aKey
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:27:42'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key | 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:31' prior: 50678363!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50678378!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:28:43' overrides: 50678378!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !

!methodRemoval: DoorState #open:by:using: stamp: 'AS 5/6/2023 12:20:07'!
open: aDoor by: aPlayableCharacter using: aKey

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ | key2 | 
		(key2 == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:01' prior: 50678393!
open: aDoor by: aPlayableCharacter using: aKey

	self error: Door noNeedForAKeyErrorDescription! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 15:29:43' prior: 50678408!
open: aDoor by: aPlayableCharacter using: aKey

	(key == aKey) ifTrue: [ ^ aDoor open ].
	self error: Door notCorrectKeyErrorDescription. 
! !
!Door methodsFor: 'testing' stamp: 'AS 4/29/2023 15:30:39' prior: 50678184!
isOpen

	^ state class == DoorOpened
! !
!Door methodsFor: 'playable character reactions' stamp: 'AS 4/29/2023 16:03:09' prior: 50677447 overrides: 50677386!
toBeOpenedBy: aPlayableCharacter

	state openby: aPlayableCharacter
! !
!DoorState methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:37'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50678459!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:03:49' overrides: 50678459!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !

!methodRemoval: DoorState #openby: stamp: 'AS 5/6/2023 12:20:08'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:10:57'!
open: aDoor by: aPlayableCharacter

	door open.! !

!methodRemoval: DoorClosed #openby: stamp: 'AS 5/6/2023 12:20:08'!
openby: aPlayableCharacter

	| state |
	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].!
!DoorKeyClosed methodsFor: 'door actions' stamp: 'AS 4/29/2023 16:11:26'!
open: aDoor by: aPlayableCharacter

	self error: Door closedWithKeyErrorDescription.
! !

!classRemoval: #PointsPortableObject stamp: 'AS 5/6/2023 12:20:08'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/6/2023 12:20:08'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/6/2023 12:20:08'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/6/2023 12:20:08'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/6/2023 12:20:09'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/6/2023 12:20:09'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorKeyClosed stamp: 'AS 5/6/2023 12:20:09'!
DoorState subclass: #DoorKeyClosed
	instanceVariableNames: 'key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorClosed stamp: 'AS 5/6/2023 12:20:09'!
DoorState subclass: #DoorClosed
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/6/2023 12:20:09'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/6/2023 12:20:09'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/6/2023 12:20:10'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/6/2023 12:20:10'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:10'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:10'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:11'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:11'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:12'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:12'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:12'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:12'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:13'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:13'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:13'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:13'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:13'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:13'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:14'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:14'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:14'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:14'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:14'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:14'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50679305!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50679310!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50679315!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50679321!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:15'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:15'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:15'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:15'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50679305!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50679310!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50679315!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50679321!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50679477!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50679490!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50679496!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50679502!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50679508!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50679477!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50679490!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50679496!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50679502!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50679508!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:16'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !
!PortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:12'!
points

	self subclassResponsibility
! !
!NoPointsPortableObject methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:18:39' overrides: 50679661!
points
	
	^0! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:19:40' prior: 50679050!
totalWeight
	
	^container sum: [:portableObject | portableObject weight ] ifEmpty: [0]
! !
!Backpack methodsFor: 'accessing' stamp: 'AS 4/29/2023 16:20:07' prior: 50679038!
totalPoints
		
	^container sum: [:portableObject | portableObject points ] ifEmpty: [0]! !
!Backpack methodsFor: 'adding' stamp: 'AS 4/29/2023 16:23:40' prior: 50679076!
add: aPortableObject
	
	"aPortableObject addTo: self."
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:29:03'!
assertShouldAddAll: portableObjects withPoints: expectedTotalPoints

	| aBackpack |
	
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	portableObjects do: [ :aPortableObject | aBackpack add: aPortableObject ].
	
	self assert: aBackpack size equals: portableObjects size.
	self assert: aBackpack totalWeight equals: (portableObjects sum: [ :aPortableObject | aPortableObject weight ]).
	self assert: aBackpack totalPoints equals: expectedTotalPoints.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
assertShouldNotAddPortableObjectIfWeightExceeded: aPortableObject

	| aBackpack |
	aBackpack := Backpack containingUpTo: self backpackWeight limitingPointsTo: 100.

	self
		should: [ aBackpack add: aPortableObject ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:32'!
backpackWeight

	^ 42! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:41' prior: 50678620!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(NoPointsPortableObject named: 'help-wanted sign' weighing: self backpackWeight + 1)
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:28:47' prior: 50678634!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	self assertShouldNotAddPortableObjectIfWeightExceeded: 
		(PointsPortableObject named: 'left-handed hammer' weighing: self backpackWeight + 6 worth: 5) ! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:26:42' prior: 50678648!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	self 
		assertShouldAddAll: self twoPortableObjects
		withPoints: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:27' prior: 50678665!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	self 
		assertShouldAddAll:  self twoPortableObjects, {(PointsPortableObject named: 'letter' weighing: 1 worth: 5)}
		withPoints: 10.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/18/2020 16:27:39'!
twoPortableObjects

	^ {
		(PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
		(NoPointsPortableObject named: 'help-wanted sign' weighing: 1) }! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50678684!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50678693!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50678702!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50678711!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50678720!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04' prior: 50678729!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20' prior: 50678738!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50678747!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31' prior: 50678762!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50678771!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57' prior: 50678786!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48' prior: 50678819!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18' prior: 50678833!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30' prior: 50678845!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44' prior: 50678862!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52' prior: 50678879!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03' prior: 50678898!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40' prior: 50678914!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/18/2020 12:37:04' prior: 50678926!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error - MessageNotUnderstood 
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25' prior: 50678940!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39' prior: 50678957!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50' prior: 50678969!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01' prior: 50678981!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29' prior: 50679016!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47' prior: 50679021!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56' prior: 50679026!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' prior: 50679035 overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:52' prior: 50679676!
totalPoints
		
	^(container select: [ :portableObject | portableObject doesItAddPoints ])	
		sum: [ :portableObject | portableObject points ]
		ifEmpty: [ 0 ]! !
!Backpack methodsFor: 'accessing' stamp: 'HAW 10/18/2020 12:20:20' prior: 50679670!
totalWeight
	
	^container 
		sum: [ :portableObject | portableObject weight ]
		ifEmpty: [ 0 ]
		! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36' prior: 50679060!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34' prior: 50679068!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24' prior: 50679682!
add: aPortableObject
	
	aPortableObject assertCanAddTo: self.
	
	container add: aPortableObject.
	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38' prior: 50679091!
isEmpty

	^ container isEmpty.! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:28:48'!
assertCanAddNoPointsPortableObject: aNoPointsPortableObject 
	
	self assertWeightAdding: aNoPointsPortableObject tolerating: 0.
	! !
!Backpack methodsFor: 'adding - private' stamp: 'HAW 10/18/2020 12:29:07'!
assertCanAddPointPortableObject: aPointsPortableObject 
	
	self assertWeightAdding: aPointsPortableObject tolerating: 5.
	self assertPointsAdding: aPointsPortableObject.
	! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33' prior: 50679105!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04' prior: 50679110!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29' prior: 50679115!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17' prior: 50679120!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00' prior: 50679125!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48' prior: 50679131!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16' prior: 50679136!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51' prior: 50679142!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06' prior: 50679148!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47' prior: 50679154!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56' prior: 50679160!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58' prior: 50679194!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:10:33' prior: 50679198!
close 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:10:45' prior: 50679202!
open 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:11:19' prior: 50679206!
openUsing: aKey 

	self subclassResponsibility ! !
!DoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 12:58:22'!
toBeUsedBy: aPlayableCharacter 

	self subclassResponsibility ! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24' prior: 50679210!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25' prior: 50679224!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #ClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:17'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!ClosedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:43' overrides: 50680349!
isOpen
	
	^ false! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:13:18' overrides: 50680331!
close 
	
	door error: Door alreadyClosedErrorDescription
	! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:33' overrides: 50680336!
open 
	
	door open! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:46' overrides: 50680340!
openUsing: aKey 
	
	door error: Door noNeedForAKeyErrorDescription! !
!ClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:29' overrides: 50680344!
toBeUsedBy: aPlayableCharacter 
	
	door toBeOpenedBy: aPlayableCharacter ! !

!classDefinition: #KeyClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #KeyClosedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!KeyClosedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:58' overrides: 50680349!
isOpen
	
	^false! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:13:36' overrides: 50680331!
close 
	
	door error: Door alreadyClosedErrorDescription
! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:02' overrides: 50680336!
open 
	
	door error: Door closedWithKeyErrorDescription
! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:18' overrides: 50680340!
openUsing: aKey 
	
	door openUsing: aKey ! !
!KeyClosedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:44' overrides: 50680344!
toBeUsedBy: aPlayableCharacter 
	
	door toBeOpenedBy: aPlayableCharacter ! !

!classDefinition: #OpenedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #OpenedDoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!OpenedDoorState methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:55:30' overrides: 50680349!
isOpen
	
	^true! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:14:24' overrides: 50680331!
close 
	
	door close! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:29' overrides: 50680336!
open 
	
	door error: Door alreadyOpenedErrorDescription
	! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 16:15:43' overrides: 50680340!
openUsing: aKey 
	
	door error: Door alreadyOpenedErrorDescription! !
!OpenedDoorState methodsFor: 'door actions' stamp: 'HAW 10/18/2020 15:55:59' overrides: 50680344!
toBeUsedBy: aPlayableCharacter 
	
	door toBeClosedBy: aPlayableCharacter ! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08' prior: 50679246!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35' prior: 50679251!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42' prior: 50679256!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51' prior: 50679261!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29' prior: 50679266!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11' prior: 50679283!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07' prior: 50679305!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25' prior: 50679310!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51' prior: 50679315!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39' prior: 50679321!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:18'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'HAW 10/18/2020 12:56:34' prior: 50679341!
isOpen

	^ state isOpen! !
!Door methodsFor: 'initialization' stamp: 'HAW 10/18/2020 12:56:34' prior: 50679345!
initializeWith: aDoorStateClass

	state := aDoorStateClass for: self.
	! !
!Door methodsFor: 'initialization' stamp: 'HAW 10/18/2020 12:56:18' prior: 50679349!
initializeWith: aDoorStateClass using: aKey

	self initializeWith: aDoorStateClass.
	key := aKey.
	! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:10:33' prior: 50679355 overrides: 50680571!
toBeClosedBy: aPlayableCharacter

	state close! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:10:45' prior: 50679367 overrides: 50680577!
toBeOpenedBy: aPlayableCharacter

	state open! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 16:11:19' prior: 50679379 overrides: 50680583!
toBeOpenedBy: aPlayableCharacter using: aKey

	state openUsing: aKey! !
!Door methodsFor: 'playable character reactions' stamp: 'HAW 10/18/2020 12:56:34' prior: 50679393 overrides: 50680589!
toBeUsedBy: aPlayableCharacter

	state toBeUsedBy: aPlayableCharacter ! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:14:24'!
close 
	
	state := ClosedDoorState for: self. 
	! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:14:33'!
open 
	
	state := OpenedDoorState for: self.
	! !
!Door methodsFor: 'reactions - private' stamp: 'HAW 10/18/2020 16:15:18'!
openUsing: aKey 
	
	key = aKey ifTrue: [ ^state := OpenedDoorState for: self ].
	self error: Door notCorrectKeyErrorDescription. 
! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:10' prior: 50679413!
closed

	^self new initializeWith: ClosedDoorState ! !
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:28' prior: 50679419!
closedWith: aKey

	^self new initializeWith: KeyClosedDoorState using: aKey.
	! !
!Door class methodsFor: 'instance creation' stamp: 'HAW 10/18/2020 12:52:40' prior: 50679425!
opened

	^self new initializeWith: OpenedDoorState ! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28' prior: 50679430!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28' prior: 50679435!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06' prior: 50679440!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40' prior: 50679445!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32' prior: 50679450!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16' prior: 50679455!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50679477!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'HAW 10/18/2020 12:28:24'!
assertCanAddTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51' prior: 50679485!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' prior: 50679490 overrides: 50680571!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' prior: 50679496 overrides: 50680577!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' prior: 50679502 overrides: 50680583!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' prior: 50679508 overrides: 50680589!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36' prior: 50679531!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50679537 overrides: 50680737!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' prior: 50679542 overrides: 50680751!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' prior: 50679548 overrides: 50680758!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' prior: 50679554 overrides: 50680765!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' prior: 50679561 overrides: 50680772!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2020 12:28:48' overrides: 50680741!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddNoPointsPortableObject: self! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36' prior: 50679578!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' prior: 50679602 overrides: 50680737!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26' prior: 50679606!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57' prior: 50679613 overrides: 50679661!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' prior: 50679618 overrides: 50680751!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' prior: 50679624 overrides: 50680758!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' prior: 50679630 overrides: 50680765!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' prior: 50679637 overrides: 50680772!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'as yet unclassified' stamp: 'HAW 10/18/2020 12:29:07' overrides: 50680741!
assertCanAddTo: aBackpack 
	
	^aBackpack assertCanAddPointPortableObject: self! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:19'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26' prior: 50679654!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classRemoval: #PointsPortableObject stamp: 'AS 5/6/2023 12:20:19'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/6/2023 12:20:19'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/6/2023 12:20:19'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/6/2023 12:20:20'!
StageObject subclass: #Door
	instanceVariableNames: 'key state'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/6/2023 12:20:20'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/6/2023 12:20:20'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #OpenedDoorState stamp: 'AS 5/6/2023 12:20:20'!
DoorState subclass: #OpenedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #KeyClosedDoorState stamp: 'AS 5/6/2023 12:20:20'!
DoorState subclass: #KeyClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #ClosedDoorState stamp: 'AS 5/6/2023 12:20:20'!
DoorState subclass: #ClosedDoorState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/6/2023 12:20:21'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/6/2023 12:20:21'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/6/2023 12:20:21'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/6/2023 12:20:21'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:21'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #BackpackTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:21'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:40:22'!
test07ShouldNotAddNoPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 42 + 1) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:36:55'!
test08ShouldNotAddPointsPortableObjectIfWeightExceeded

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self
		should: [ aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 42 + 6 worth: 5) ]
		raise: Error
		withMessageText: Backpack maxWeightExceededErrorDescription.
		
	self assert: aBackpack isEmpty. 
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test09ShouldAddPortableObjectsIfWeightUnderMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 41.
	self assert: aBackpack totalPoints equals: 5.
! !
!BackpackTest methodsFor: 'adding' stamp: 'HAW 10/14/2020 14:35:57'!
test10ShouldAddPortableObjectsIfWeightEqualsMaxWeightCapacity

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 40 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 1).
	aBackpack add: (PointsPortableObject named: 'letter' weighing: 1 worth: 5).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalWeight equals: 42.
	self assert: aBackpack totalPoints equals: 10.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test01CanNotCreateBackpackWithZeroMaxWeight

	self
		should: [ Backpack containingUpTo: 0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test02CanNotCreateBackpackWithNegativeMaxWeight

	self
		should: [ Backpack containingUpTo: -1 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack invalidWeightCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test03CanNotCreateBackpackWithZeroMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: 0 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test04CanNotCreateBackpackWithNegativeMaxPoints

	self
		should: [ Backpack containingUpTo: 10 limitingPointsTo: -1 ]
		raise: Error
		withMessageText: Backpack invalidPointsCapacityErrorDescription.! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test05CanNotCreateBackpackWithNoIntegerMaxWeight

	self
		should: [ Backpack containingUpTo: 1.0 limitingPointsTo: 100 ]
		raise: Error
		withMessageText: Backpack weightCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'creating' stamp: 'HAW 10/14/2020 14:31:04'!
test06CanNotCreateBackpackWithNoIntegerMaxPoints

	self
		should: [ Backpack containingUpTo: 100 limitingPointsTo: 1.0 ]
		raise: Error
		withMessageText: Backpack pointsCapacityMustBeIntegerErrorDescription.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:20'!
test11ShouldAddZeroWeightWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalWeight equals: 0.
	self assert: aBackpack isEmpty
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test12ShouldAddWeightWhenAddingPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalWeight equals: 20.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:49:31'!
test13ShouldAddZeroPointsWhenEmpty

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	self assert: aBackpack totalPoints equals: 0.
	self assert: aBackpack isEmpty.
! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test14ShouldAddPointsWhenAddingPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (PointsPortableObject named: 'car key' weighing: 10 worth: 20).
	
	self assert: aBackpack size equals: 2.
	self assert: aBackpack totalPoints equals: 25.

! !
!BackpackTest methodsFor: 'accessing' stamp: 'HAW 10/14/2020 14:35:57'!
test15ShouldNotAddPointsWhenAddingNoPointsPortableObjects

	| aBackpack |
	aBackpack := Backpack containingUpTo: 42 limitingPointsTo: 100.

	aBackpack add: (PointsPortableObject named: 'left-handed hammer' weighing: 10 worth: 5).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	aBackpack add: (NoPointsPortableObject named: 'help-wanted sign' weighing: 10).
	
	self assert: aBackpack size equals: 3.
	self assert: aBackpack totalPoints equals: 5.

! !

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:22'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorTest category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:22'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:43:48'!
test01ADoorOpenedCanNotBeOpenedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyOpenedErrorDescription.
		
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:18'!
test04ADoorClosedCanBeOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter.
	self assert: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:44:30'!
test05ADoorClosedCanNotBeOpenedWithAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: oldKey ]
		raise: Error
		withMessageText: Door noNeedForAKeyErrorDescription.
		
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:44'!
test07ADoorKeyClosedCanNotBeOpenedWithoutAKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:47:52'!
test08ADoorKeyClosedCanNotBeOpenWithAnyKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeOpenedBy: mainCharacter using: (PointsPortableObject named: 'car key' weighing: 2 worth: 1000) ]
		raise: Error
		withMessageText: Door notCorrectKeyErrorDescription.
		
	self deny: aDoor isOpen ! !
!DoorTest methodsFor: 'opening' stamp: 'HAW 10/14/2020 14:48:03'!
test09ADoorKeyClosedCanBeOpenWithTheCorrectKey
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self deny: aDoor isOpen.
	aDoor toBeOpenedBy: mainCharacter using: oldKey.
	self assert: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:43:40'!
test02ADoorOpenedCanBeClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeClosedBy: mainCharacter.
	self deny: aDoor isOpen.
	! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:16'!
test03ADoorClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'closing' stamp: 'HAW 10/14/2020 14:48:25'!
test06ADoorKeyClosedCanNotBeClosedAgain
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeClosedBy: mainCharacter ]
		raise: Error
		withMessageText: Door alreadyClosedErrorDescription.
		
	self deny: aDoor isOpen! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:39'!
test10WhenUsingADoorClosedGetsOpened
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door closed.
	
	self deny: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self assert: aDoor isOpen ! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:48:50'!
test11WhenUsingADoorOpenedGetsClosed
	
	| mainCharacter aDoor |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	aDoor := Door opened.
	
	self assert: aDoor isOpen.
	aDoor toBeUsedBy: mainCharacter.	
	self deny: aDoor isOpen.! !
!DoorTest methodsFor: 'using' stamp: 'HAW 10/14/2020 14:49:01'!
test12WhenUsingADoorKeyClosedCanNotBeOpened
	
	| mainCharacter aDoor oldKey |
	
	mainCharacter := PlayableCharacter named: 'Bernard' using: (Backpack containingUpTo: 100 limitingPointsTo: 100).
	oldKey := (PointsPortableObject named: 'old-rusty key' weighing: 2 worth: 1000).
	aDoor := Door closedWith: oldKey.
	
	self 
		should: [ aDoor toBeUsedBy: mainCharacter ]
		raise: Error
		withMessageText: Door closedWithKeyErrorDescription.
		
	self deny: aDoor isOpen! !

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:23'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Backpack category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:23'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:29'!
signalMaxPointsExceeded

	self error: self class maxPointsExceededErrorDescription ! !
!Backpack methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 18:02:47'!
signalMaxWeightExceeded

	self error: self class maxWeightExceededErrorDescription ! !
!Backpack methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:31:56'!
initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	weightCapacity := aWeightCapacity.
	gamePointsCapacity := pointsCapacity.
	
	container := OrderedCollection new.
	
	
	! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:14:47' overrides: 16901663!
size

	^ container size.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 13:59:37'!
totalPoints
		
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		(portableObject doesItAddPoints) ifTrue: [ total := total +  portableObject points ].
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'accessing' stamp: 'FRT 10/12/2020 14:00:21'!
totalWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | portableObject |
		portableObject := (container at: index).
		total := total + portableObject weight.
		index := index + 1.	
	].

	^ total.! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/12/2020 14:12:36'!
assertPointsAdding: aPointsPortableObject

	(self totalPoints + aPointsPortableObject points) > gamePointsCapacity ifTrue: [ self signalMaxPointsExceeded ]! !
!Backpack methodsFor: 'assertions' stamp: 'FRT 10/15/2020 12:22:34'!
assertWeightAdding: aPortableObject tolerating: aThreshold

	(self totalWeight + aPortableObject weight - weightCapacity) > aThreshold ifTrue: [ self signalMaxWeightExceeded ]! !
!Backpack methodsFor: 'adding' stamp: 'FRT 10/15/2020 12:21:12'!
add: aPortableObject
	
	(aPortableObject isKindOf: NoPointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 0.
		container add: aPortableObject.
	].

	(aPortableObject isKindOf: PointsPortableObject) ifTrue: [
		self assertWeightAdding: aPortableObject tolerating: 5.
		self assertPointsAdding: aPortableObject.
		container add: aPortableObject.
	].	! !
!Backpack methodsFor: 'testing' stamp: 'FRT 10/11/2020 18:38:38'!
isEmpty

	^ container isEmpty.! !

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:24'!
Backpack class
	instanceVariableNames: ''!

!classDefinition: 'Backpack class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:24'!
Backpack class
	instanceVariableNames: ''!
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:27:33'!
invalidPointsCapacityErrorDescription

	^ 'Points capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 18:21:04'!
invalidWeightCapacityErrorDescription

	^ 'Weight capacity must be positive'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:29'!
maxPointsExceededErrorDescription

	^ 'Maximum points has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:36:17'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:43:00'!
pointsCapacityMustBeIntegerErrorDescription

	^ 'Points capacity must be integer'! !
!Backpack class methodsFor: 'error messages' stamp: 'FRT 10/8/2020 17:42:48'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:27:16'!
signalInvalidPointsCapacity

	self error: self invalidPointsCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/11/2020 18:21:51'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription 
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:41:06'!
signalPointsCapacityMustBeInteger

	self error: self pointsCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'exceptions' stamp: 'FRT 10/8/2020 17:40:47'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Backpack class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:31:56'!
containingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity

	aWeightCapacity strictlyPositive  ifFalse: [ self signalInvalidWeightCapacity ].
	pointsCapacity strictlyPositive ifFalse: [ self signalInvalidPointsCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	pointsCapacity isInteger ifFalse: [ self signalPointsCapacityMustBeInteger ].
	
	^ self new initializeContainingUpTo: aWeightCapacity limitingPointsTo: pointsCapacity.
! !

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:24'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #DoorState category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:24'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!DoorState methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:26:58'!
initializeFor: aDoor

	door := aDoor! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:14'!
close

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:36'!
open

	self subclassResponsibility! !
!DoorState methodsFor: 'door actions' stamp: 'FRT 10/13/2020 14:47:48'!
openUsing: aKey

	self subclassResponsibility! !
!DoorState methodsFor: 'testing' stamp: 'FRT 10/13/2020 14:47:24'!
isOpen

	self subclassResponsibility! !

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
DoorState class
	instanceVariableNames: ''!

!classDefinition: 'DoorState class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
DoorState class
	instanceVariableNames: ''!
!DoorState class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:25:25'!
for: aDoor

	^ self new initializeFor: aDoor! !

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PlayableCharacter category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:08'!
close: aStageObject

	aStageObject toBeClosedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:35'!
open: aStageObject

	aStageObject toBeOpenedBy: self.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 23:00:42'!
take: aPortableObject

	backpack add: aPortableObject.! !
!PlayableCharacter methodsFor: 'actions' stamp: 'FRT 10/14/2020 22:59:51'!
use: aStageObject

	aStageObject toBeUsedBy: self.! !
!PlayableCharacter methodsFor: 'initialization' stamp: 'FRT 10/8/2020 19:44:29'!
initializeNamed: aName using: aBackpack

	name := aName.
	backpack := aBackpack.! !

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
PlayableCharacter class
	instanceVariableNames: ''!

!classDefinition: 'PlayableCharacter class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
PlayableCharacter class
	instanceVariableNames: ''!
!PlayableCharacter class methodsFor: 'instance creation' stamp: 'FRT 10/8/2020 19:43:11'!
named: aName using: aBackpack

	^ self new initializeNamed: aName using: aBackpack! !

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #StageObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:25'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:07'!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:25'!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:51'!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!StageObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:23:39'!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:26'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #Door category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:26'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!Door methodsFor: 'testing' stamp: 'FRT 10/12/2020 00:34:03'!
isOpen

	^ state == #Opened
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:28:44'!
initializeWith: aDoorState

	state := aDoorState
! !
!Door methodsFor: 'initialization' stamp: 'FRT 10/13/2020 14:30:34'!
initializeWith: aDoorState using: aKey

	state := aDoorState.
	key := aKey.
! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:11' overrides: 50681739!
toBeClosedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ state := #Closed ].
	(state == #Closed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].
	(state == #KeyClosed) ifTrue: [ self error: Door alreadyClosedErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:23' overrides: 50681744!
toBeOpenedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ ^ state := #Opened ].
	(state == #KeyClosed) ifTrue: [ self error: Door closedWithKeyErrorDescription ].! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:38' overrides: 50681749!
toBeOpenedBy: aPlayableCharacter using: aKey

	(state == #Opened) ifTrue: [ self error: Door alreadyOpenedErrorDescription ].
	(state == #Closed) ifTrue: [ self error: Door noNeedForAKeyErrorDescription ].
	(state == #KeyClosed) ifTrue: [ 
		(key == aKey) ifTrue: [ ^ state := #Opened ].
		self error: Door notCorrectKeyErrorDescription. 
	]! !
!Door methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:24:50' overrides: 50681755!
toBeUsedBy: aPlayableCharacter

	(state == #Opened) ifTrue: [ ^ self toBeClosedBy: aPlayableCharacter ].
	(state == #Closed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].
	(state == #KeyClosed) ifTrue: [ ^ self toBeOpenedBy: aPlayableCharacter ].! !

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:26'!
Door class
	instanceVariableNames: ''!

!classDefinition: 'Door class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:26'!
Door class
	instanceVariableNames: ''!
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:27'!
closed

	| door |
	
	door := Door new.
	door initializeWith: #Closed.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:31:20'!
closedWith: aKey

	| door |
	
	door := Door new.
	door initializeWith: #KeyClosed using: aKey.
	
	^ door.! !
!Door class methodsFor: 'instance creation' stamp: 'FRT 10/13/2020 14:29:52'!
opened

	| door |
	
	door := Door new.
	door initializeWith: #Opened.
	
	^ door.! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:28'!
alreadyClosedErrorDescription

	^ 'The door is already closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 20:15:28'!
alreadyOpenedErrorDescription

	^ 'The door is already opened'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:15:06'!
closedWithKeyErrorDescription

	^ 'The door is closed with key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 19:50:40'!
keyClosedErrorDescription

	^ 'The door is closed with a key'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:26:32'!
noNeedForAKeyErrorDescription

	^ 'The door is not key-closed'! !
!Door class methodsFor: 'error messages' stamp: 'FRT 10/11/2020 22:31:16'!
notCorrectKeyErrorDescription

	^ 'Not the correct key!!'! !

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20'!
doesItAddPoints

	self subclassResponsibility	! !
!PortableObject methodsFor: 'adding' stamp: 'FRT 10/8/2020 18:38:17'!
addTo: aBackpack

	self subclassResponsibility	! !
!PortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 18:53:51'!
weight

	^ weight! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:01' overrides: 50681739!
toBeClosedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:14' overrides: 50681744!
toBeOpenedBy: aPlayableCharacter

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:27' overrides: 50681749!
toBeOpenedBy: aPlayableCharacter using: aKey

	self subclassResponsibility! !
!PortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:39' overrides: 50681755!
toBeUsedBy: aPlayableCharacter

	self subclassResponsibility! !

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #NoPointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!NoPointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:34:36'!
initializeNamed: aName weighing: aWeight
	
	name := aName.
	weight := aWeight.! !
!NoPointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50681911!
doesItAddPoints	

	^ false! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:27:59' overrides: 50681924!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:14' overrides: 50681930!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:24' overrides: 50681936!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!NoPointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:34' overrides: 50681942!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
NoPointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'NoPointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
NoPointsPortableObject class
	instanceVariableNames: ''!
!NoPointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:34:36'!
named: aName weighing: aWeight
	
	^ self new initializeNamed: aName weighing: aWeight. ! !

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #PointsPortableObject category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:27'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!
!PointsPortableObject methodsFor: 'testing' stamp: 'FRT 10/11/2020 17:54:20' overrides: 50681911!
doesItAddPoints

	^ true! !
!PointsPortableObject methodsFor: 'initialization' stamp: 'HAW 10/14/2020 14:36:26'!
initializeNamed: aName weighing: aWeight worth: gamePoints
	
	name := aName.
	weight := aWeight.
	points := gamePoints.! !
!PointsPortableObject methodsFor: 'accessing' stamp: 'FRT 10/11/2020 19:06:57'!
points

	^ points! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:49' overrides: 50681924!
toBeClosedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:28:59' overrides: 50681930!
toBeOpenedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:14' overrides: 50681936!
toBeOpenedBy: aPlayableCharacter using: aKey

	"No implementado en 1er Parcial"! !
!PointsPortableObject methodsFor: 'playable character reactions' stamp: 'FRT 10/12/2020 23:29:25' overrides: 50681942!
toBeUsedBy: aPlayableCharacter

	"No implementado en 1er Parcial"! !

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:28'!
PointsPortableObject class
	instanceVariableNames: ''!

!classDefinition: 'PointsPortableObject class' category: 'ISW1-2020-2C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:28'!
PointsPortableObject class
	instanceVariableNames: ''!
!PointsPortableObject class methodsFor: 'instance creation' stamp: 'HAW 10/14/2020 14:36:26'!
named: aName weighing: aWeight worth: gamePoints
	
	^ self new initializeNamed: aName weighing: aWeight worth: gamePoints.! !

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:28'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:28'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:41:38' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopCustomer named: 'Ada Lovelace' ofType: #Gold.
	alanKay := CoffeeShopCustomer named: 'Alan Kay' ofType: #Silver.
	billGates := CoffeeShopCustomer named: 'Bill Gates' ofType: #Normal! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:15:53'!
combo1

	^#Combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/20/2019 17:21:01'!
combo2

	^#Combo2! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test02CanQuerySalesByCustomer

	| salesToAdaLovelace |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	
	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ])! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:41:51'!
test03SalesAreDistinguishedByCustomer

	| salesToAdaLovelace salesToAlanKay |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	salesToAdaLovelace := salesSystem salesMadeTo: adaLovelace.
	self assert: 1 equals: salesToAdaLovelace size.
	self assert: 1 equals: (salesToAdaLovelace count: [ :aProduct | aProduct = self combo1 ]).

	salesToAlanKay := salesSystem salesMadeTo: alanKay.
	self assert: 1 equals: salesToAlanKay size.
	self assert: 1 equals: (salesToAlanKay  count: [ :aProduct | aProduct = self combo2 ])! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:41:51'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:19'!
test05VolumeIs_250_WhenOnlyCombo1WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:07'!
test06VolumeIs_100_WhenOnlyCombo2WasSoldToCustomer

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:46:41'!
test07VolumeSoldToCustomerIsTheSumOfAllSoldProducts

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:48:39'!
test08NoRewardExpectedWhenCustomerHasNotBuyAnything

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self failWith: 'No reward expected when customer has not buy anything'! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 1 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo2.
	self assert: 60*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	| alaKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alaKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 1 equals: alaKayReward quantity.
	self assert: alaKayReward isForCombo2.
	self assert: 120*3/4*peso equals: alaKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 1 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo2.
	self assert: 120*9/10*peso equals: billGatesReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	| adaLovelaceReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	adaLovelaceReward := salesSystem rewardOf: adaLovelace ifNone: [ self fail ].

	self assert: 2 equals: adaLovelaceReward quantity.
	self assert: adaLovelaceReward isForCombo1.
	self assert: 75*peso equals: adaLovelaceReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	| alanKayReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	alanKayReward := salesSystem rewardOf: alanKay ifNone: [ self fail ].

	self assert: 2 equals: alanKayReward quantity.
	self assert: alanKayReward isForCombo1.
	self assert: 83*peso equals: alanKayReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:41:51'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	| billGatesReward |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo1.
	salesSystem registerSaleTo: billGates of: self combo2.

	billGatesReward := salesSystem rewardOf: billGates ifNone: [ self fail ].

	self assert: 2 equals: billGatesReward quantity.
	self assert: billGatesReward isForCombo1.
	self assert: 97*peso equals: billGatesReward price.
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:29'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:29'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'type' stamp: 'HAW 9/21/2019 13:05:10'!
type

	^type! !
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/21/2019 13:00:45'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType ! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:29'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:29'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/21/2019 13:00:21'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:29'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:29'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo1
	
	^product = #Combo1! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:07:57'!
isForCombo2
	
	^product = #Combo2! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'product volume' stamp: 'HAW 9/22/2019 19:51:19'!
volumeOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^250*milliliter ].
	aProduct = #Combo2 ifTrue: [ ^100*milliliter ].

	self error: 'Invalid product'
	! !
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:51:19'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | self volumeOf: aProduct ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:50:03' overrides: 16904184!
initialize

	Smalltalk at: #milliliter put: (BaseUnit named: 'milliliter')! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:03:50'!
createRewardFor: aCustomer 
	
	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'product price' stamp: 'HAW 9/22/2019 21:43:12'!
priceOf: aProduct

	aProduct = #Combo1 ifTrue: [ ^150*peso ].
	aProduct = #Combo2 ifTrue: [ ^120*peso ].

	self error: 'Invalid combo type'! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:30'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50682553!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := 75*peso ].
	aCustomer type = #Silver ifTrue: [ price := 83*peso ].
	aCustomer type = #Normal ifTrue: [ price := 97*peso ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50682558!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:01:41' overrides: 50682562!
rewardedProduct
	
	^#Combo1! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50682583!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:41:45' overrides: 50682553!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	
	aCustomer type = #Gold ifTrue: [ price := (self priceOf: product)/2 ].
	aCustomer type = #Silver ifTrue: [ price := (self priceOf: product)*3/4 ].
	aCustomer type = #Normal ifTrue: [ price := (self priceOf: product)*9/10 ].
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50682558!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:00:28' overrides: 50682562!
rewardedProduct
	
	^#Combo2! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:31'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50682583!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/6/2023 12:20:31'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/6/2023 12:20:31'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/6/2023 12:20:32'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/6/2023 12:20:32'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/6/2023 12:20:32'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/6/2023 12:20:32'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/6/2023 12:20:32'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:32'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:32'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/22/2019 21:30:01' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopGoldCustomer named: 'Ada Lovelace'.
	alanKay := CoffeeShopSilverCustomer named: 'Alan Kay'.
	billGates := CoffeeShopNormalCustomer named: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/22/2019 21:21:44'!
combo1

	^CoffeeShopCombo1 new! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/22/2019 21:21:54'!
combo2

	^CoffeeShopCombo2 new! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/22/2019 21:30:20'!
initializeNamed: aName 

	name := aName.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:37:51'!
rewardPriceFor: aReward

	self subclassResponsibility ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 21:30:29'!
named: aName 

	^self new initializeNamed: aName ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50683033!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50683033!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50683033!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'comparing' stamp: 'HAW 9/22/2019 21:22:35' overrides: 16901772!
= anObject

	^self class = anObject class! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:38:21'!
price

	self subclassResponsibility ! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:38:27'!
volume

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopCombo1 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCombo1 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:34'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCombo1 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:21' overrides: 50683143!
price

	^150*peso! !
!CoffeeShopCombo1 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:57' overrides: 50683147!
volume

	^250*milliliter ! !

!classDefinition: #CoffeeShopCombo2 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCombo2 category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCombo2 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:34' overrides: 50683143!
price

	^120*peso! !
!CoffeeShopCombo2 methodsFor: 'price/volume' stamp: 'HAW 9/22/2019 21:20:45' overrides: 50683147!
volume

	^100*milliliter ! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 21:24:59'!
isForCombo1
	
	^product class = CoffeeShopCombo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/22/2019 21:25:07'!
isForCombo2
	
	^product class = CoffeeShopCombo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16904184!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:35'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50683356!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:23:58' overrides: 50683360!
rewardedProduct
	
	^CoffeeShopCombo1 new! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50683364!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50683368!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50683372!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50683386!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:36'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50683356!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:24:09' overrides: 50683360!
rewardedProduct
	
	^CoffeeShopCombo2 new! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50683364!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50683368!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50683372!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:37'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:37'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50683386!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/6/2023 12:20:37'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/6/2023 12:20:37'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/6/2023 12:20:37'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/6/2023 12:20:37'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/6/2023 12:20:37'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo2 stamp: 'AS 5/6/2023 12:20:38'!
CoffeeShopProduct subclass: #CoffeeShopCombo2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCombo1 stamp: 'AS 5/6/2023 12:20:38'!
CoffeeShopProduct subclass: #CoffeeShopCombo1
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 5/6/2023 12:20:38'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 5/6/2023 12:20:38'!
CoffeeShopCustomer subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 5/6/2023 12:20:38'!
CoffeeShopCustomer subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 5/6/2023 12:20:38'!
CoffeeShopCustomer subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/6/2023 12:20:38'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/6/2023 12:20:39'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:39'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopTest category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:39'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopTest methodsFor: 'setUp/tearDown' stamp: 'HAW 9/23/2019 08:55:28' overrides: 16961394!
setUp

	adaLovelace := CoffeeShopCustomer goldNamed: 'Ada Lovelace'.
	alanKay := CoffeeShopCustomer silverNamed: 'Alan Kay'.
	billGates := CoffeeShopCustomer normalNamed: 'Bill Gates'! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:18'!
combo1

	^CoffeeShopProduct combo1! !
!CoffeeShopTest methodsFor: 'test objects' stamp: 'HAW 9/23/2019 08:59:25'!
combo2

	^CoffeeShopProduct combo2 ! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 20:22:35'!
assertSalesMadeTo: aCustomer are: aQuantity ofType: aProductTypeBlock

	| salesToCustomer |
	
	salesToCustomer := salesSystem salesMadeTo: aCustomer.
	self assert: aQuantity equals: salesToCustomer size.
	self assert: aQuantity equals: (salesToCustomer count: aProductTypeBlock)! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test01ThereAreNoSalesWhenSalesSystemIsCreated

	salesSystem := CoffeeShopSalesSystem new.

	self assert: (salesSystem salesMadeTo: adaLovelace) isEmpty! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test02CanQuerySalesByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	self assertSalesMadeTo: adaLovelace are: 1 ofType: [ :aProduct | aProduct = self combo1 ]
	! !
!CoffeeShopTest methodsFor: 'tests - sales' stamp: 'HAW 9/22/2019 21:18:36'!
test03SalesAreDistinguishedByCustomer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: alanKay of: self combo2.

	self assertSalesMadeTo: adaLovelace are: 2 ofType: [ :aProduct | aProduct = self combo1 ].
	self assertSalesMadeTo: alanKay are: 1 ofType: [ :aProduct | aProduct = self combo2 ]! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test04VolumeSoldToCustomerIsZeroWhenCustomerHasNoSaleRegistered

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 0*milliliter equals: volumeSoldToCustomer! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test05VolumesSoldToCustomerIs_250_WhenOnlyCombo1WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 250*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test06VolumesSoldToCustomerIs_100_WhenOnlyCombo2WasBought

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: 100*milliliter equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - volume sold' stamp: 'HAW 9/22/2019 21:18:36'!
test07VolumesSoldToCustomerIsTheSumOfAllSales

	| volumeSoldToCustomer |

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem registerSaleTo: adaLovelace of: self combo1.
	salesSystem registerSaleTo: adaLovelace of: self combo2.

	volumeSoldToCustomer := salesSystem volumeSoldTo: adaLovelace.

	self assert: (250*milliliter)+(100*milliliter) equals: volumeSoldToCustomer ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:25:09'!
assertRewardOf: aCustomer is: aQuantity of: aRewardTypeBlock at: aPrice

	| customerReward |
	
	customerReward := salesSystem rewardOf: aCustomer ifNone: [ self fail ].

	self assert: aQuantity equals: customerReward quantity.
	self assert: (aRewardTypeBlock value: customerReward).
	self assert: aPrice equals: customerReward price.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:29:19'!
registerSalesForCombo1RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:17:22'!
registerSalesForCombo1RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo1RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 2 of: [ :aReward | aReward isForCombo1 ] at: aPrice ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 20:27:16'!
registerSalesForCombo2RewardTo: aCustomer

	salesSystem registerSaleTo: aCustomer of: self combo1.
	salesSystem registerSaleTo: aCustomer of: self combo2.
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:15:55'!
registerSalesForCombo2RewardTo: aCustomer andAssertPriceIs: aPrice

	self registerSalesForCombo2RewardTo: aCustomer.
	self assertRewardOf: aCustomer is: 1 of: [ :aReward | aReward isForCombo2 ] at: aPrice! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test08WhenNothingHasBeenSoldToCustomerThereIsNoRewardForHer

	salesSystem := CoffeeShopSalesSystem new.

	salesSystem rewardOf: adaLovelace ifNone: [ ^self ].
	
	self fail.! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test09GoldCustomerGetsRewardedWithOneCombo2With50PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: adaLovelace andAssertPriceIs: 60*peso! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test10SilverCustomerGetsRewardedWithOneCombo2With75PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: alanKay andAssertPriceIs: 120*3/4*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test11NormalCustomerGetsRewardedWithOneCombo2With90PercentItsPriceWhenRule1Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo2RewardTo: billGates andAssertPriceIs: 120*9/10*peso ! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test12GoldCustomerGetsRewardedWithOneCombo1At75PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: adaLovelace andAssertPriceIs: 75*peso 
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test13SilverCustomerGetsRewardedWithOneCombo1At83PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: alanKay andAssertPriceIs: 83*peso
! !
!CoffeeShopTest methodsFor: 'tests - rewards' stamp: 'HAW 9/22/2019 21:18:36'!
test14NormalCustomerGetsRewardedWithOneCombo1At97PesosWhenRule2Holds

	salesSystem := CoffeeShopSalesSystem new.
	self registerSalesForCombo1RewardTo: billGates andAssertPriceIs: 97*peso
! !

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:40'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:40'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomer methodsFor: 'initialization' stamp: 'HAW 9/23/2019 08:54:02'!
initializeNamed: aName ofType: aType

	name := aName.
	type := aType.
	! !
!CoffeeShopCustomer methodsFor: 'printing' stamp: 'HAW 9/22/2019 18:57:07' overrides: 16902975!
printOn: aStream

	aStream
		nextPutAll: 'Customer named ';
		nextPutAll: name! !
!CoffeeShopCustomer methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:17'!
rewardPriceFor: aReward

	^type rewardPriceFor: aReward ! !

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:40'!
CoffeeShopCustomer class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopCustomer class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:40'!
CoffeeShopCustomer class
	instanceVariableNames: ''!
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:09'!
goldNamed: aName 

	^self named: aName ofType: CoffeeShopGoldCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:44'!
named: aName ofType: aType

	^self new initializeNamed: aName ofType: aType! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:28'!
normalNamed: aName 

	^self named: aName ofType: CoffeeShopNormalCustomer new! !
!CoffeeShopCustomer class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 08:53:18'!
silverNamed: aName 

	^self named: aName ofType: CoffeeShopSilverCustomer new! !

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopCustomerType category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopCustomerType methodsFor: 'reward price' stamp: 'HAW 9/23/2019 08:54:32'!
rewardPriceFor: aCustomer

	self subclassResponsibility ! !

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopGoldCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopGoldCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:02' overrides: 50683938!
rewardPriceFor: aReward

	^aReward rewardPriceForGoldCustomer! !

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopNormalCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopNormalCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:33:38' overrides: 50683938!
rewardPriceFor: aReward

	^aReward rewardPriceForNormalCustomer! !

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSilverCustomer category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSilverCustomer methodsFor: 'reward price' stamp: 'HAW 9/22/2019 21:32:57' overrides: 50683938!
rewardPriceFor: aReward

	^aReward rewardPriceForSilverCustomer! !

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopProduct category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:19'!
price

	^price! !
!CoffeeShopProduct methodsFor: 'price/volume' stamp: 'HAW 9/23/2019 08:57:27'!
volume

	^volume ! !
!CoffeeShopProduct methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:02:56'!
initializeOf: aVolume at: aPrice

	volume := aVolume.
	price := aPrice.
! !

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!

!classDefinition: 'CoffeeShopProduct class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
CoffeeShopProduct class
	instanceVariableNames: 'combo1 combo2'!
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:40'!
combo1

	^combo1! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:46'!
combo2

	^combo2 ! !
!CoffeeShopProduct class methodsFor: 'instance creation' stamp: 'HAW 9/23/2019 09:02:29'!
of: aVolume at: aPrice 

	^self new initializeOf: aVolume at: aPrice 
! !
!CoffeeShopProduct class methodsFor: 'initialization' stamp: 'HAW 9/23/2019 09:03:14' overrides: 16904184!
initialize

	combo1 := self of: 250*milliliter at: 150*peso.
	combo2 := self of: 100*milliliter at: 120*peso! !

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopReward category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:41'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/20/2019 17:54:42'!
price

	^price! !
!CoffeeShopReward methodsFor: 'accessing' stamp: 'HAW 9/21/2019 16:31:13'!
quantity

	^quantity ! !
!CoffeeShopReward methodsFor: 'initialization' stamp: 'HAW 9/22/2019 19:08:08'!
initializeOf: aProduct at: aPrice quantity: aQuantity

	product := aProduct.
	price := aPrice.
	quantity := aQuantity
	! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:00:41'!
isForCombo1
	
	^product = CoffeeShopProduct combo1 ! !
!CoffeeShopReward methodsFor: 'testing' stamp: 'HAW 9/23/2019 09:01:02'!
isForCombo2
	
	^product = CoffeeShopProduct combo2 ! !

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
CoffeeShopReward class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopReward class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
CoffeeShopReward class
	instanceVariableNames: ''!
!CoffeeShopReward class methodsFor: 'instance creation' stamp: 'HAW 9/20/2019 17:53:14'!
of: aComboType at: aPrice quantity: aQuantity

	^self new initializeOf: aComboType at: aPrice quantity: aQuantity
! !

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CoffeeShopSalesSystem category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!CoffeeShopSalesSystem methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:17:34' overrides: 16920235!
initialize

	sales := Dictionary new! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 19:06:50'!
registerSaleTo: aCustomer of: aProduct

	| salesToCustomer |

	salesToCustomer := sales at: aCustomer ifAbsentPut: [ OrderedCollection new ].
	salesToCustomer add: aProduct ! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/20/2019 17:24:49'!
salesMadeTo: aCustomer

	^sales at: aCustomer ifAbsent: [ #() ]! !
!CoffeeShopSalesSystem methodsFor: 'selling' stamp: 'HAW 9/22/2019 21:26:40'!
volumeSoldTo: aCustomer

	 ^(self salesMadeTo: aCustomer) sum: [ :aProduct | aProduct volume ] ifEmpty: [ 0*milliliter ]! !
!CoffeeShopSalesSystem methodsFor: 'rewarding' stamp: 'HAW 9/22/2019 19:53:42'!
rewardOf: aCustomer ifNone: noneBlock 

	| salesToCustomer volumeSoldToCustomer rewardRule |

	salesToCustomer := self salesMadeTo: aCustomer.
	volumeSoldToCustomer := self volumeSoldTo: aCustomer.
	
	rewardRule := RewardRule for: volumeSoldToCustomer ifNone: [^noneBlock value].
	^rewardRule createRewardFor: aCustomer.
	! !

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!

!classDefinition: 'CoffeeShopSalesSystem class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
CoffeeShopSalesSystem class
	instanceVariableNames: ''!
!CoffeeShopSalesSystem class methodsFor: 'initialization' stamp: 'HAW 9/20/2019 17:32:54' overrides: 16904184!
initialize

	liter := BaseUnit named: 'liter'.
	milliliter := ProportionalDerivedUnit baseUnit: liter conversionFactor: 1/100 named: 'milliliter'.! !

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 21:35:14'!
createRewardFor: aCustomer 
	
	| price |
	
	product := self rewardedProduct.
	price := aCustomer rewardPriceFor: self.
	
	^CoffeeShopReward of: product at: price quantity: self productQuantity! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:26'!
productQuantity

	self subclassResponsibility ! !
!RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:51:33'!
rewardedProduct

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:18'!
rewardPriceForGoldCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:31'!
rewardPriceForNormalCustomer

	self subclassResponsibility ! !
!RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:36:26'!
rewardPriceForSilverCustomer

	self subclassResponsibility ! !

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:42'!
RewardRule class
	instanceVariableNames: ''!
!RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22'!
isFor: volumeSoldToCustomer 
		
	self subclassResponsibility ! !
!RewardRule class methodsFor: 'instance creation' stamp: 'HAW 9/22/2019 19:53:42'!
for: volumeSoldToCustomer ifNone: aNoneBlock

	^self subclasses 
		detect: [ :aRuleClass | aRuleClass isFor: volumeSoldToCustomer ] 
		ifFound: [ :aRuleClass | aRuleClass new ]
		ifNone: aNoneBlock ! !

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo1RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 19:54:35' overrides: 50684231!
productQuantity
	
	^2! !
!Combo1RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:00:06' overrides: 50684235!
rewardedProduct
	
	^CoffeeShopProduct combo1 ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:32:17' overrides: 50684239!
rewardPriceForGoldCustomer
	
	^ 75*peso
	! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:50' overrides: 50684243!
rewardPriceForNormalCustomer
	
	^ 97*peso ! !
!Combo1RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:33:10' overrides: 50684247!
rewardPriceForSilverCustomer

	^ 83*peso ! !

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
Combo1RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo1RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
Combo1RewardRule class
	instanceVariableNames: ''!
!Combo1RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50684261!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer > (500*milliliter)! !

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #Combo2RewardRule category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/22/2019 10:23:07' overrides: 50684231!
productQuantity

	^1! !
!Combo2RewardRule methodsFor: 'reward creation' stamp: 'HAW 9/23/2019 09:01:14' overrides: 50684235!
rewardedProduct
	
	^CoffeeShopProduct combo2 ! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:38' overrides: 50684239!
rewardPriceForGoldCustomer
	
	^product price/2 
	! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:35:06' overrides: 50684243!
rewardPriceForNormalCustomer
	
	^product price *9/10! !
!Combo2RewardRule methodsFor: 'price' stamp: 'HAW 9/22/2019 21:34:53' overrides: 50684247!
rewardPriceForSilverCustomer
	
	^product price*3/4
	! !

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
Combo2RewardRule class
	instanceVariableNames: ''!

!classDefinition: 'Combo2RewardRule class' category: 'IngSof1-2019-2C-1Parcial' stamp: 'AS 5/6/2023 12:20:43'!
Combo2RewardRule class
	instanceVariableNames: ''!
!Combo2RewardRule class methodsFor: 'testing' stamp: 'HAW 9/22/2019 19:53:22' overrides: 50684261!
isFor: volumeSoldToCustomer 

	^volumeSoldToCustomer between: 300*milliliter and: 500*milliliter
	! !

!classRemoval: #Combo2RewardRule stamp: 'AS 5/6/2023 12:20:43'!
RewardRule subclass: #Combo2RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #Combo1RewardRule stamp: 'AS 5/6/2023 12:20:44'!
RewardRule subclass: #Combo1RewardRule
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #RewardRule stamp: 'AS 5/6/2023 12:20:44'!
Object subclass: #RewardRule
	instanceVariableNames: 'product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSalesSystem stamp: 'AS 5/6/2023 12:20:44'!
Object subclass: #CoffeeShopSalesSystem
	instanceVariableNames: 'sales'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopReward stamp: 'AS 5/6/2023 12:20:44'!
Object subclass: #CoffeeShopReward
	instanceVariableNames: 'price quantity product'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopProduct stamp: 'AS 5/6/2023 12:20:44'!
Object subclass: #CoffeeShopProduct
	instanceVariableNames: 'price volume'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopSilverCustomer stamp: 'AS 5/6/2023 12:20:44'!
CoffeeShopCustomerType subclass: #CoffeeShopSilverCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopNormalCustomer stamp: 'AS 5/6/2023 12:20:45'!
CoffeeShopCustomerType subclass: #CoffeeShopNormalCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopGoldCustomer stamp: 'AS 5/6/2023 12:20:45'!
CoffeeShopCustomerType subclass: #CoffeeShopGoldCustomer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomerType stamp: 'AS 5/6/2023 12:20:45'!
Object subclass: #CoffeeShopCustomerType
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopCustomer stamp: 'AS 5/6/2023 12:20:45'!
Object subclass: #CoffeeShopCustomer
	instanceVariableNames: 'name type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classRemoval: #CoffeeShopTest stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #CoffeeShopTest
	instanceVariableNames: 'billGates adaLovelace alanKay salesSystem'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'IngSof1-2019-2C-1Parcial'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00' prior: 50673942!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32' prior: 50673952!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54' prior: 50673963!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15' prior: 50673974!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46' prior: 50672608!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51' prior: 50672616!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48' prior: 50672624!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14' prior: 50672632!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44' prior: 50672656!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57' prior: 50672667!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49' prior: 50672677!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34' prior: 50672689!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53' prior: 50672701!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40' prior: 50672715!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16' prior: 50672725!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10' prior: 50672739!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41' prior: 50672751!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39' prior: 50672780!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47' prior: 50672788!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04' prior: 50672796!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29' prior: 50672805!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36' prior: 50672814!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28' prior: 50672826!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50' prior: 50672838!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57' prior: 50672854!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03' prior: 50672871!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07' prior: 50672892!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16' prior: 50672914!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11' prior: 50673796!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52' prior: 50672976!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31' prior: 50672981!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03' prior: 50672986!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03' prior: 50673001!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31' prior: 50673007!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55' prior: 50673028!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22' prior: 50673033!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06' prior: 50673037!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30' prior: 50673041!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24' prior: 50673044!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:45'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40' prior: 50673057!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22' prior: 50673070!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08' prior: 50673075!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18' prior: 50673080!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12' prior: 50673085!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16' prior: 50673090!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08' prior: 50673095!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18' prior: 50673100!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08' prior: 50673105!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' prior: 50673126 overrides: 50685015!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' prior: 50673130 overrides: 50685010!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' prior: 50673150 overrides: 50685015!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' prior: 50673154 overrides: 50685010!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25' prior: 50673828!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39' prior: 50673999!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54' prior: 50673636!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48' prior: 50673641!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39' prior: 50673719!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21' prior: 50673209!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04' prior: 50673212!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29' prior: 50673713!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52' prior: 50673230!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35' prior: 50673235!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32' prior: 50673240!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04' prior: 50673245!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32' prior: 50673250!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32' prior: 50673255!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42' prior: 50673277!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36' prior: 50673285!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03' prior: 50673439!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38' prior: 50673451!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33' prior: 50673310!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19' prior: 50673313!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17' prior: 50673317!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09' prior: 50673322!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29' prior: 50673893!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41' prior: 50674020!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31' prior: 50673343!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38' prior: 50673349!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:46'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58' prior: 50673364!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41' prior: 50673381!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12' prior: 50673387!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21' prior: 50673393!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29' prior: 50673399!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38' prior: 50673405!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12' prior: 50673411!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21' prior: 50673417!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31' prior: 50673423!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38' prior: 50673428!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32' prior: 50673433!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !

!classRemoval: #TankRover stamp: 'AS 5/6/2023 12:20:46'!
Robot subclass: #TankRover
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Aluminum3000 stamp: 'AS 5/6/2023 12:20:46'!
Robot subclass: #Aluminum3000
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #TurboLaserCannon stamp: 'AS 5/6/2023 12:20:46'!
Weapon subclass: #TurboLaserCannon
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #HSBlaster stamp: 'AS 5/6/2023 12:20:46'!
Weapon subclass: #HSBlaster
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Claw stamp: 'AS 5/6/2023 12:20:47'!
Weapon subclass: #Claw
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Weapon stamp: 'AS 5/6/2023 12:20:47'!
Object subclass: #Weapon
	instanceVariableNames: 'type weight speedImpact usedTimes'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #RobotWarsTest stamp: 'AS 5/6/2023 12:20:47'!
TestCase subclass: #RobotWarsTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-1C-1erParcial'!

!classRemoval: #Trailer stamp: 'AS 5/6/2023 12:20:47'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/6/2023 12:20:47'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/6/2023 12:20:48'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/6/2023 12:20:48'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/6/2023 12:20:48'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/6/2023 12:20:48'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/6/2023 12:20:48'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/6/2023 12:20:48'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/6/2023 12:20:48'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:00'!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'F 5/21/2020 21:50:32'!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withMechanicalFailure.
			aCashier receiveOrder: aRobot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'F 5/20/2020 23:18:54'!
test03ShouldNotAcceptSensorsFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot withSensorsFailure.
			aCashier receiveOrder: aRobot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'F 5/20/2020 23:47:15'!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	| aRobot aTrailer aCashier |
	
	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aCashier := Cashier new.

	self
		should: [ 
			aRobot take: (ProductA with: 1  and: 1).
			aRobot withMechanicalFailure.
			
			aCashier receiveOrder: aRobot.
			
			aRobot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:46'!
test01CanNotCreateProductWithCeroOrLessWeight

	self
		should: [ Product with: 0  and: 100 ]
		raise: Error
		withMessageText: Product invalidWeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 19:37:51'!
test02CanNotCreateProductWithCeroOrLessHeight

	self
		should: [ Product with: 100  and: 0 ]
		raise: Error
		withMessageText: Product invalidHeightErrorDescription 
! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:54:48'!
test03CanNotCreateProductWithNoIntegerWeight

	self
		should: [ Product with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Product weightMustBeIntegerErrorDescription 

! !
!ProductTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:55:14'!
test04CanNotCreateProductWithNoIntegerHeight

	self
		should: [ Product with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Product heightMustBeIntegerErrorDescription 

! !

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:49'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotTest methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 11:29:44'!
test01ShouldReceiveAnEmptyTrailer

	| aTrailer |

	aTrailer := Trailer with: 20 and: 100.
	aTrailer carry: (ProductA with: 1  and: 1).
	
	self
		should: [ Robot with: aTrailer ]
		raise: Error
		withMessageText: Robot notEmptyTrailerErrorDescription! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:04:57'!
test02ShouldTakeProductsWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:07:49'!
test03ShouldTakeProductsWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withSensorsFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 11:08:34'!
test04ShouldTakeProductsWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot withMechanicalFailure.
	
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: 1 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'taking products' stamp: 'FRT 5/4/2020 18:26:53'!
test05ShouldNotTakeProductsWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot outOfOrder.
	
	self
		should: [ aRobot take: (ProductA with: 1  and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
	
	self assert: 0 equals: aTrailer totalProductsAmount! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:46:40'!
test06CanCloseOrderWhenWorkingNormal

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	self assert: (aRobot closeOrderUsing: Cashier new)! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 11:28:16'!
test07CanNotCloseOrderWhenWorkingWithSensorsFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot withSensorsFailure.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
 
! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 12:47:10'!
test08CanCloseOrderWhenWorkingWithMechanicalFailures

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).

	aRobot withMechanicalFailure.	
		
	self assert: (aRobot closeOrderUsing: Cashier new).! !
!RobotTest methodsFor: 'closing order' stamp: 'FRT 5/4/2020 18:48:41'!
test09CanNotCloseOrderWhenOutOfOrder

	| aTrailer aRobot |

	aTrailer := Trailer with: 20 and: 100.
	aRobot := Robot with: aTrailer.
	aRobot take: (ProductA with: 1  and: 1).
	
	aRobot outOfOrder.

	self
		should: [ aRobot closeOrderUsing: Cashier new ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.
 
! !

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:50'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #TrailerTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:50'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:29:39'!
test01CanNotCreateTrailerWithCeroOrLessMaxWeight

	self
		should: [ Trailer with: 0  and: 100 ]
		raise: Error
		withMessageText: Trailer invalidWeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:30:47'!
test02CanNotCreateTrailerWithCeroOrLessMaxHeight

	self
		should: [ Trailer with: 1  and: 0 ]
		raise: Error
		withMessageText: Trailer invalidHeightCapacityErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:04'!
test03CanNotCreateTrailerWithNoIntegerMaxWeight

	self
		should: [ Trailer with: 1.5  and: 100 ]
		raise: Error
		withMessageText: Trailer weightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:41:29'!
test04CanNotCreateTrailerWithNoIntegerMaxHeight

	self
		should: [ Trailer with: 100  and: 1.5 ]
		raise: Error
		withMessageText: Trailer heightCapacityMustBeIntegerErrorDescription 
! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:36'!
test05ShouldRejectProductAIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductA with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/4/2020 17:43:28'!
test06ShouldRejectProductBIfWeightExceeded

	| aTrailer |
	aTrailer := Trailer with: 20  and: 100.
	
	self
		should: [ aTrailer carry: (ProductB with: 21 and: 1) ]
		raise: Error
		withMessageText: Trailer maxWeightExceededErrorDescription.
		
	self assert: aTrailer isEmpty.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:50'!
test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
		
	self assert: aTrailer totalProductsAmount equals: 4.
	self assert: aTrailer totalProductsWeight equals: 10.! !
!TrailerTest methodsFor: 'weight capacity' stamp: 'FRT 5/5/2020 11:27:57'!
test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity

	| aTrailer |
	aTrailer := Trailer with: 11  and: 100.
	
	aTrailer carry: (ProductA with: 1 and: 1).
	aTrailer carry: (ProductA with: 2 and: 1).
	aTrailer carry: (ProductB with: 3 and: 1).
	aTrailer carry: (ProductB with: 4 and: 1).
	aTrailer carry: (ProductB with: 1 and: 1).
	
	self assert: aTrailer totalProductsAmount equals: 5.
	self assert: aTrailer totalProductsWeight equals: 11.! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:03'!
test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: 0.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:07'!
test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductA with: 10 and: halfExceededHeightCapacity).
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).
	
	self assert: aTrailer totalProductsAmount equals: 2.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !
!TrailerTest methodsFor: 'height capacity' stamp: 'FRT 5/5/2020 11:28:16'!
test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts

	| aTrailer heightCapacity exceededHeightCapacity halfExceededHeightCapacity |

	heightCapacity := 100.
	aTrailer := Trailer with: 20  and: heightCapacity.
	
	exceededHeightCapacity := heightCapacity + 2.
	halfExceededHeightCapacity := exceededHeightCapacity / 2.
	
	aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity).

	self 
		should: [aTrailer carry: (ProductB with: 10 and: halfExceededHeightCapacity)] 
		raise: Error
		withMessageText: Trailer maxHeightExceededErrorDescription.
	
	self assert: aTrailer totalProductsAmount equals: 1.
	self assert: aTrailer totalProductsHeight equals: halfExceededHeightCapacity.
	! !

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Cashier category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Cashier methodsFor: 'closing buy order' stamp: 'F 5/20/2020 23:33:11'!
receiveOrder: aRobot
	
	aRobot status = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:17:52'!
assertTrailerNotEmpty: aTrailer
	
	aTrailer isEmpty ifTrue: [self signalTrailerIsEmpty]! !
!Cashier methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:28:31'!
signalTrailerIsEmpty
	
	self error: self class trailerIsEmptyErrorDescription! !
!Cashier methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:28:03'!
signalRobotSensorsFailure
	
	self error: self class robotSensorsFailureErrorDescription! !

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Cashier class
	instanceVariableNames: ''!

!classDefinition: 'Cashier class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Cashier class
	instanceVariableNames: ''!
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:03'!
robotSensorsFailureErrorDescription
	
	^ 'This robot presents sensors failures!!'! !
!Cashier class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:28:31'!
trailerIsEmptyErrorDescription
	
	^ 'This robots trailer is empty!!'! !

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Product category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Product methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 10:39:55'!
initializeWith: aWeight and: aHeight
	
	weight := aWeight.
	height := aHeight.! !
!Product methodsFor: 'action' stamp: 'FRT 5/4/2020 10:38:22'!
carryBy: aTrailer	
	
	self subclassResponsibility! !
!Product methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:39:06'!
isStackable
	
	self subclassResponsibility! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:30'!
height
	
	^ height! !
!Product methodsFor: 'accessing' stamp: 'FRT 5/4/2020 10:43:24'!
weight
	
	^ weight! !

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Product class
	instanceVariableNames: ''!

!classDefinition: 'Product class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:51'!
Product class
	instanceVariableNames: ''!
!Product class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:47:40'!
with: aWeight and: aHeight
	
	aWeight strictlyPositive ifFalse: [ self signalInvalidWeight ].
	aHeight strictlyPositive ifFalse: [ self signalInvalidHeight ].

	aWeight isInteger ifFalse: [ self signalWeightMustBeInteger ].
	aHeight isInteger ifFalse: [ self signalHeightMustBeInteger ].
	
	^ self new initializeWith: aWeight and: aHeight! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:22'!
signalHeightMustBeInteger

	self error: self heightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:08'!
signalInvalidHeight

	self error: self invalidHeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:29:18'!
signalInvalidWeight

	self error: self invalidWeightErrorDescription! !
!Product class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:48:12'!
signalWeightMustBeInteger

	self error: self weightMustBeIntegerErrorDescription! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:16'!
heightMustBeIntegerErrorDescription

	^ 'Height must be integer'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:08'!
invalidHeightErrorDescription

	^ 'Height must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:18'!
invalidWeightErrorDescription

	^ 'Weight must be positive'! !
!Product class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:08'!
weightMustBeIntegerErrorDescription

	^ 'Weight must be integer'! !

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:52'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductA category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:52'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductA methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:41:29' overrides: 50686073!
isStackable

	^ false! !
!ProductA methodsFor: 'action' stamp: 'FRT 5/4/2020 10:41:12' overrides: 50686069!
carryBy: aTrailer

	aTrailer carryProductA: self! !

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:52'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #ProductB category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:52'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!ProductB methodsFor: 'testing' stamp: 'FRT 5/4/2020 10:42:28' overrides: 50686073!
isStackable

	^ true! !
!ProductB methodsFor: 'action' stamp: 'FRT 5/4/2020 10:42:16' overrides: 50686069!
carryBy: aTrailer

	aTrailer carryProductB: self! !

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:52'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Robot category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:52'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:41:25'!
closeOrderUsing: aCashier
	
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'FRT 5/4/2020 18:30:39'!
take: aProduct

	status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:54'!
outOfOrder

	status := #OutOfOrder
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:48'!
withMechanicalFailure

	status := #MechanicalFailure
! !
!Robot methodsFor: 'status' stamp: 'FRT 5/4/2020 18:29:39'!
withSensorsFailure

	status := #SensorsFailure
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/4/2020 18:35:21'!
status

	^ status
! !
!Robot methodsFor: 'accessing' stamp: 'FRT 5/3/2020 21:27:04'!
trailer

	^ trailer
! !
!Robot methodsFor: 'initialization' stamp: 'FRT 5/4/2020 18:21:29'!
initializeWith: aTrailer

	trailer := aTrailer.
	status := #WorkingNormal.
! !

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:53'!
Robot class
	instanceVariableNames: ''!

!classDefinition: 'Robot class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:53'!
Robot class
	instanceVariableNames: ''!
!Robot class methodsFor: 'instance creation' stamp: 'FRT 5/3/2020 22:36:52'!
with: aTrailer

	self assertIsEmpty: aTrailer.

	^ self new initializeWith: aTrailer! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/3/2020 22:35:35'!
assertIsEmpty: aTrailer

	^ aTrailer isEmpty ifFalse: [ self signalNotEmptyTrailer ]! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 11:29:32'!
signalNotEmptyTrailer

	self error: self notEmptyTrailerErrorDescription! !
!Robot class methodsFor: 'assertions' stamp: 'FRT 5/4/2020 18:26:04'!
signalOutOfOrder
	
	self error: self outOfOrderErrorDescription! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:29:32'!
notEmptyTrailerErrorDescription

	^ 'The robot was assigned a non empty trailer'! !
!Robot class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 18:26:32'!
outOfOrderErrorDescription
	
	^ 'Robot out of order :('! !

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:53'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #Trailer category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:53'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Trailer methodsFor: 'initialization' stamp: 'FRT 5/3/2020 23:27:42'!
initializeWith: aWeightCapacity and: aHeightCapacity

	weightCapacity := aWeightCapacity.
	heightCapacity := aHeightCapacity.
	
	container := OrderedCollection new.! !
!Trailer methodsFor: 'accessing' stamp: 'FRT 5/3/2020 23:34:36'!
totalProductsAmount
	
	^ container size.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:35:03'!
totalProductsHeight
	"Solo importa la altura de los productos apilables"

	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [ | product |
		product := (container at: index).
		(product isStackable) ifTrue: [ total := total +  product height ].
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'accessing' stamp: 'F 5/14/2020 10:34:38'!
totalProductsWeight
	
	| total index |

	total := 0.
	index := 1.
	
	[index <= container size] whileTrue: [
		total := total + (container at: index) weight.
		index := index + 1.	
	].

	^ total.! !
!Trailer methodsFor: 'testing' stamp: 'FRT 5/3/2020 23:33:33'!
isEmpty
	
	^ container isEmpty! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/3/2020 23:35:19'!
carry: aProduct
	
	^ aProduct carryBy: self.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:17'!
carryProductA: aProduct
	
	self assertWeightAdding: aProduct.
	container add: aProduct.! !
!Trailer methodsFor: 'action' stamp: 'FRT 5/4/2020 19:08:09'!
carryProductB: aProduct

	self assertWeightAdding: aProduct.
	self assertHeightAdding: aProduct.
	
	container add: aProduct.! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:29'!
assertHeightAdding: aProduct
	
	(self totalProductsHeight + aProduct height) > heightCapacity ifTrue: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'FRT 5/5/2020 11:27:41'!
assertWeightAdding: aProduct
	
	(self totalProductsWeight + aProduct weight) > weightCapacity ifTrue: [ self signalMaxWeightCapacityExceeded ]! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:31'!
signalMaxHeightCapacityExceeded

	self error: self class maxHeightExceededErrorDescription
! !
!Trailer methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:38'!
signalMaxWeightCapacityExceeded

	self error: self class maxWeightExceededErrorDescription
! !

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:54'!
Trailer class
	instanceVariableNames: ''!

!classDefinition: 'Trailer class' category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:54'!
Trailer class
	instanceVariableNames: ''!
!Trailer class methodsFor: 'instance creation' stamp: 'FRT 5/4/2020 17:33:58'!
with: aWeightCapacity and: aHeightCapacity

	aWeightCapacity strictlyPositive ifFalse: [ self signalInvalidWeightCapacity ].
	aHeightCapacity strictlyPositive ifFalse: [ self signalInvalidHeightCapacity ].
	
	aWeightCapacity isInteger ifFalse: [ self signalWeightCapacityMustBeInteger ].
	aHeightCapacity isInteger ifFalse: [ self signalHeightCapacityMustBeInteger ].
		
	^ self new initializeWith: aWeightCapacity and: aHeightCapacity.

! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:41'!
signalHeightCapacityMustBeInteger

	self error: self heightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:12'!
signalInvalidHeightCapacity

	self error: self invalidHeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 11:30:21'!
signalInvalidWeightCapacity

	self error: self invalidWeightCapacityErrorDescription
! !
!Trailer class methodsFor: 'exceptions' stamp: 'FRT 5/4/2020 17:37:29'!
signalWeightCapacityMustBeInteger

	self error: self weightCapacityMustBeIntegerErrorDescription
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:38'!
heightCapacityMustBeIntegerErrorDescription

	^ 'Height capacity must be integer'! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:12'!
invalidHeightCapacityErrorDescription

	^ 'The trailers height capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:21'!
invalidWeightCapacityErrorDescription

	^ 'The trailers weight capacity must be positive.'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:31'!
maxHeightExceededErrorDescription

	^ 'Maximum height has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 11:30:38'!
maxWeightExceededErrorDescription

	^ 'Maximum weight has been exceeded'
! !
!Trailer class methodsFor: 'error messages' stamp: 'FRT 5/4/2020 17:49:32'!
weightCapacityMustBeIntegerErrorDescription

	^ 'Weight capacity must be integer'! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:19:45' prior: 50686325!
totalProductsHeight

	^(container select: [ :product | product isStackable])
		sum: [ :product | product height ]
		ifEmpty: [0]

! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:41' prior: 50686337!
totalProductsWeight
	
	^container sum: [ :product | product weight ]
! !
!Trailer methodsFor: 'accessing' stamp: 'AS 4/30/2023 14:20:56' prior: 50686482!
totalProductsWeight
	
	^container sum: [ :product | product weight ] ifEmpty: [0]
! !

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:54'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusWorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusSensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusMechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatusOutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotStatusMechanicalFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:25:40'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:27:46' prior: 50686210!
closeOrderUsing: aCashier
	
	"status from: self closeOrderTo: aCashier"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:32:10' prior: 50673802 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:33:45'!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	| aTrailer |
	
	aRobot outOfOrder.
		
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	^ true
! !
!RobotStatusOutOfOrder methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:35:08' prior: 50673809 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusOutOfOrderFrom: aRobot
	! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:36:44' prior: 50686635 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:37:14' prior: 50673815 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:37:42'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusWorkingNormal methodsFor: 'no messages' stamp: 'AS 4/30/2023 14:38:11' prior: 50673822 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:38:45'!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	| aTrailer | 
	
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
	^ true
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:23' prior: 50686233!
outOfOrder

	status := RobotStatusOutOfOrder new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:37' prior: 50686237!
withMechanicalFailure

	status := RobotStatusMechanicalFailure new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:39:48' prior: 50686241!
withSensorsFailure

	status := RobotStatusSensorsFailure
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:40:10' prior: 50686594!
closeOrderUsing: aCashier
	
	status from: self closeOrderTo: aCashier.
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:41:38' prior: 50686222!
take: aProduct

	status take: aProduct into: trailer
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 14:43:37' prior: 50686699!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:46:01' prior: 50673688 overrides: 50673855!
take: aProduct into: trailer of: aRobot
	
	^trailer withMechanicalFailure carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:44' prior: 50673682 overrides: 50673855!
take: aProduct into: trailer of: aRobot
	
	^aRobot class signalOutOfOrder.! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:47:57' prior: 50686711 overrides: 50673855!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct 
	
	"status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].	"! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:13' prior: 50673702 overrides: 50673855!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:48:20' prior: 50673708 overrides: 50673855!
take: aProduct into: trailer of: aRobot
	
	^trailer carry: aProduct ! !
!Robot methodsFor: 'initialization' stamp: 'AS 4/30/2023 14:48:46' prior: 50686251!
initializeWith: aTrailer

	trailer := aTrailer.
	status := RobotStatusWorkingNormal new
! !
!Robot methodsFor: 'status' stamp: 'AS 4/30/2023 14:49:01' prior: 50686689!
withSensorsFailure

	status := RobotStatusSensorsFailure new
! !

!methodRemoval: RobotStatusMechanicalFailure #closeOrderUsing: stamp: 'AS 5/6/2023 12:20:55'!
closeOrderUsing: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailure
	
	"
	status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
	"!
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:07' prior: 50686610 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:19' prior: 50686649 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:50:34' prior: 50686663 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrder: aRobot! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:15' prior: 50686788 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:32' prior: 50686795 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSeensorsFailureFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:51:51'!
receiveOrderWithStatusSensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:51:51' prior: 50686817 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !

!methodRemoval: Cashier #receiveOrderWithStatusSeensorsFailureFrom: stamp: 'AS 5/6/2023 12:20:55'!
receiveOrderWithStatusSeensorsFailureFrom: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure
!
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:52:04' prior: 50686802 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 14:57:14' prior: 50685990!
receiveOrder: aRobot
	
	aRobot closeOrderUsing: self
! !
!RobotStatusMechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 14:59:54' prior: 50686809 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusMechanicalFailureFrom: aRobot
! !
!RobotStatusOutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:12' prior: 50686642 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	^aRobot class signalOutOfOrder
	! !
!RobotStatusSensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:17' prior: 50686831 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusSensorsFailureFrom: aRobot! !
!RobotStatusWorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 4/30/2023 15:00:24' prior: 50686845 overrides: 50673850!
from: aRobot closeOrderTo: aCashier
	
	^aCashier receiveOrderWithStatusWorkingNormalFrom: aRobot! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 15:01:59' prior: 50686694!
closeOrderUsing: aCashier
	
	^status from: self closeOrderTo: aCashier.
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:07:39' prior: 50686625!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 15:08:02' prior: 50686669!
receiveOrderWithStatusWorkingNormalFrom: aRobot
	
	self assertTrailerNotEmpty: aRobot trailer.	
	"Comentario: en este punto el cashier realizaría el checkout de los productos."		
	^ true
! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:12' prior: 50673850!
from: aRobot closeOrderTo: aCashier
	
	self subclassResponsibility ! !
!RobotStatus methodsFor: 'actions' stamp: 'AS 4/30/2023 15:10:38' prior: 50673855!
take: aProduct into: trailer of: aRobot

	self subclassResponsibility ! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:01:25'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:17' prior: 50686365!
assertHeightAdding: aProduct
	
	self execute: [ self signalMaxHeightCapacityExceeded ]
		If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:02:32'!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: aBlock value.
! !

!methodRemoval: Trailer #execute:If:exceed: stamp: 'AS 5/6/2023 12:20:55'!
execute: aBlock If: aValue exceed: aThreshold
	
	(aValue > aThreshold) ifTrue: aBlock value.
!
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:14' prior: 50686924!
assertHeightAdding: aProduct
	
	self If: (self totalProductsHeight + aProduct height)
		exceed: heightCapacity	
		execute: [ self signalMaxHeightCapacityExceeded ]! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:03:55' prior: 50686943!
assertHeightAdding: aProduct
	
	self if: (self totalProductsHeight + aProduct height)
		 exceed: heightCapacity	
		 execute: [ self signalMaxHeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:04:22' prior: 50686372!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #CashierTest category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 12:20:55'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:06' overrides: 16961394!
setUp

	trailer := Trailer with: 20 and: 100.
	robot := Robot with: trailer.	
	cashier := Cashier new.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:06:55' prior: 50685569!
test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot

	self
		should: [ 
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from empty trailer' stamp: 'AS 4/30/2023 16:07:11' prior: 50685582!
test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot

	self
		should: [ 
			robot withMechanicalFailure.
			cashier receiveOrder: robot 
		]
		raise: Error
		withMessageText: Cashier trailerIsEmptyErrorDescription.
! !
!CashierTest methodsFor: 'receiving from sensors failure robot' stamp: 'AS 4/30/2023 16:07:28' prior: 50685597!
test03ShouldNotAcceptSensorsFailureRobot

	self
		should: [ 
			robot withSensorsFailure.
			cashier receiveOrder: robot ]
		raise: Error
		withMessageText: Cashier robotSensorsFailureErrorDescription.
! !
!CashierTest methodsFor: 'receiving from mechanical failure robot' stamp: 'AS 4/30/2023 16:07:55' prior: 50685611!
test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot

	self
		should: [ 
			robot take: (ProductA with: 1  and: 1).
			robot withMechanicalFailure.
			
			cashier receiveOrder: robot.
			
			robot take: (ProductA with: 1 and: 1) ]
		raise: Error
		withMessageText: Robot outOfOrderErrorDescription.

! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:11:47' prior: 50686892!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self halt.
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:13:52' prior: 50686704!
take: aProduct

	self halt.
	status take: aProduct into: trailer of: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 4/30/2023 16:14:13' prior: 50687052!
take: aProduct

	status take: aProduct into: trailer of: self
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 4/30/2023 16:15:00' prior: 50687045!
receiveOrderWithStatusMechanicalFailureFrom: aRobot
	
	aRobot outOfOrder.	
	self assertTrailerNotEmpty: aRobot trailer.		
	^ true
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:16:09' prior: 50686959!
assertWeightAdding: aProduct
	
	self halt.
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:17:09' prior: 50687069!
assertWeightAdding: aProduct
	
	self if: (self totalProductsWeight + aProduct weight)
		 exceed: weightCapacity	
		 execute: [ self signalMaxWeightCapacityExceeded ]
! !
!Trailer methodsFor: 'assertions' stamp: 'AS 4/30/2023 16:18:21' prior: 50686932!
if: aValue exceed: aThreshold execute: aBlock 
	
	(aValue > aThreshold) ifTrue: [aBlock value].
! !

!classRemoval: #TurboInactive stamp: 'AS 5/6/2023 12:20:56'!
Turbo subclass: #TurboInactive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboActive stamp: 'AS 5/6/2023 12:20:56'!
Turbo subclass: #TurboActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Turbo stamp: 'AS 5/6/2023 12:20:56'!
Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Track stamp: 'AS 5/6/2023 12:20:56'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #SectorTurboNotAdmited stamp: 'AS 5/6/2023 12:20:56'!
Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #SectorTurboAdmited stamp: 'AS 5/6/2023 12:20:56'!
Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Sector stamp: 'AS 5/6/2023 12:20:56'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #GrandPrix stamp: 'AS 5/6/2023 12:20:57'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneCar stamp: 'AS 5/6/2023 12:20:57'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneTest stamp: 'AS 5/6/2023 12:20:57'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Trailer stamp: 'AS 5/6/2023 12:20:57'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusWorkingNormal stamp: 'AS 5/6/2023 12:20:57'!
RobotStatus subclass: #RobotStatusWorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusSensorsFailure stamp: 'AS 5/6/2023 12:20:58'!
RobotStatus subclass: #RobotStatusSensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusOutOfOrder stamp: 'AS 5/6/2023 12:20:58'!
RobotStatus subclass: #RobotStatusOutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatusMechanicalFailure stamp: 'AS 5/6/2023 12:20:58'!
RobotStatus subclass: #RobotStatusMechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatus stamp: 'AS 5/6/2023 12:20:58'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/6/2023 12:20:58'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/6/2023 12:20:58'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/6/2023 12:20:58'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/6/2023 12:20:59'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/6/2023 12:20:59'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/6/2023 12:20:59'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/6/2023 12:20:59'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/6/2023 12:20:59'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/6/2023 12:20:59'!
TestCase subclass: #CashierTest
	instanceVariableNames: 'trailer robot cashier'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #PointsPortableObject stamp: 'AS 5/6/2023 12:20:59'!
PortableObject subclass: #PointsPortableObject
	instanceVariableNames: 'points'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #NoPointsPortableObject stamp: 'AS 5/6/2023 12:21:00'!
PortableObject subclass: #NoPointsPortableObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PortableObject stamp: 'AS 5/6/2023 12:21:00'!
StageObject subclass: #PortableObject
	instanceVariableNames: 'name weight'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Door stamp: 'AS 5/6/2023 12:21:00'!
StageObject subclass: #Door
	instanceVariableNames: 'state key'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #StageObject stamp: 'AS 5/6/2023 12:21:00'!
Object subclass: #StageObject
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #PlayableCharacter stamp: 'AS 5/6/2023 12:21:00'!
Object subclass: #PlayableCharacter
	instanceVariableNames: 'name backpack'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorState stamp: 'AS 5/6/2023 12:21:00'!
Object subclass: #DoorState
	instanceVariableNames: 'door'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #Backpack stamp: 'AS 5/6/2023 12:21:01'!
Object subclass: #Backpack
	instanceVariableNames: 'weightCapacity gamePointsCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorTest stamp: 'AS 5/6/2023 12:21:01'!
TestCase subclass: #DoorTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #BackpackTest stamp: 'AS 5/6/2023 12:21:01'!
TestCase subclass: #BackpackTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classRemoval: #DoorOpen stamp: 'AS 5/6/2023 12:21:01'!
AnObsoleteDoorState subclass: #DoorOpen
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-2C-Parcial-Enunciado'!

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:01'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:01'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 4/30/2022 18:38:56'!
test01SectorLengthMustBePositive

	self 
		should: [ Sector withTurboOf: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07'!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector _ Sector withTurboOf: 10 * kilometer.
	outside _ sector length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07'!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector _ Sector withoutTurboOf: 10*kilometer.
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:20'!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 20 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:26'!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:35'!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:40'!
test07TrackMustHaveSectors

	self
		should: [ Track withSectors: #() ]
		raise: Error
		withMessageText: Track mustHaveSectorsErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:46'!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	track _ Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:23:36'!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	outside _ track length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:24:51'!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	positionInSector2 _ 5 * kilometer.
	positionInTrack _ sectors first length + positionInSector2.
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:15'!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	track _ Track withSectors: sectors.
	car1 _ FormulaOneCar drivenBy: #Schumacher.
	car2 _ FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:37'!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:26:29'!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track _ Track withSectors: (OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer)).
	numberOfLaps _ 100.
	
	grandPrix _ GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:14'!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100.
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:18'!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:27:57'!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:28:20'!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:29:34'!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:40'!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	sectorA _ Sector withTurboOf: 10 * kilometer.
	sectorB _ Sector withTurboOf: 30 * kilometer.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:48:08'!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:31'!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:58'!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:19:06'!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:24'!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:59'!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:03'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:03'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'initialization' stamp: 'HAW 5/2/2022 14:12:13'!
initializeDrivenBy: aDriver 

	driver _ aDriver.
	turboActivated _ false.
	turboActivations _ 0.
	speed _ 0*kilometer/hour.
	traveledDistance _ 0.
	! !
!FormulaOneCar methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:28'!
runningInGrandPrix: aGrandPrix
	
	grandPrix _ aGrandPrix! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:07'!
advance: aDistance

	traveledDistance _ traveledDistance + aDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'FRT 4/30/2022 16:33:07'!
atSector: aSector

	currentSector _ aSector.! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/2/2022 14:11:23'!
speed

	turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	].

	^speed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/1/2022 17:34:26'!
speed: newSpeed

	speed _ newSpeed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:19'!
traveledDistance

	^ traveledDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:31'!
traveledDistance: aDistance

	traveledDistance _ aDistance! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:23:56'!
activateTurbo

	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:47'!
deactivateTurbo
	
	turboActivated ifFalse: [ self error: self turboAlreadydeActivatedErrorDescription ].
	
	turboActivated _ false! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:13'!
turboAlreadydeActivatedErrorDescription
	
	^'Turbo is already deactivated'! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 4/30/2022 19:10:34'!
isTurboActivated
	
	^turboActivated! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 5/2/2022 14:23:06'!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'HAW 5/2/2022 14:23:47'!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 ! !

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:04'!
FormulaOneCar class
	instanceVariableNames: ''!

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:04'!
FormulaOneCar class
	instanceVariableNames: ''!
!FormulaOneCar class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 18:44:15'!
drivenBy: aDriver 

	^self new initializeDrivenBy: aDriver ! !

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:04'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:04'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!GrandPrix methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:39'!
initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars

	track _ aTrack.
	numberOfLaps _ aNumberOfLaps.
	aCollectionOfCars do: [ :car | car runningInGrandPrix: self ].
! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 22:23:59'!
locationOf: aCar

	^ aCar traveledDistance.	! !
!GrandPrix methodsFor: 'car position' stamp: 'HAW 4/30/2022 19:15:32'!
put: aCar at: aDistance

	| distanceInTrack |
	
	aCar traveledDistance: aDistance.
	
	distanceInTrack _ aDistance \\ track length.
	track put: aCar at: distanceInTrack.
	! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:38:16'!
sectorOf: aCar 

	^ track sectorOf: aCar.! !
!GrandPrix methodsFor: 'length' stamp: 'HAW 4/30/2022 18:43:17'!
length

	^ track length * numberOfLaps! !
!GrandPrix methodsFor: 'simulation' stamp: 'FRT 5/1/2022 09:06:07'!
advance: aTimeLapse
	
	| ix cars |
	
	cars _ track cars asOrderedCollection.
	ix _ 1.
	[ix <= cars size] whileTrue: [ | car |
		car _ cars at: ix.
		self relocate: car after: aTimeLapse.
		ix _ ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'HAW 5/1/2022 17:35:43'!
relocate: aCar after: aTimeLapse 

	| distanceMoved distanceInTrack |
	
	distanceMoved _ aCar speed * aTimeLapse.
	aCar advance: distanceMoved.
	
	distanceInTrack _ aCar traveledDistance \\ track length.
	track put: aCar at: distanceInTrack.! !

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:05'!
GrandPrix class
	instanceVariableNames: ''!

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:05'!
GrandPrix class
	instanceVariableNames: ''!
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:05'!
on: aTrack running: aNumberOfLaps 

	^self on: aTrack running: aNumberOfLaps with: #()! !
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:16'!
on: aTrack running: aNumberOfLaps with: aCollectionOfCars

	^self new initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars! !
!GrandPrix class methodsFor: 'error message' stamp: 'ARM 4/28/2022 15:09:05'!
distanceOutSideRaceTrackLengthErrorMessage

	^'Distance outside Race Track length'! !
!GrandPrix class methodsFor: 'error message' stamp: 'FRT 5/1/2022 12:24:57'!
turboNotAllowedWithRainTiresErrorMessage

	^ 'Turbo not allowed with rain tires'! !

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:05'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:05'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 10:02:21'!
initializeOf: aLength 

	cars _ Dictionary new.
	length _ aLength.! !
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 09:59:49'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55'!
assertValidPosition: aPosition

	length < aPosition ifTrue: [ self error: self class cannotPlacedCarErrorDescription ]! !
!Sector methodsFor: 'car position' stamp: 'HAW 5/1/2022 16:59:05'!
atStartPut: aCar
 
	self put: aCar at: 0*kilometer! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 09:23:35'!
positionOf: aCar
 
	^ cars at: aCar.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55'!
put: aCar at: aPosition
 
	self assertValidPosition: aPosition.
	
	cars at: aCar put: aPosition.
	aCar atSector: self.! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:04:40'!
remove: aCar
 
	cars removeKey: aCar ifAbsent: [].
! !
!Sector methodsFor: 'accessing' stamp: 'FRT 4/30/2022 22:08:51'!
cars
	
	^ cars keys! !
!Sector methodsFor: 'accessing' stamp: 'HAW 5/2/2022 14:26:16'!
length

	^length! !
!Sector methodsFor: 'testing' stamp: 'HAW 5/1/2022 16:54:33'!
includes: aCar

	^ cars includesKey: aCar! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:21:14'!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:07:54'!
assertDriverIsOneSecondOrLess: aCarToActivateTurboTo ofDriverAt: positionOfCarAhead

	| carAhead |
	
	carAhead _ self carAtPosition: positionOfCarAhead.
	
	((positionOfCarAhead / carAhead speed) -
	((cars at: aCarToActivateTurboTo) / aCarToActivateTurboTo speed)) < (1 * second)
		ifFalse: [self error: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription ].! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:06:52'!
carAtPosition: positionOfDriver

	^cars keyAtValue: positionOfDriver! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:08:13'!
positionOfCarAheadOf: aCarToActiveTurboTo ifNone: alternativeClosure

	| sortedPositions carToActivateTurboToPosition |
	
	carToActivateTurboToPosition _ cars at: aCarToActiveTurboTo.
	sortedPositions _ cars asSortedCollection remove: carToActivateTurboToPosition; yourself.
	 
	^ sortedPositions 
		detect: [:aPosition | aPosition > carToActivateTurboToPosition ]
		ifNone: alternativeClosure ! !

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:06'!
Sector class
	instanceVariableNames: ''!

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:06'!
Sector class
	instanceVariableNames: ''!
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:32'!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ self new initializeOf: aLength; withTurbo: true; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:47'!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; withTurbo: false; yourself ! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:24:41'!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:13:07'!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 10:08:26'!
cannotPlacedCarErrorDescription

	^ 'Driver can not be placed outside section'! !
!Sector class methodsFor: 'error message' stamp: 'HAW 4/30/2022 17:05:20'!
lengthMustBePositiveErrorDescription

	^ 'Length must be positive'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 09:54:45'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:06'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:06'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Track methodsFor: 'initialization' stamp: 'HAW 4/30/2022 17:06:50'!
initializeWithSectors: aSectors

	sectors _ aSectors copy.! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18'!
carNotFoundErrorDescription

	^ 'Car not found'! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:03'!
positionOf: aCar
	| accumulatedLength ix sector |
	
	ix _ 1.
	sector _ (sectors at: ix).
	accumulatedLength _ 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength _ accumulatedLength + sector length.
		ix _ ix + 1.
		sector _ (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar).! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:26:38'!
put: aCar at: aPosition

	| ix sector acc |
	
	aPosition > self length ifTrue: [ self error: self class cannotPlacedCarErrorDescription ].

	self remove: aCar.

	ix _ 1.
	sector _ sectors at: ix. 
	acc _ 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc _ acc + sector length.
		ix _ ix + 1.
		sector _ sectors at: ix.
	].

	sector put: aCar at: aPosition - acc.! !
!Track methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:15:27'!
remove: aCar
	
	| currentSector |
	
	currentSector _ self sectorOf: aCar ifNone: [ ^ self ].
	currentSector remove: aCar.
	! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18'!
sectorOf: aCar
	
	^self sectorOf: aCar ifNone: [ self error: self carNotFoundErrorDescription ]! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:47'!
sectorOf: aCar ifNone: aBlock

	 | ix |
	
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | sector |
		sector _	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix _ ix + 1.
	].

	^ aBlock value.! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:10:09'!
cars
	| allCars ix |
	
	allCars _ Set new.
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | s |
		s _ sectors at: ix.
		allCars addAll: s cars.
		ix _ ix + 1.
	].

	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:31:32'!
length

	| acc ix |

	acc _ 0 * kilometer.
	ix _ 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector _ sectors at: ix.
		acc _ acc + sector length.
		ix _ ix + 1.		
	].

	^ acc.
! !
!Track methodsFor: 'testing' stamp: 'FRT 5/1/2022 09:26:52'!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix sector |
	inc _ false.
	ix _ 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector _ sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc _ true]
		ifFalse: [
			ix _ ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s _ sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix _ ix + 1
			]	
		]. 
	^ inc
	! !

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Track class
	instanceVariableNames: ''!

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Track class
	instanceVariableNames: ''!
!Track class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 17:10:08'!
withSectors: sectors

	sectors isEmpty ifTrue: [ self error: self mustHaveSectorsErrorDescription ].
	
	^ self new initializeWithSectors: sectors! !
!Track class methodsFor: 'error messages' stamp: 'FRT 4/29/2022 18:22:32'!
cannotPlacedCarErrorDescription

	^ 'Car cannot be placed in track'! !
!Track class methodsFor: 'error messages' stamp: 'HAW 4/30/2022 17:09:27'!
mustHaveSectorsErrorDescription

	^'Track must have sectors'! !
!Track methodsFor: 'accessing' stamp: 'AS 5/3/2023 15:01:13' prior: 50688280!
cars
	| allCars |
	
	allCars := Set new.
	sectors do: [ :sector | allCars addAll: sector cars ].
	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'AS 5/3/2023 15:34:15' prior: 50688337!
cars
	| allCars |
	
	allCars := Set new.
	sectors do: [ :sector | allCars addAll: sector cars ].
	^ allCars
! !
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:38:49' prior: 50688296!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix sector |
	
	^sectors includes: aCar.
	"
	inc := false.
	ix := 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector := sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc := true]
		ifFalse: [
			ix := ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s := sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix := ix + 1
			]	
		]. 
	^ inc
	"! !
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:45:00' prior: 50688349!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix s |
	
	^sectors anySatisfy: [ :sector | sector includes: aCar].
	"
	inc := false.
	ix := 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector := sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc := true]
		ifFalse: [
			ix := ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s := sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix := ix + 1
			]	
		]. 
	^ inc
	"! !
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:45:29' prior: 50688366!
includes: aCar

	^sectors anySatisfy: [ :sector | sector includes: aCar].
! !
!Track methodsFor: 'accessing' stamp: 'AS 5/3/2023 15:46:43' prior: 50688288!
length

	^sectors sum: [ :sector | sector length] ifEmpty: [0 * kilometer].
! !
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:50:47' prior: 50688230!
positionOf: aCar
	| accumulatedLength ix s |

	^sectors sum: [ :sector | (sector includes: aCar) ifFalse: [sector length] ifTrue: [sector positionOf: aCar] ] ifEmpty: [ 0 * kilometer ].
	"
	ix := 1.
	sector := (sectors at: ix).
	accumulatedLength := 0 * kilometer.
	
	[sector includes: aCar] whileFalse: [
		accumulatedLength := accumulatedLength + sector length.
		ix := ix + 1.
		sector := (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar).
	"! !
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:51:23' prior: 50688395!
positionOf: aCar

	^sectors sum: [ :sector | (sector includes: aCar) 
					ifFalse: [sector length] 
					ifTrue: [sector positionOf: aCar] ]
		ifEmpty: [ 0 * kilometer ].
! !
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:55:14' prior: 50688271!
sectorOf: aCar ifNone: aBlock

	 | ix |
	
	^sectors detect: [ :sector | sector includes: aCar] ifNone: [aBlock value].
	"
	ix := 1.
	[ix <= sectors size] whileTrue: [ | sector |
		sector :=	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix := ix + 1.
	].

	^ aBlock value.
	"! !
!Track methodsFor: 'car position' stamp: 'AS 5/3/2023 15:55:39' prior: 50688422!
sectorOf: aCar ifNone: aBlock
	
	^sectors detect: [ :sector | sector includes: aCar]
			ifNone: [aBlock value].
! !
!Track methodsFor: 'testing' stamp: 'AS 5/3/2023 15:57:02' prior: 50688384!
includes: aCar

	^sectors anySatisfy: [ :sector | sector includes: aCar].! !

!classDefinition: #TurboSector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Sector subclass: #TurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboSector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Sector subclass: #TurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #NoTurboSector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Sector subclass: #NoTurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #NoTurboSector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Sector subclass: #NoTurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboState category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Object subclass: #TurboState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboState category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Object subclass: #TurboState
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboActivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
TurboState subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboActivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
TurboState subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboDeactivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
TurboState subclass: #TurboDeactivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboDeactivated category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
TurboState subclass: #TurboDeactivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboState category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Object subclass: #TurboState
	instanceVariableNames: 'activations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #TurboState category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Object subclass: #TurboState
	instanceVariableNames: 'activations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations turboState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:07'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations turboState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'initialization' stamp: 'AS 5/3/2023 16:02:19' prior: 50687850!
initializeDrivenBy: aDriver 

	driver := aDriver.
	turboActivated := false.
	turboActivations := 0.
	speed := 0*kilometer/hour.
	traveledDistance := 0.
	turboState := TurboDeactivated new.
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:07:24'!
createSectorWithTurboOf: length

	^TurboSector of: 0 * kilometer.
! !
!TurboSector class methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:09:04'!
of: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	^ self new initializeOf: aLength
	"^ self new initializeOf: aLength; withTurbo: true; yourself "! !
!Sector class methodsFor: 'instance creation' stamp: 'AS 5/3/2023 16:09:32'!
of: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	^ self new initializeOf: aLength! !

!methodRemoval: TurboSector class #of: stamp: 'AS 5/6/2023 12:21:07'!
of: aLength 

	aLength strictlyPositive ifFalse: [ self error: Sector lengthMustBePositiveErrorDescription ]	.
	
	^ self new initializeOf: aLength
	"^ self new initializeOf: aLength; withTurbo: true; yourself "!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:10:16'!
createSectorWithoutTurboOf: length

	^NoTurboSector of: 0 * kilometer.
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:10:38' prior: 50687354!
test01SectorLengthMustBePositive

	self 
		should: [ self createSectorWithTurboOf: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:11:11' prior: 50687362!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := self createSectorWithTurboOf: 10 * kilometer.
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:12:08' prior: 50688612!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector := self createSectorWithTurboOf: (10 * kilometer).
	outside := sector length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:12:57' prior: 50688567!
createSectorWithTurboOf: aLength

	^TurboSector of: aLength
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:13:06' prior: 50688598!
createSectorWithoutTurboOf: aLength

	^NoTurboSector of: aLength
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:13:25' prior: 50687379!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector :=  self createSectorWithoutTurboOf: 10*kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:13:44' prior: 50688656!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector :=  self createSectorWithoutTurboOf: 10 * kilometer.
	car := FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!NoTurboSector methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:15:15' overrides: 50688100!
activateTurboTo: aCarToActivateTurboTo

	self error: Sector turboNotAllowedErrorDescription! !
!TurboSector methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:15:35' overrides: 50688100!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	positionOfCarAhead := self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:16:15' prior: 50687394!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 20 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:16:31' prior: 50687415!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:16:50' prior: 50687433!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:17:29' prior: 50687477!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	track := Track withSectors: sectors.
	outside := track length + (1 * millimeter).
	car := FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:17:52' prior: 50687497!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
		
	positionInSector2 := 5 * kilometer.
	positionInTrack := sectors first length + positionInSector2.
	
	track := Track withSectors: sectors.
	car := FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:18:19' prior: 50687521!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
		
	track := Track withSectors: sectors.
	car1 := FormulaOneCar drivenBy: #Schumacher.
	car2 := FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:18:40' prior: 50687542!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	track := Track withSectors: sectors.
	car := FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:19:02' prior: 50687560!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track := Track withSectors: (OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer)).
	numberOfLaps := 100.
	
	grandPrix := GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:19:20' prior: 50687575!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (self createSectorWithTurboOf: 10 * kilometer)))
		running: 100.
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	hamilton := FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:19:37' prior: 50687595!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (self createSectorWithTurboOf: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:20:01' prior: 50687613!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:20:26' prior: 50687635!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:20:48' prior: 50687655!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	
	grandPrix := GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:11' prior: 50687678!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen := FormulaOneCar drivenBy: #Verstappen.
	sectorA := self createSectorWithTurboOf: 10 * kilometer.
	sectorB := self createSectorWithTurboOf: 30 * kilometer.
	
	grandPrix := GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:27' prior: 50687705!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:42' prior: 50687725!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:21:59' prior: 50687745!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:22:15' prior: 50687766!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:22:28' prior: 50687788!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:22:42' prior: 50687809!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector := self createSectorWithTurboOf: 24 * kilometer.
	
	schumacher := FormulaOneCar drivenBy: #Schumacher.
	hamilton := FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!methodRemoval: Sector class #withTurboOf: stamp: 'AS 5/6/2023 12:21:08'!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ self new initializeOf: aLength; withTurbo: true; yourself !

!methodRemoval: Sector class #withoutTurboOf: stamp: 'AS 5/6/2023 12:21:08'!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; withTurbo: false; yourself !

!methodRemoval: Sector #withTurbo: stamp: 'AS 5/6/2023 12:21:08'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
!
!FormulaOneTest methodsFor: 'tests' stamp: 'AS 5/3/2023 16:24:05' prior: 50687465!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors := OrderedCollection 
		with: (self createSectorWithTurboOf: 10 * kilometer)
		with: (self createSectorWithoutTurboOf: 20 * kilometer).
	track := Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !
!Sector methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:24:34' prior: 50688100!
activateTurboTo: aCarToActivateTurboTo

	self subclassResponsibility 
! !
!TurboState methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:26:27'!
activateIn: aCar
	
	self subclassResponsibility! !
!TurboActivated methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:26:39' overrides: 50689185!
activateIn: aCar
	
	self subclassResponsibility! !
!TurboDeactivated methodsFor: 'no messages' stamp: 'AS 5/3/2023 16:26:44' overrides: 50689185!
activateIn: aCar
	
	self subclassResponsibility! !
!TurboActivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:27:24' prior: 50689190 overrides: 50689185!
activateIn: aCar
	
	self error: aCar turboAlreadyActivatedErrorDescription.! !
!TurboActivated class methodsFor: 'errorDescriptions' stamp: 'AS 5/3/2023 16:28:40'!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!TurboActivated methodsFor: 'actions' stamp: 'AS 5/3/2023 16:28:54' prior: 50689201 overrides: 50689185!
activateIn: aCar
	
	self error: self class turboAlreadyActivatedErrorDescription.! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:29:34' prior: 50687894!
activateTurbo

	turboState activateIn: self.
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:30:48' prior: 50689219!
activateTurbo

	turboState activateIn: currentSector To: self.
"	currentSector activateTurboTo: self."
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'AS 5/3/2023 16:30:59' prior: 50689225!
activateTurbo

	turboState activateAt: currentSector To: self.
"	currentSector activateTurboTo: self."
! !
!TurboState methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:31:31'!
activateAt: currentSector To: aCar
	
	self subclassResponsibility! !

!methodRemoval: TurboState #activateIn: stamp: 'AS 5/6/2023 12:21:08'!
activateIn: aCar
	
	self subclassResponsibility!
!TurboActivated methodsFor: 'actions' stamp: 'AS 5/3/2023 16:31:53' overrides: 50689237!
activateAt: currentSector To: aCar

	self error: self class turboAlreadyActivatedErrorDescription.! !

!methodRemoval: TurboActivated #activateIn: stamp: 'AS 5/6/2023 12:21:08'!
activateIn: aCar
	
	self error: self class turboAlreadyActivatedErrorDescription.!
!TurboDeactivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:32:05' overrides: 50689237!
activateAt: currentSector To: aCar
	
	! !

!methodRemoval: TurboDeactivated #activateIn: stamp: 'AS 5/6/2023 12:21:08'!
activateIn: aCar
	
	self subclassResponsibility!
!TurboDeactivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:33:51' prior: 50689258 overrides: 50689237!
activateAt: currentSector To: aCar
	
	aCar turboActivated.
	currentSector activateTurboTo: aCar.
	! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'AS 5/3/2023 16:34:15' prior: 50687922!
activateTurboInSectorWithTurbo
	
	turboActivated := TurboActivated new.
	turboActivations := turboActivations + 1 ! !
!TurboDeactivated methodsFor: 'as yet unclassified' stamp: 'AS 5/3/2023 16:34:40' prior: 50689267 overrides: 50689237!
activateAt: currentSector To: aCar
	
	currentSector activateTurboTo: aCar.
	! !

!classRemoval: #TurboDeactivated stamp: 'AS 5/6/2023 12:21:08'!
TurboState subclass: #TurboDeactivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboActivated stamp: 'AS 5/6/2023 12:21:08'!
TurboState subclass: #TurboActivated
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboState stamp: 'AS 5/6/2023 12:21:09'!
Object subclass: #TurboState
	instanceVariableNames: 'activations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Track stamp: 'AS 5/6/2023 12:21:09'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboSector stamp: 'AS 5/6/2023 12:21:09'!
Sector subclass: #TurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #NoTurboSector stamp: 'AS 5/6/2023 12:21:09'!
Sector subclass: #NoTurboSector
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Sector stamp: 'AS 5/6/2023 12:21:09'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #GrandPrix stamp: 'AS 5/6/2023 12:21:09'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneCar stamp: 'AS 5/6/2023 12:21:09'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations turboState'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneTest stamp: 'AS 5/6/2023 12:21:10'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:10'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneTest category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:10'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 4/30/2022 18:38:56'!
test01SectorLengthMustBePositive

	self 
		should: [ Sector withTurboOf: 0 * kilometer.]
		raise: Error
		withMessageText: Sector lengthMustBePositiveErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07'!
test02ACarCanNotBePlacedInAKilometerGreaterThanSectorLength

	| sector  outside car |
	
	sector _ Sector withTurboOf: 10 * kilometer.
	outside _ sector length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self 
		should: [ sector put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (sector includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:07'!
test03CarCannotActivateTurboInNonTurboSector

	| car sector |

	sector _ Sector withoutTurboOf: 10*kilometer.
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	sector atStartPut: car.
	
	self should: [ car activateTurbo ]
		raise: Error
		withExceptionDo: [ :error |
			self assert: Sector turboNotAllowedErrorDescription equals: error messageText.
			self deny: car isTurboActivated]
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:20'!
test04CarCannotActivateTurboWhenNoCarAhead

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 20 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	sector put: schumacher at: 12 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ hamilton activateTurbo]
		raise: Error - MessageNotUnderstood
		withExceptionDo: [:exception |
			self assert: Sector cannotActivateTurboWhenNoCarAheadErrorDescription equals: exception messageText. 
			self deny: hamilton isTurboActivated ]! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:26'!
test05CarCanActivateTurboWhenLessThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.95 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:35'!
test06CarCannotActivateTurboWhenMoreThanASecondBehindAnotherCar

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 300 * kilometer / hour.
	hamilton speed: 300 * kilometer / hour.
	
	sector put: schumacher at: 12.9 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self should: [schumacher activateTurbo]
		raise: Error - MessageNotUnderstood 
		withExceptionDo: [ :error |
			self 
				assert: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription 
				equals: error messageText.
			self deny: schumacher isTurboActivated]
			! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:40'!
test07TrackMustHaveSectors

	self
		should: [ Track withSectors: #() ]
		raise: Error
		withMessageText: Track mustHaveSectorsErrorDescription! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:16:46'!
test08TheLengthOfATrackShouldBeTheSumOfItsSectors

	| sectors track |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	track _ Track withSectors: sectors.
	
	self assert: 30 * kilometer equals: 	track length! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:23:36'!
test09ACarCanNotBePlacedInAKilometerGreaterThanTrackLength

	| sectors track car outside |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	outside _ track length + (1 * millimeter).
	car _ FormulaOneCar drivenBy: #Schumacher.
	
	self should: [ track put: car at: outside ] 
		raise: Error
		withExceptionDo: [ :error |
			self assert: Track cannotPlacedCarErrorDescription equals: error messageText.
			self deny: (track includes: car) ]	
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:24:51'!
test10TrackShouldPlaceCarInKilometerWithinSector

	| sectors track car positionInTrack positionInSector2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	positionInSector2 _ 5 * kilometer.
	positionInTrack _ sectors first length + positionInSector2.
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: positionInTrack.
	
	self assert: sectors second equals: (track sectorOf: car).
	self assert: positionInTrack equals: (track positionOf: car).
	
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:15'!
test11TrackShouldKnowCarsInRunning

	| sectors track car1 car2 |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
		
	track _ Track withSectors: sectors.
	car1 _ FormulaOneCar drivenBy: #Schumacher.
	car2 _ FormulaOneCar drivenBy: #Verstappen.

	track put: car1 at: 10 * kilometer.
	track put: car2 at: 30 * kilometer.
	
	self assert: (track includes: car1).
	self assert: (track includes: car2).
		
	self assert: (sectors first includes: car1).
	self assert: (sectors second includes: car2).

! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:25:37'!
test12CarCannotBeInMoreThanOneSectorAtATime

	| sectors track car |
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	track _ Track withSectors: sectors.
	car _ FormulaOneCar drivenBy: #Schumacher.

	track put: car at: 5 * kilometer.
	track put: car at: 15 * kilometer.
	
	self assert: sectors second equals: (track sectorOf: car).
	self deny: (sectors first includes: car).
	self assert: (sectors second includes: car)
! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:26:29'!
test13GrandPrixLengthShouldBeTrackLengthTimesNumberOfLaps

	| track grandPrix numberOfLaps |
	
	track _ Track withSectors: (OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer)).
	numberOfLaps _ 100.
	
	grandPrix _ GrandPrix on: track running: numberOfLaps.
	
	self assert: track length * numberOfLaps	 equals: grandPrix length
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:14'!
test14TwoCarsCanBeAtTheSameDistanceFromStart

	| grandPrix hamilton verstappen |
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100.
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.	
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix put: hamilton at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert:  5 * kilometer equals: (grandPrix locationOf: hamilton). 
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:18'!
test15ACarStoppedShouldNotMoveAfterSomeTime

	| grandPrix verstappen |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0 * kilometer / hour.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: (Sector withTurboOf: 10 * kilometer)))
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 5 * kilometer.
	grandPrix advance: 10 * minute.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen) 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:27:57'!
test16ACarSpeedingShouldMoveAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	verstappen speed: 0* kilometer / hour.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
	
	grandPrix put: verstappen at: 0 * kilometer.
	verstappen speed: 300 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 300 * kilometer equals: (grandPrix locationOf: verstappen). 
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:28:20'!
test17GrandPrixKnowsSectorOfCar

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 5 * kilometer.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:29:34'!
test18GrandPrixKnowsSectorOfCarAfterSomeTime

	| grandPrix verstappen sectors |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	
	sectors _ OrderedCollection 
		with: (Sector withTurboOf: 10 * kilometer)
		with: (Sector withoutTurboOf: 20 * kilometer).
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: sectors)
		running: 100
		with: (Set with: verstappen).
		
	grandPrix put: verstappen at: 0 * kilometer.
	
	verstappen speed: 5 * kilometer / hour. ":)"
	grandPrix advance: 1 * hour.
	
	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectors first equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 09:17:40'!
test19GrandPrixMovesCarsBetweenSectors

	| grandPrix verstappen sectorA sectorB |
	
	verstappen _ FormulaOneCar drivenBy: #Verstappen.
	sectorA _ Sector withTurboOf: 10 * kilometer.
	sectorB _ Sector withTurboOf: 30 * kilometer.
	
	grandPrix _ GrandPrix 
		on: (Track withSectors: (OrderedCollection with: sectorA with: sectorB))
		running: 100
		with: (Set new add: verstappen; yourself).
		
	grandPrix put: verstappen at: 5 * kilometer.

	self assert: 5 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorA equals: (grandPrix sectorOf: verstappen).
	
	verstappen speed: 15 * kilometer / hour.
	grandPrix advance: 1 * hour.
	
	self assert: 20 * kilometer equals: (grandPrix locationOf: verstappen). 
	self assert: sectorB equals: (grandPrix sectorOf: verstappen).
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:48:08'!
test20FirstTurboIncrementsSpeedByTwentyPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 120 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:31'!
test21SecondTurboSpeedsByTenPercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 110 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:14:58'!
test22ThirdTurboSpeedsByFivePercent

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.
	
	self assert: schumacher isTurboActivated.
	self assert: 105 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:19:06'!
test23AfterThridTurbo_TurboIsExhausted

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	schumacher activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo; deactivateTurbo; activateTurbo.	
	
	self assert: schumacher isTurboActivated.
	self assert: 100 * kilometer / hour equals: schumacher speed.! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:24'!
test24CanNotActivateTurboWhenTurboIsActivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	schumacher activateTurbo.
	
	self 
		should: [ schumacher activateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadyActivatedErrorDescription
	
	! !
!FormulaOneTest methodsFor: 'tests' stamp: 'HAW 5/2/2022 14:24:59'!
test25CanNotDeactivateTurboWhenIsDeactivated

	| schumacher hamilton sector |
	
	sector _ Sector withTurboOf: 24 * kilometer.
	
	schumacher _ FormulaOneCar drivenBy: #Schumacher.
	hamilton _ FormulaOneCar drivenBy: #Hamilton.
	
	schumacher speed: 100 * kilometer / hour.
	hamilton speed: 100 * kilometer / hour.
	
	sector put: schumacher at: 12.99 * kilometer.
	sector put: hamilton at: 13 * kilometer.
	
	self 
		should: [ schumacher deactivateTurbo ]
		raise: Error - MessageNotUnderstood 
		withMessageText: schumacher turboAlreadydeActivatedErrorDescription
	
	! !

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:12'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #FormulaOneCar category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:12'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!FormulaOneCar methodsFor: 'initialization' stamp: 'HAW 5/2/2022 14:12:13'!
initializeDrivenBy: aDriver 

	driver _ aDriver.
	turboActivated _ false.
	turboActivations _ 0.
	speed _ 0*kilometer/hour.
	traveledDistance _ 0.
	! !
!FormulaOneCar methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:28'!
runningInGrandPrix: aGrandPrix
	
	grandPrix _ aGrandPrix! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:07'!
advance: aDistance

	traveledDistance _ traveledDistance + aDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'FRT 4/30/2022 16:33:07'!
atSector: aSector

	currentSector _ aSector.! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/2/2022 14:11:23'!
speed

	turboActivated ifTrue: [
		turboActivations = 1 ifTrue: [ ^ speed * 12 / 10 ].
		turboActivations = 2 ifTrue: [ ^ speed * 11 / 10 ].
		turboActivations = 3 ifTrue: [ ^ speed * 105 / 100 ].
	].

	^speed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 5/1/2022 17:34:26'!
speed: newSpeed

	speed _ newSpeed! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:19'!
traveledDistance

	^ traveledDistance! !
!FormulaOneCar methodsFor: 'moving' stamp: 'HAW 4/30/2022 19:15:31'!
traveledDistance: aDistance

	traveledDistance _ aDistance! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:23:56'!
activateTurbo

	turboActivated ifTrue: [ self error: self turboAlreadyActivatedErrorDescription ].
	
	currentSector activateTurboTo: self.
! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:47'!
deactivateTurbo
	
	turboActivated ifFalse: [ self error: self turboAlreadydeActivatedErrorDescription ].
	
	turboActivated _ false! !
!FormulaOneCar methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:25:13'!
turboAlreadydeActivatedErrorDescription
	
	^'Turbo is already deactivated'! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 4/30/2022 19:10:34'!
isTurboActivated
	
	^turboActivated! !
!FormulaOneCar methodsFor: 'testing' stamp: 'HAW 5/2/2022 14:23:06'!
turboAlreadyActivatedErrorDescription
	
	^'Turbo already activated'! !
!FormulaOneCar methodsFor: 'turbo-private' stamp: 'HAW 5/2/2022 14:23:47'!
activateTurboInSectorWithTurbo
	
	turboActivated _ true.
	turboActivations _ turboActivations + 1 ! !

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
FormulaOneCar class
	instanceVariableNames: ''!

!classDefinition: 'FormulaOneCar class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
FormulaOneCar class
	instanceVariableNames: ''!
!FormulaOneCar class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 18:44:15'!
drivenBy: aDriver 

	^self new initializeDrivenBy: aDriver ! !

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #GrandPrix category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!GrandPrix methodsFor: 'initialization' stamp: 'FRT 5/1/2022 11:26:39'!
initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars

	track _ aTrack.
	numberOfLaps _ aNumberOfLaps.
	aCollectionOfCars do: [ :car | car runningInGrandPrix: self ].
! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 22:23:59'!
locationOf: aCar

	^ aCar traveledDistance.	! !
!GrandPrix methodsFor: 'car position' stamp: 'HAW 4/30/2022 19:15:32'!
put: aCar at: aDistance

	| distanceInTrack |
	
	aCar traveledDistance: aDistance.
	
	distanceInTrack _ aDistance \\ track length.
	track put: aCar at: distanceInTrack.
	! !
!GrandPrix methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:38:16'!
sectorOf: aCar 

	^ track sectorOf: aCar.! !
!GrandPrix methodsFor: 'length' stamp: 'HAW 4/30/2022 18:43:17'!
length

	^ track length * numberOfLaps! !
!GrandPrix methodsFor: 'simulation' stamp: 'FRT 5/1/2022 09:06:07'!
advance: aTimeLapse
	
	| ix cars |
	
	cars _ track cars asOrderedCollection.
	ix _ 1.
	[ix <= cars size] whileTrue: [ | car |
		car _ cars at: ix.
		self relocate: car after: aTimeLapse.
		ix _ ix + 1.
	]
! !
!GrandPrix methodsFor: 'simulation' stamp: 'HAW 5/1/2022 17:35:43'!
relocate: aCar after: aTimeLapse 

	| distanceMoved distanceInTrack |
	
	distanceMoved _ aCar speed * aTimeLapse.
	aCar advance: distanceMoved.
	
	distanceInTrack _ aCar traveledDistance \\ track length.
	track put: aCar at: distanceInTrack.! !

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
GrandPrix class
	instanceVariableNames: ''!

!classDefinition: 'GrandPrix class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
GrandPrix class
	instanceVariableNames: ''!
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:05'!
on: aTrack running: aNumberOfLaps 

	^self on: aTrack running: aNumberOfLaps with: #()! !
!GrandPrix class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 19:36:16'!
on: aTrack running: aNumberOfLaps with: aCollectionOfCars

	^self new initializeWithTrack: aTrack andNumberOfLaps: aNumberOfLaps andCars: aCollectionOfCars! !
!GrandPrix class methodsFor: 'error message' stamp: 'ARM 4/28/2022 15:09:05'!
distanceOutSideRaceTrackLengthErrorMessage

	^'Distance outside Race Track length'! !
!GrandPrix class methodsFor: 'error message' stamp: 'FRT 5/1/2022 12:24:57'!
turboNotAllowedWithRainTiresErrorMessage

	^ 'Turbo not allowed with rain tires'! !

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Sector category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:13'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 10:02:21'!
initializeOf: aLength 

	cars _ Dictionary new.
	length _ aLength.! !
!Sector methodsFor: 'initialization' stamp: 'FRT 5/1/2022 09:59:49'!
withTurbo: aBoolean
 
	withTurbo _ aBoolean.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55'!
assertValidPosition: aPosition

	length < aPosition ifTrue: [ self error: self class cannotPlacedCarErrorDescription ]! !
!Sector methodsFor: 'car position' stamp: 'HAW 5/1/2022 16:59:05'!
atStartPut: aCar
 
	self put: aCar at: 0*kilometer! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 09:23:35'!
positionOf: aCar
 
	^ cars at: aCar.
! !
!Sector methodsFor: 'car position' stamp: 'FRT 5/1/2022 14:13:55'!
put: aCar at: aPosition
 
	self assertValidPosition: aPosition.
	
	cars at: aCar put: aPosition.
	aCar atSector: self.! !
!Sector methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:04:40'!
remove: aCar
 
	cars removeKey: aCar ifAbsent: [].
! !
!Sector methodsFor: 'accessing' stamp: 'FRT 4/30/2022 22:08:51'!
cars
	
	^ cars keys! !
!Sector methodsFor: 'accessing' stamp: 'HAW 5/2/2022 14:26:16'!
length

	^length! !
!Sector methodsFor: 'testing' stamp: 'HAW 5/1/2022 16:54:33'!
includes: aCar

	^ cars includesKey: aCar! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:21:14'!
activateTurboTo: aCarToActivateTurboTo

	| positionOfCarAhead |

	withTurbo ifFalse: [	self error: Sector turboNotAllowedErrorDescription].
	
	positionOfCarAhead _ self 
		positionOfCarAheadOf: aCarToActivateTurboTo 
		ifNone: [self error: Sector cannotActivateTurboWhenNoCarAheadErrorDescription ].
		
	self 
		assertDriverIsOneSecondOrLess: aCarToActivateTurboTo
		ofDriverAt: positionOfCarAhead.

	aCarToActivateTurboTo activateTurboInSectorWithTurbo
! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:07:54'!
assertDriverIsOneSecondOrLess: aCarToActivateTurboTo ofDriverAt: positionOfCarAhead

	| carAhead |
	
	carAhead _ self carAtPosition: positionOfCarAhead.
	
	((positionOfCarAhead / carAhead speed) -
	((cars at: aCarToActivateTurboTo) / aCarToActivateTurboTo speed)) < (1 * second)
		ifFalse: [self error: Sector cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription ].! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:06:52'!
carAtPosition: positionOfDriver

	^cars keyAtValue: positionOfDriver! !
!Sector methodsFor: 'turbo' stamp: 'HAW 5/2/2022 14:08:13'!
positionOfCarAheadOf: aCarToActiveTurboTo ifNone: alternativeClosure

	| sortedPositions carToActivateTurboToPosition |
	
	carToActivateTurboToPosition _ cars at: aCarToActiveTurboTo.
	sortedPositions _ cars asSortedCollection remove: carToActivateTurboToPosition; yourself.
	 
	^ sortedPositions 
		detect: [:aPosition | aPosition > carToActivateTurboToPosition ]
		ifNone: alternativeClosure ! !

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:14'!
Sector class
	instanceVariableNames: ''!

!classDefinition: 'Sector class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:14'!
Sector class
	instanceVariableNames: ''!
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:32'!
withTurboOf: aLength 

	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.

	^ self new initializeOf: aLength; withTurbo: true; yourself ! !
!Sector class methodsFor: 'instance creation' stamp: 'HAW 5/2/2022 14:05:47'!
withoutTurboOf: aLength 
	
	aLength strictlyPositive ifFalse: [ self error: self lengthMustBePositiveErrorDescription ]	.
		
	^ self new initializeOf: aLength; withTurbo: false; yourself ! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:24:41'!
cannotActivateTurboWhenMoreThanASecondBehindAnotherCarErrorDescription
	
	^ 'Cannot activate Turbo when opponent is more than 1 second ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 20:13:07'!
cannotActivateTurboWhenNoCarAheadErrorDescription
	
	^ 'Cannot activate Turbo without opponent ahead'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 10:08:26'!
cannotPlacedCarErrorDescription

	^ 'Driver can not be placed outside section'! !
!Sector class methodsFor: 'error message' stamp: 'HAW 4/30/2022 17:05:20'!
lengthMustBePositiveErrorDescription

	^ 'Length must be positive'! !
!Sector class methodsFor: 'error message' stamp: 'FRT 4/30/2022 09:54:45'!
turboNotAllowedErrorDescription
	
	^ 'Turbo not allowed in this Sector'! !

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:15'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classDefinition: #Track category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:15'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!
!Track methodsFor: 'initialization' stamp: 'HAW 4/30/2022 17:06:50'!
initializeWithSectors: aSectors

	sectors _ aSectors copy.! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18'!
carNotFoundErrorDescription

	^ 'Car not found'! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:03'!
positionOf: aCar
	| accumulatedLength ix sector |
	
	ix _ 1.
	sector _ (sectors at: ix).
	accumulatedLength _ 0 * kilometer.

	[sector includes: aCar] whileFalse: [
		accumulatedLength _ accumulatedLength + sector length.
		ix _ ix + 1.
		sector _ (sectors at: ix).
	].

	^ accumulatedLength + (sector positionOf: aCar).! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:26:38'!
put: aCar at: aPosition

	| ix sector acc |
	
	aPosition > self length ifTrue: [ self error: self class cannotPlacedCarErrorDescription ].

	self remove: aCar.

	ix _ 1.
	sector _ sectors at: ix. 
	acc _ 0 * kilometer.

	[aPosition > (acc +  sector length)] whileTrue: [
		acc _ acc + sector length.
		ix _ ix + 1.
		sector _ sectors at: ix.
	].

	sector put: aCar at: aPosition - acc.! !
!Track methodsFor: 'car position' stamp: 'FRT 4/30/2022 15:15:27'!
remove: aCar
	
	| currentSector |
	
	currentSector _ self sectorOf: aCar ifNone: [ ^ self ].
	currentSector remove: aCar.
	! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:10:18'!
sectorOf: aCar
	
	^self sectorOf: aCar ifNone: [ self error: self carNotFoundErrorDescription ]! !
!Track methodsFor: 'car position' stamp: 'HAW 5/2/2022 14:09:47'!
sectorOf: aCar ifNone: aBlock

	 | ix |
	
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | sector |
		sector _	sectors at: ix.
		(sector includes: aCar) ifTrue: [ ^ sector ].
		ix _ ix + 1.
	].

	^ aBlock value.! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:10:09'!
cars
	| allCars ix |
	
	allCars _ Set new.
	ix _ 1.
	[ix <= sectors size] whileTrue: [ | s |
		s _ sectors at: ix.
		allCars addAll: s cars.
		ix _ ix + 1.
	].

	^ allCars
	! !
!Track methodsFor: 'accessing' stamp: 'FRT 5/1/2022 09:31:32'!
length

	| acc ix |

	acc _ 0 * kilometer.
	ix _ 1.
	
	[ix <= sectors size] whileTrue: [ | sector |
		sector _ sectors at: ix.
		acc _ acc + sector length.
		ix _ ix + 1.		
	].

	^ acc.
! !
!Track methodsFor: 'testing' stamp: 'FRT 5/1/2022 09:26:52'!
includes: aCar
	"Returns if any of the sectors includes aCar"
	
	| inc ix sector |
	inc _ false.
	ix _ 1.
	
	(sectors size = 0) ifTrue: [ ^ inc ].
	
	sector _ sectors at: ix.
	(sector includes: aCar) 
		ifTrue: [ inc _ true]
		ifFalse: [
			ix _ ix +1.
			[ix <= sectors size] whileTrue: [ | s |
				s _ sectors at: ix.
				(s includes: aCar) ifTrue: [ ^ true ].
				ix _ ix + 1
			]	
		]. 
	^ inc
	! !

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:15'!
Track class
	instanceVariableNames: ''!

!classDefinition: 'Track class' category: 'ISW1-2022-1C-Parcial-1' stamp: 'AS 5/6/2023 12:21:15'!
Track class
	instanceVariableNames: ''!
!Track class methodsFor: 'instance creation' stamp: 'HAW 4/30/2022 17:10:08'!
withSectors: sectors

	sectors isEmpty ifTrue: [ self error: self mustHaveSectorsErrorDescription ].
	
	^ self new initializeWithSectors: sectors! !
!Track class methodsFor: 'error messages' stamp: 'FRT 4/29/2022 18:22:32'!
cannotPlacedCarErrorDescription

	^ 'Car cannot be placed in track'! !
!Track class methodsFor: 'error messages' stamp: 'HAW 4/30/2022 17:09:27'!
mustHaveSectorsErrorDescription

	^'Track must have sectors'! !

!classRemoval: #Track stamp: 'AS 5/6/2023 12:22:11'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Sector stamp: 'AS 5/6/2023 12:22:11'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #GrandPrix stamp: 'AS 5/6/2023 12:22:11'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneCar stamp: 'AS 5/6/2023 12:22:11'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneTest stamp: 'AS 5/6/2023 12:22:12'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Tree stamp: 'AS 5/6/2023 12:22:18'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Empty stamp: 'AS 5/6/2023 12:22:18'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Diggable stamp: 'AS 5/6/2023 12:22:18'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Terrain stamp: 'AS 5/6/2023 12:22:18'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #SimplePirate stamp: 'AS 5/6/2023 12:22:19'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Captain stamp: 'AS 5/6/2023 12:22:19'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #PirateRank stamp: 'AS 5/6/2023 12:22:19'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Filibustero stamp: 'AS 5/6/2023 12:22:19'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Corsario stamp: 'AS 5/6/2023 12:22:19'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Bucanero stamp: 'AS 5/6/2023 12:22:19'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Pirate stamp: 'AS 5/6/2023 12:22:19'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Map stamp: 'AS 5/6/2023 12:22:20'!
Object subclass: #Map
	instanceVariableNames: 'island startPosition steps treasureMarkPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Island stamp: 'AS 5/6/2023 12:22:20'!
Object subclass: #Island
	instanceVariableNames: 'boardSize treesAt digsAt crewAt treasureAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Crew stamp: 'AS 5/6/2023 12:22:20'!
Object subclass: #Crew
	instanceVariableNames: 'island pirates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #CrewTest stamp: 'AS 5/6/2023 12:22:20'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1 treePosition1 island1 map1 crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #ResidentialZone stamp: 'AS 5/6/2023 12:22:24'!
Zone subclass: #ResidentialZone
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #IndustrialZone stamp: 'AS 5/6/2023 12:22:25'!
Zone subclass: #IndustrialZone
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #CommertialZone stamp: 'AS 5/6/2023 12:22:25'!
Zone subclass: #CommertialZone
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #Zone stamp: 'AS 5/6/2023 12:22:25'!
Object subclass: #Zone
	instanceVariableNames: 'numberOfCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #WaterTower stamp: 'AS 5/6/2023 12:22:25'!
Service subclass: #WaterTower
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #SolarPlant stamp: 'AS 5/6/2023 12:22:25'!
Service subclass: #SolarPlant
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #Service stamp: 'AS 5/6/2023 12:22:25'!
Object subclass: #Service
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #City stamp: 'AS 5/6/2023 12:22:25'!
Object subclass: #City
	instanceVariableNames: 'zones name services'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #CityTest stamp: 'AS 5/6/2023 12:22:26'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWaterConsumption commertialZoneEnergyConsumption commertialZoneWaterConsumption industrialZoneEnergyConsumption industrialZoneWaterConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

----End fileIn of E:\ISW1\Parciales\2020\1C\Primer Parcial\ISW1-2020-1C-Parcial-Enunciado.st----!

Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 14:20:51'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #WorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 14:21:05'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #SensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 14:21:15'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #MechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 14:21:22'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #OutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 14:21:29'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!Robot methodsFor: 'initialization' stamp: 'AS 5/6/2023 14:22:58' prior: 50691218!
initializeWith: aTrailer

	trailer := aTrailer.
	status := WorkingNormal new.
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 14:23:04' prior: 50691200!
outOfOrder

	status := OutOfOrder new.
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 14:23:10' prior: 50691204!
withMechanicalFailure

	status := MechanicalFailure new.
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 14:23:17' prior: 50691208!
withSensorsFailure

	status := SensorsFailure new.
! !
!RobotStatus methodsFor: 'no messages' stamp: 'AS 5/6/2023 14:24:34'!
type
	
	self subclassResponsibility ! !
!MechanicalFailure methodsFor: 'no messages' stamp: 'AS 5/6/2023 14:24:51' overrides: 50691522!
type
	
	^#MechanicalFailure! !
!OutOfOrder methodsFor: 'no messages' stamp: 'AS 5/6/2023 14:25:03' overrides: 50691522!
type
	
	^#OutOfOrder! !
!SensorsFailure methodsFor: 'no messages' stamp: 'AS 5/6/2023 14:25:14' overrides: 50691522!
type
	
	^#SensorsFailure! !
!WorkingNormal methodsFor: 'no messages' stamp: 'AS 5/6/2023 14:25:24' overrides: 50691522!
type
	
	^#WorkingNormal! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 14:26:01' prior: 50691177!
closeOrderUsing: aCashier
	
	status type = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	status type = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status type = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	status type = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 14:26:15' prior: 50691189!
take: aProduct

	status type = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	status type = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	status type = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	status type = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'AS 5/6/2023 14:26:22'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'AS 5/6/2023 14:26:22'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'AS 5/6/2023 14:26:22'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'AS 5/6/2023 14:26:22'!
PASSED!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 5/6/2023 14:26:26'!
FAILURE!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 5/6/2023 14:26:26'!
FAILURE!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 5/6/2023 14:26:26'!
FAILURE!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 5/6/2023 14:26:26'!
FAILURE!

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 5/6/2023 14:26:29'!
FAILURE!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 14:27:35'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 14:27:35'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:27:35'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:27:35'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 14:27:35'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:27:35'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:27:35'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:27:35'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 14:27:35'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:27:46'!
ERROR!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'AS 5/6/2023 14:28:27'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 14:28:30'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 14:28:30'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:28:30'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:28:30'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 14:28:30'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:28:30'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:28:30'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:28:30'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 14:28:30'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:28:34'!
ERROR!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 14:32:07'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 14:32:07'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:32:07'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:32:07'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 14:32:07'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:32:07'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:32:07'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:32:07'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 14:32:07'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:32:15'!
ERROR!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 14:33:16' prior: 50691543!
closeOrderUsing: aCashier
	
	(status type) = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	(status type) = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	(status type) = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	(status type) = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:33:20'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:33:21'!
FAILURE!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:33:38'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:33:40'!
ERROR!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:33:45'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 14:33:50'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 14:33:50'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:33:50'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:33:50'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 14:33:50'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:33:50'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 14:33:50'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 14:33:50'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 14:33:50'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 14:33:56'!
ERROR!

status type!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 5/6/2023 16:54:13' prior: 50690971!
receiveOrder: aRobot
	
	aRobot status type = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 16:54:15'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 16:54:17'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 16:54:17'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 16:54:17'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 16:54:18'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 16:54:18'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 16:54:18'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 16:54:18'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 16:54:18'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 16:54:18'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 16:54:18'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 16:54:19'!
FAILURE!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 5/6/2023 16:55:27' prior: 50691806!
receiveOrder: aRobot
	
	aRobot status type = #WorkingNormal ifTrue: [ | aTrailer | 
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
		^ true
	].

	aRobot status type = #SensorsFailure ifTrue: [ 	
		aRobot outOfOrder.
		self signalRobotSensorsFailure
	].
	
	aRobot status type = #MechanicalFailure ifTrue: [ | aTrailer |
		aRobot outOfOrder.
		
		aTrailer := aRobot trailer.	
		self assertTrailerNotEmpty: aTrailer.
		
		"Comentario: en este punto el cashier realizaría el checkout de los productos."

		^ true
	].
! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 16:55:34'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 16:55:34'!
PASSED!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:01:56' prior: 50691741!
closeOrderUsing: aCashier
	
	status closeOrderFrom: self using: aCashier.

! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:02:03'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:02:03'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:02:03'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:02:03'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:02:03'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:02:03'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:02:03'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:02:03'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:02:03'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:02:05'!
ERROR!
!WorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:02:12'!
closeOrderFrom: aRobot using: aCashier 
	self shouldBeImplemented.! !
!WorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:04:28' prior: 50691961!
closeOrderFrom: aRobot using: aCashier 

	aRobot workingNormalCloseOrderUsing: aCashier.
! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:04:32'!
ERROR!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:04:41'!
workingNormalCloseOrderUsing: aCashier 
	self shouldBeImplemented.! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:05:37' prior: 50691975!
workingNormalCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromWorkingNormalRobot: self
! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:05:43'!
ERROR!
!Cashier methodsFor: 'closing buy order' stamp: 'AS 5/6/2023 17:06:35'!
receiveOrderFromNormalWorkingRobot: aRobot
	
	| aTrailer | 
	
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizaría el checkout de los productos."
		
	^ true! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 5/6/2023 17:06:37'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 5/6/2023 17:06:37'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 5/6/2023 17:06:37'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 5/6/2023 17:06:37'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:06:40'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:06:40'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:06:40'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:06:40'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:06:40'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:06:40'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:06:40'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:06:40'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:06:40'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:06:42'!
ERROR!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:07:42' prior: 50691980!
workingNormalCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromNormalWorkingRobot: self
! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:07:50'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:07:50'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:07:50'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:07:50'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:07:50'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:07:50'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:07:50'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:07:50'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:07:50'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:07:54'!
ERROR!
!MechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:09:16'!
closeOrderFrom: aRobot using: aCashier 

	aRobot mechanicalFailureCloseOrderUsing: aCashier.
! !
!OutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:09:34'!
closeOrderFrom: aRobot using: aCashier 

	aRobot outOfOrderCloseOrderUsing: aCashier.
! !
!SensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:09:49'!
closeOrderFrom: aRobot using: aCashier 

	aRobot sensorsFailureCloseOrderUsing: aCashier.
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:10:10'!
mechanicalFailureCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromNormalWorkingRobot: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:10:26' prior: 50692104!
mechanicalFailureCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromMechanicalFailureRobot: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:10:53'!
sensorsFailureCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromNSensorsFailureRobot: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:11:23'!
outOfOrderCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromOutOfOrderRobot: self
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:11:29' prior: 50692116!
sensorsFailureCloseOrderUsing: aCashier 

	^ aCashier receiveOrderFromSensorsFailureRobot: self
! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 5/6/2023 17:12:06'!
receiveOrderFromSensorsFailureRobot: aRobot
	
	aRobot outOfOrder.
	self signalRobotSensorsFailure! !
!Cashier methodsFor: 'closing buy order' stamp: 'AS 5/6/2023 17:12:40'!
receiveOrderFromMechanicalFailureRobot: aRobot
	
	| aTrailer |
	
	aRobot outOfOrder.
		
	aTrailer := aRobot trailer.	
	self assertTrailerNotEmpty: aTrailer.
		
	"Comentario: en este punto el cashier realizaría el checkout de los productos."

	^ true! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:13:27' prior: 50692122!
outOfOrderCloseOrderUsing: aCashier 

	^ self class signalOutOfOrder
! !

!testRun: #CashierTest #test01ShouldNotAcceptEmptyTrailerFromNormalWorkingRobot stamp: 'AS 5/6/2023 17:13:34'!
PASSED!

!testRun: #CashierTest #test02ShouldNotAcceptEmptyTrailerFromMechanicalFailureRobot stamp: 'AS 5/6/2023 17:13:34'!
PASSED!

!testRun: #CashierTest #test03ShouldNotAcceptSensorsFailureRobot stamp: 'AS 5/6/2023 17:13:34'!
PASSED!

!testRun: #CashierTest #test04ShouldChangeRobotStatusToOutOfOrderWhenMechanicalFailureRobot stamp: 'AS 5/6/2023 17:13:34'!
PASSED!

!testRun: #ProductTest #test01CanNotCreateProductWithCeroOrLessWeight stamp: 'AS 5/6/2023 17:13:37'!
PASSED!

!testRun: #ProductTest #test02CanNotCreateProductWithCeroOrLessHeight stamp: 'AS 5/6/2023 17:13:37'!
PASSED!

!testRun: #ProductTest #test03CanNotCreateProductWithNoIntegerWeight stamp: 'AS 5/6/2023 17:13:37'!
PASSED!

!testRun: #ProductTest #test04CanNotCreateProductWithNoIntegerHeight stamp: 'AS 5/6/2023 17:13:37'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:13:41'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:13:41'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:13:41'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:13:43'!
ERROR!

aRobot status!
!WorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:15:11' prior: 50691967!
closeOrderFrom: aRobot using: aCashier 

	^aRobot workingNormalCloseOrderUsing: aCashier.
! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:15:12'!
ERROR!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:15:50' prior: 50691922!
closeOrderUsing: aCashier
	
	^status closeOrderFrom: self using: aCashier.

! !

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:15:53'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:15:55'!
ERROR!
!MechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:16:19' prior: 50692087!
closeOrderFrom: aRobot using: aCashier 

	^ aRobot mechanicalFailureCloseOrderUsing: aCashier.
! !

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:16:20'!
PASSED!

!testRun: #TrailerTest #test01CanNotCreateTrailerWithCeroOrLessMaxWeight stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test02CanNotCreateTrailerWithCeroOrLessMaxHeight stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test03CanNotCreateTrailerWithNoIntegerMaxWeight stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test04CanNotCreateTrailerWithNoIntegerMaxHeight stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test05ShouldRejectProductAIfWeightExceeded stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test06ShouldRejectProductBIfWeightExceeded stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test07ShouldAcceptProductsIfWeightUnderMaxWeightCapacity stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test08ShouldAcceptProductsIfWeightEqualsMaxWeightCapacity stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test09ShouldAcceptProductAIgnoringMaxTotalHeightOfBProducts stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test10ShouldIgnoreAProductsInMaxTotalHeightOfBProducts stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!testRun: #TrailerTest #test11ShouldRejectProductBExceedingMaxTotalHeightOfBProducts stamp: 'AS 5/6/2023 17:16:32'!
PASSED!

!classRemoval: #Trailer stamp: 'AS 5/6/2023 17:20:42'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #WorkingNormal stamp: 'AS 5/6/2023 17:20:42'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #SensorsFailure stamp: 'AS 5/6/2023 17:20:42'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #OutOfOrder stamp: 'AS 5/6/2023 17:20:42'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #MechanicalFailure stamp: 'AS 5/6/2023 17:20:43'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatus stamp: 'AS 5/6/2023 17:20:43'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/6/2023 17:20:43'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/6/2023 17:20:43'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/6/2023 17:20:43'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/6/2023 17:20:43'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/6/2023 17:20:43'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/6/2023 17:20:44'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/6/2023 17:20:44'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/6/2023 17:20:44'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/6/2023 17:20:44'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

----End fileIn of E:\ISW1\Parciales\2020\1C\Primer Parcial\ISW1-2020-1C-Parcial-Enunciado.st----!

Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:21:49'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #WorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:22:03'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #MechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:22:11'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #SensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:22:17'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #OutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:22:27'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotStatus methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:23:32'!
type
	
	self subclassResponsibility ! !
!MechanicalFailure methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:23:55' overrides: 50693345!
type
	
	^MechanicalFailure! !
!MechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:24:05' prior: 50693350 overrides: 50693345!
type
	
	^#MechanicalFailure! !
!OutOfOrder methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:24:30' overrides: 50693345!
type
	
	^#OutOforder! !
!SensorsFailure methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:24:40' overrides: 50693345!
type
	
	^#SensorsFailure! !
!WorkingNormal methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:24:50' overrides: 50693345!
type
	
	^#WorkingNormal! !
!Robot methodsFor: 'accessing' stamp: 'AS 5/6/2023 17:25:01' prior: 50693053!
status

	^ status type
! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:25:03'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:25:03'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:25:03'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:25:03'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:25:03'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:25:03'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:25:03'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:25:03'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:25:03'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:25:10'!
ERROR!
!Robot methodsFor: 'initialization' stamp: 'AS 5/6/2023 17:25:51' prior: 50693059!
initializeWith: aTrailer

	trailer := aTrailer.
	status := WorkingNormal new.
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 17:25:58' prior: 50693041!
outOfOrder

	status := OutOfOrder new
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 17:26:04' prior: 50693045!
withMechanicalFailure

	status := MechanicalFailure new
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 17:26:09' prior: 50693049!
withSensorsFailure

	status := SensorsFailure new
! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:26:14'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:26:14'!
FAILURE!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:26:14'!
FAILURE!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:26:14'!
FAILURE!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:26:14'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:26:14'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:26:14'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:26:14'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:26:14'!
FAILURE!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:26:17'!
FAILURE!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:27:58' prior: 50693018!
closeOrderUsing: aCashier
	
	self status = #WorkingNormal ifTrue: [ ^ aCashier receiveOrder: self ].
	self status = #SensorsFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	self status = #MechanicalFailure ifTrue: [ ^ aCashier receiveOrder: self ].
	self status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:28:10' prior: 50693030!
take: aProduct

	self status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	self status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	self status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	self status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:28:14'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:28:14'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:28:14'!
FAILURE!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:29:27'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:29:27'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:29:28'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:29:28'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:29:28'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:29:28'!
PASSED!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:29:28'!
PASSED!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:29:28'!
PASSED!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:29:28'!
FAILURE!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:29:30'!
FAILURE!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:30:21'!
FAILURE!

!classRemoval: #Trailer stamp: 'AS 5/6/2023 17:31:04'!
Object subclass: #Trailer
	instanceVariableNames: 'weightCapacity heightCapacity container'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #WorkingNormal stamp: 'AS 5/6/2023 17:31:04'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #SensorsFailure stamp: 'AS 5/6/2023 17:31:04'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #OutOfOrder stamp: 'AS 5/6/2023 17:31:04'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #MechanicalFailure stamp: 'AS 5/6/2023 17:31:05'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotStatus stamp: 'AS 5/6/2023 17:31:05'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Robot stamp: 'AS 5/6/2023 17:31:05'!
Object subclass: #Robot
	instanceVariableNames: 'status trailer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductB stamp: 'AS 5/6/2023 17:31:05'!
Product subclass: #ProductB
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductA stamp: 'AS 5/6/2023 17:31:05'!
Product subclass: #ProductA
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Product stamp: 'AS 5/6/2023 17:31:05'!
Object subclass: #Product
	instanceVariableNames: 'weight height'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #Cashier stamp: 'AS 5/6/2023 17:31:05'!
Object subclass: #Cashier
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #TrailerTest stamp: 'AS 5/6/2023 17:31:06'!
TestCase subclass: #TrailerTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #RobotTest stamp: 'AS 5/6/2023 17:31:06'!
TestCase subclass: #RobotTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #ProductTest stamp: 'AS 5/6/2023 17:31:06'!
TestCase subclass: #ProductTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classRemoval: #CashierTest stamp: 'AS 5/6/2023 17:31:06'!
TestCase subclass: #CashierTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

----End fileIn of E:\ISW1\Parciales\2020\1C\Primer Parcial\ISW1-2020-1C-Parcial-Enunciado.st----!

Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #RobotStatus category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:32:24'!
Object subclass: #RobotStatus
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #WorkingNormal category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:32:34'!
RobotStatus subclass: #WorkingNormal
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #MechanicalFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:32:39'!
RobotStatus subclass: #MechanicalFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #SensorsFailure category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:32:44'!
RobotStatus subclass: #SensorsFailure
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!

!classDefinition: #OutOfOrder category: 'ISW1-2020-1C-Parcial-Enunciado' stamp: 'AS 5/6/2023 17:32:53'!
RobotStatus subclass: #OutOfOrder
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2020-1C-Parcial-Enunciado'!
!RobotStatus methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:33:30'!
equals: aStatus
	
	self subclassResponsibility ! !
!MechanicalFailure methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:34:04' overrides: 50694607!
equals: aStatus
	
	^ aStatus = #MechanicalFailure! !
!OutOfOrder methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:34:19' overrides: 50694607!
equals: aStatus
	
	^ aStatus = #OutOfOrder! !
!SensorsFailure methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:34:30' overrides: 50694607!
equals: aStatus
	
	^ aStatus = #SensorsFailure! !
!WorkingNormal methodsFor: 'no messages' stamp: 'AS 5/6/2023 17:34:40' overrides: 50694607!
equals: aStatus
	
	^ aStatus = #WorkingNormal! !
!Robot methodsFor: 'initialization' stamp: 'AS 5/6/2023 17:35:04' prior: 50694321!
initializeWith: aTrailer

	trailer := aTrailer.
	status := WorkingNormal new.
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 17:35:10' prior: 50694303!
outOfOrder

	status := OutOfOrder new
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 17:35:16' prior: 50694307!
withMechanicalFailure

	status := MechanicalFailure new
! !
!Robot methodsFor: 'status' stamp: 'AS 5/6/2023 17:35:21' prior: 50694311!
withSensorsFailure

	status := SensorsFailure new
! !

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:35:27'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:35:27'!
FAILURE!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:35:27'!
FAILURE!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:35:27'!
FAILURE!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:35:27'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:35:27'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:35:27'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:35:27'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:35:27'!
FAILURE!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:35:31'!
FAILURE!

robot := Robot new.!

robot status = #WorkingNormal!
!MechanicalFailure methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:37:07' overrides: 16901772!
= aStatus
	
	^ aStatus = #MechanicalFailure! !
!OutOfOrder methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:37:20' overrides: 16901772!
= aStatus
	
	^ aStatus = #OutOfOrder! !
!SensorsFailure methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:37:26' overrides: 16901772!
= aStatus
	
	^ aStatus = #SensorsFailure! !
!WorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:37:32' overrides: 16901772!
= aStatus
	
	^ aStatus = #WorkingNormal! !

robot status = #WorkingNormal!
!RobotStatus methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:38:17' overrides: 16901772!
= aStatus
	
	self subclassResponsibility ! !
!RobotStatus methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:40:09' overrides: 16920284!
== aStatus
	
	self subclassResponsibility ! !
!WorkingNormal methodsFor: 'as yet unclassified' stamp: 'AS 5/6/2023 17:40:20' overrides: 50694713!
== aStatus
	
	^ aStatus = #WorkingNormal! !

robot := Robot new.!

robot status = #WorkingNormal!

!methodRemoval: RobotStatus #= stamp: 'AS 5/6/2023 17:49:21'!
= aStatus
	
	self subclassResponsibility !

!methodRemoval: RobotStatus #== stamp: 'AS 5/6/2023 17:49:26'!
== aStatus
	
	self subclassResponsibility !

!methodRemoval: RobotStatus #equals: stamp: 'AS 5/6/2023 17:49:29'!
equals: aStatus
	
	self subclassResponsibility !

!methodRemoval: MechanicalFailure #= stamp: 'AS 5/6/2023 17:49:37'!
= aStatus
	
	^ aStatus = #MechanicalFailure!

!methodRemoval: MechanicalFailure #equals: stamp: 'AS 5/6/2023 17:49:39'!
equals: aStatus
	
	^ aStatus = #MechanicalFailure!

!methodRemoval: OutOfOrder #= stamp: 'AS 5/6/2023 17:49:47'!
= aStatus
	
	^ aStatus = #OutOfOrder!

!methodRemoval: OutOfOrder #equals: stamp: 'AS 5/6/2023 17:49:49'!
equals: aStatus
	
	^ aStatus = #OutOfOrder!

!methodRemoval: SensorsFailure #= stamp: 'AS 5/6/2023 17:49:56'!
= aStatus
	
	^ aStatus = #SensorsFailure!

!methodRemoval: SensorsFailure #equals: stamp: 'AS 5/6/2023 17:49:58'!
equals: aStatus
	
	^ aStatus = #SensorsFailure!

!methodRemoval: WorkingNormal #= stamp: 'AS 5/6/2023 17:50:06'!
= aStatus
	
	^ aStatus = #WorkingNormal!

!methodRemoval: WorkingNormal #== stamp: 'AS 5/6/2023 17:50:14'!
== aStatus
	
	^ aStatus = #WorkingNormal!

!methodRemoval: WorkingNormal #equals: stamp: 'AS 5/6/2023 17:50:15'!
equals: aStatus
	
	^ aStatus = #WorkingNormal!
!Robot methodsFor: 'accessing' stamp: 'AS 5/6/2023 17:52:15' prior: 50694315!
status

	(status isKindOf: WorkingNormal) ifTrue: [^#WorkingNormal].
	(status isKindOf: MechanicalFailure) ifTrue: [^#MechanicalFailure].
	(status isKindOf: SensorsFailure) ifTrue: [^#SensorsFailure].
	(status isKindOf: OutOfOrder) ifTrue: [^#OutOfOrder].
! !

robot := Robot new.!

robot status = #WorkingNormal!

robot status = #WorkingNormal!

robot status!

robot status isKindOf: WorkingNormal!
!Robot methodsFor: 'accessing' stamp: 'AS 5/6/2023 17:54:11' prior: 50694766!
status

	^status.
	"
	(status isKindOf: WorkingNormal) ifTrue: [^#WorkingNormal].
	(status isKindOf: MechanicalFailure) ifTrue: [^#MechanicalFailure].
	(status isKindOf: SensorsFailure) ifTrue: [^#SensorsFailure].
	(status isKindOf: OutOfOrder) ifTrue: [^#OutOfOrder].
	"
! !

robot status.!

robot := Robot new.!

robot status.!

robot := Robot with: Trailer new.!

robot := Robot with: (Trailer with: 20 and: 100).!

robot status.!

robot status isKindOf: WorkingNormal!
!Robot methodsFor: 'accessing' stamp: 'AS 5/6/2023 17:56:18' prior: 50694781!
status

	(status isKindOf: WorkingNormal) ifTrue: [^#WorkingNormal].
	(status isKindOf: MechanicalFailure) ifTrue: [^#MechanicalFailure].
	(status isKindOf: SensorsFailure) ifTrue: [^#SensorsFailure].
	(status isKindOf: OutOfOrder) ifTrue: [^#OutOfOrder].

! !

robot status = #WorkingNormal!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:56:37'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:56:37'!
FAILURE!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:56:37'!
FAILURE!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:56:37'!
FAILURE!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:56:37'!
FAILURE!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:56:37'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:56:37'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:56:37'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:56:37'!
FAILURE!
!Robot methodsFor: 'actions' stamp: 'AS 5/6/2023 17:58:08' prior: 50694292!
take: aProduct

	self status = #WorkingNormal ifTrue: [ ^ trailer carry: aProduct ].
	self status = #SensorsFailure ifTrue: [ ^ trailer carry: aProduct ].
	self status = #MechanicalFailure ifTrue: [ ^ trailer carry: aProduct ].
	self status = #OutOfOrder ifTrue: [ ^ self class signalOutOfOrder ].
! !

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:58:12'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:58:15'!
PASSED!

!testRun: #RobotTest #test01ShouldReceiveAnEmptyTrailer stamp: 'AS 5/6/2023 17:58:15'!
PASSED!

!testRun: #RobotTest #test02ShouldTakeProductsWhenWorkingNormal stamp: 'AS 5/6/2023 17:58:15'!
PASSED!

!testRun: #RobotTest #test03ShouldTakeProductsWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:58:15'!
PASSED!

!testRun: #RobotTest #test04ShouldTakeProductsWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:58:15'!
PASSED!

!testRun: #RobotTest #test05ShouldNotTakeProductsWhenOutOfOrder stamp: 'AS 5/6/2023 17:58:15'!
PASSED!

!testRun: #RobotTest #test06CanCloseOrderWhenWorkingNormal stamp: 'AS 5/6/2023 17:58:15'!
ERROR!

!testRun: #RobotTest #test07CanNotCloseOrderWhenWorkingWithSensorsFailures stamp: 'AS 5/6/2023 17:58:15'!
FAILURE!

!testRun: #RobotTest #test08CanCloseOrderWhenWorkingWithMechanicalFailures stamp: 'AS 5/6/2023 17:58:15'!
ERROR!

!testRun: #RobotTest #test09CanNotCloseOrderWhenOutOfOrder stamp: 'AS 5/6/2023 17:58:15'!
FAILURE!

----STARTUP---- (17 May 2023 19:33:16) as F:\CUIS University ISW1\CuisUniversity-5706.image!


----End fileIn of E:\ISW1\Otros\Repo_TP_Exactas-main\Repo_TP_Exactas-main\ingenieria de software 1\17-Portfolio 1\Portfolio-Ejercicio-Entrega.st----!

----STARTUP---- (25 May 2023 14:51:13) as F:\CUIS University ISW1\CuisUniversity-5706.image!


!classRemoval: #Tree stamp: 'AS 5/25/2023 14:51:25'!
Terrain subclass: #Tree
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Empty stamp: 'AS 5/25/2023 14:51:25'!
Terrain subclass: #Empty
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Diggable stamp: 'AS 5/25/2023 14:51:26'!
Terrain subclass: #Diggable
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Terrain stamp: 'AS 5/25/2023 14:51:26'!
Object subclass: #Terrain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #SimplePirate stamp: 'AS 5/25/2023 14:51:26'!
PirateRank subclass: #SimplePirate
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Captain stamp: 'AS 5/25/2023 14:51:26'!
PirateRank subclass: #Captain
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #PirateRank stamp: 'AS 5/25/2023 14:51:26'!
Object subclass: #PirateRank
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Filibustero stamp: 'AS 5/25/2023 14:51:26'!
Pirate subclass: #Filibustero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Corsario stamp: 'AS 5/25/2023 14:51:27'!
Pirate subclass: #Corsario
	instanceVariableNames: 'map'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Bucanero stamp: 'AS 5/25/2023 14:51:27'!
Pirate subclass: #Bucanero
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Pirate stamp: 'AS 5/25/2023 14:51:27'!
Object subclass: #Pirate
	instanceVariableNames: 'rank'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Map stamp: 'AS 5/25/2023 14:51:27'!
Object subclass: #Map
	instanceVariableNames: 'island startPosition steps treasureMarkPosition'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Island stamp: 'AS 5/25/2023 14:51:27'!
Object subclass: #Island
	instanceVariableNames: 'boardSize treesAt digsAt crewAt treasureAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #Crew stamp: 'AS 5/25/2023 14:51:27'!
Object subclass: #Crew
	instanceVariableNames: 'island pirates'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #CrewTest stamp: 'AS 5/25/2023 14:51:27'!
TestCase subclass: #CrewTest
	instanceVariableNames: 'crewPosition1 treePosition1 island1 map1 crew1'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-2C-1erParcial'!

!classRemoval: #TurboInactive stamp: 'AS 5/25/2023 14:51:32'!
Turbo subclass: #TurboInactive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #TurboActive stamp: 'AS 5/25/2023 14:51:32'!
Turbo subclass: #TurboActive
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Turbo stamp: 'AS 5/25/2023 14:51:32'!
Object subclass: #Turbo
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Track stamp: 'AS 5/25/2023 14:51:32'!
Object subclass: #Track
	instanceVariableNames: 'sectors driversDistanceFromBeginning'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #SectorTurboNotAdmited stamp: 'AS 5/25/2023 14:51:32'!
Sector subclass: #SectorTurboNotAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #SectorTurboAdmited stamp: 'AS 5/25/2023 14:51:32'!
Sector subclass: #SectorTurboAdmited
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #Sector stamp: 'AS 5/25/2023 14:51:33'!
Object subclass: #Sector
	instanceVariableNames: 'cars length withTurbo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #GrandPrix stamp: 'AS 5/25/2023 14:51:33'!
Object subclass: #GrandPrix
	instanceVariableNames: 'track numberOfLaps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneCar stamp: 'AS 5/25/2023 14:51:33'!
Object subclass: #FormulaOneCar
	instanceVariableNames: 'grandPrix driver speed turboActivated traveledDistance currentSector turboActivations'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #FormulaOneTest stamp: 'AS 5/25/2023 14:51:33'!
TestCase subclass: #FormulaOneTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2022-1C-Parcial-1'!

!classRemoval: #ResidentialZone stamp: 'AS 5/25/2023 14:51:36'!
Zone subclass: #ResidentialZone
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #IndustrialZone stamp: 'AS 5/25/2023 14:51:36'!
Zone subclass: #IndustrialZone
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #CommertialZone stamp: 'AS 5/25/2023 14:51:37'!
Zone subclass: #CommertialZone
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #Zone stamp: 'AS 5/25/2023 14:51:37'!
Object subclass: #Zone
	instanceVariableNames: 'numberOfCells'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #WaterTower stamp: 'AS 5/25/2023 14:51:37'!
Service subclass: #WaterTower
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #SolarPlant stamp: 'AS 5/25/2023 14:51:37'!
Service subclass: #SolarPlant
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #Service stamp: 'AS 5/25/2023 14:51:37'!
Object subclass: #Service
	instanceVariableNames: 'type'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #City stamp: 'AS 5/25/2023 14:51:37'!
Object subclass: #City
	instanceVariableNames: 'zones name services'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

!classRemoval: #CityTest stamp: 'AS 5/25/2023 14:51:37'!
TestCase subclass: #CityTest
	instanceVariableNames: 'city solarPlantEnergyPoints waterTowerWaterPoints residentialZoneEnergyConsumption residentialZoneWaterConsumption commertialZoneEnergyConsumption commertialZoneWaterConsumption industrialZoneEnergyConsumption industrialZoneWaterConsumption'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'ISW1-2021-2C-1erParcial'!

----End fileIn of E:\ISW1\07-Portfolio 2\Portfolio-Solucion.st----!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 15:01:04'!
Object subclass: #Transfer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 15:00:20'!
test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue 

	| sourceAccount destinationAccount |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.
	
	Transfer register: 100 from: sourceAccount to: destinationAccount.
		
	self assert: 100 equals: destinationAccount balance .
	self assert: 100 * -1 equals: sourceAccount balance .
! !
!Transfer class methodsFor: 'no messages' stamp: 'AS 5/25/2023 15:02:28'!
for: aValue

	^ self new initializeFor: aValue ! !

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 15:05:10'!
Object subclass: #Transfer
	instanceVariableNames: 'value'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'no messages' stamp: 'AS 5/25/2023 15:05:08'!
initializeFor: aValue

	value := aValue ! !

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 15:05:54'!
ERROR!
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 15:11:03'!
register: aValue from: sourceAccount to: destinationAccount

	| deposit withdraw transfer |
	
	withdraw := Withdraw register: aValue on: sourceAccount.
	deposit := Deposit register: aValue on: destinationAccount.
	
	transfer := self for: aValue.
	
	^ transfer! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 15:11:25'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 15:11:25'!
PASSED!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 15:38:59'!
test09TransferDepositKnowsTransferWithdrawAndViceversa

	| sourceAccount destinationAccount transfer transferDeposit transferWithdraw |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.
	
	transfer := Transfer register: 100 from: sourceAccount to: destinationAccount.
	
	transferDeposit := transfer deposit.
	transferWithdraw := transfer withdraw.
		
	self assert: transferDeposit equals: transferWithdraw deposit.
	self assert: transferWithdraw equals: transferDeposit withdraw.
! !

Object subclass: #Transfer
	instanceVariableNames: 'value deposit withdraw'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Transfer category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 15:39:17'!
Object subclass: #Transfer
	instanceVariableNames: 'value deposit withdraw'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!Transfer methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 15:39:40'!
deposit
	
	^ deposit! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 15:39:49'!
withdraw
	
	^ withdraw! !
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 15:41:25' prior: 50696493!
register: aValue from: sourceAccount to: destinationAccount

	| transfer deposit withdraw |

	withdraw := Withdraw register: aValue on: sourceAccount.
	deposit := Deposit register: aValue on: destinationAccount.
	
	transfer := self for: aValue from: withdraw to: deposit.
	
	^ transfer! !
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 15:42:07'!
for: aValue from: aDeposit to: aWithdraw

	^ self new initializeFor: aValue from: aDeposit to: aWithdraw! !

!methodRemoval: Transfer class #for: stamp: 'AS 5/25/2023 15:42:15'!
for: aValue

	^ self new initializeFor: aValue !
!Transfer methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 15:42:49'!
initializeFor: aValue from: aDeposit to: aWithdraw

	deposit := aDeposit.
	withdraw := aWithdraw.
	value := aValue! !

!methodRemoval: Transfer #initializeFor: stamp: 'AS 5/25/2023 15:43:49'!
initializeFor: aValue

	value := aValue !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 15:44:03'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 15:44:04'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 15:44:04'!
ERROR!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 15:44:04'!
ERROR!

AccountTransaction subclass: #TransferDeposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferDeposit category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 15:55:25'!
AccountTransaction subclass: #TransferDeposit
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #TransferWithdraw
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferWithdraw category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 15:56:15'!
AccountTransaction subclass: #TransferWithdraw
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

AccountTransaction subclass: #TransferDeposit
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferDeposit category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 15:56:20'!
AccountTransaction subclass: #TransferDeposit
	instanceVariableNames: 'transfer'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!TransferDeposit methodsFor: 'nil' stamp: 'AS 5/25/2023 15:57:00' overrides: 50696350!
affectBalance: aBalance

	^aBalance + transfer value ! !
!TransferWithdraw methodsFor: 'no messages' stamp: 'AS 5/25/2023 15:57:11' overrides: 50696350!
affectBalance: aBalance

	^aBalance - transfer value ! !
!TransferWithdraw methodsFor: 'nil' stamp: 'AS 5/25/2023 15:57:47'!
deposit
	
	^transfer deposit! !
!TransferDeposit methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 15:58:03'!
withdraw
	
	^transfer withdraw! !
!TransferDeposit class methodsFor: 'no messages' stamp: 'AS 5/25/2023 15:59:33'!
for: aValue from: aTransfer

	^ self new initializeFor: aValue from: aTransfer! !
!TransferDeposit class methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 16:00:23'!
from: aTransfer

	^ self new initializeFrom: aTransfer! !

!methodRemoval: TransferDeposit class #for:from: stamp: 'AS 5/25/2023 16:00:32'!
for: aValue from: aTransfer

	^ self new initializeFor: aValue from: aTransfer!
!TransferDeposit methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 16:01:06'!
initializeFrom: aTransfer

	transfer := aTransfer! !
!TransferWithdraw methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 16:01:12'!
initializeFrom: aTransfer

	transfer := aTransfer! !
!TransferWithdraw class methodsFor: 'no messages' stamp: 'AS 5/25/2023 16:01:28'!
from: aTransfer

	^ self new initializeFrom: aTransfer! !
!Deposit class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:08:55' overrides: 50696364!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !
!Withdraw class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:08:55' overrides: 50696364!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !
!TransferWithdraw class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:08:56' overrides: 50696364!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !
!TransferDeposit class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:08:56' overrides: 50696364!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction! !

!methodRemoval: AccountTransaction class #register:on: stamp: 'AS 5/25/2023 16:08:56'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction!

!methodRemoval: TransferDeposit class #register:on: stamp: 'AS 5/25/2023 16:10:39'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction!

!methodRemoval: TransferWithdraw class #register:on: stamp: 'AS 5/25/2023 16:10:44'!
register: aValue on: account

	| transaction |
	
	transaction := self for: aValue.
	account register: transaction.
		
	^ transaction!
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:21:07' prior: 50696576!
register: aValue from: sourceAccount to: destinationAccount

	| transfer deposit withdraw |

	transfer := self for: aValue.
	
	withdraw := TransferWithdraw transfer: transfer on: sourceAccount.
	deposit := TransferDeposit transfer: transfer on: destinationAccount.
	
	"
	self register: transfer on sourceAccount
	transfer withdraw: self
	
	
	
	
	"
	"transfer := self for: aValue from: withdraw to: deposit."
	
	^ transfer! !
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:28:22' prior: 50696787!
register: aValue from: sourceAccount to: destinationAccount

	| transfer deposit withdraw |

	transfer := self new for: aValue.
	
	withdraw := TransferWithdraw transfer: transfer on: sourceAccount.
	deposit := TransferDeposit transfer: transfer on: destinationAccount.
	
	"
	self register: transfer on sourceAccount
	transfer withdraw: self
	
	
	
	
	"
	"transfer := self for: aValue from: withdraw to: deposit."
	
	^ transfer! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 16:28:41'!
initializeFor: aValue

	value := aValue! !

!methodRemoval: Transfer #initializeFor:from:to: stamp: 'AS 5/25/2023 16:28:47'!
initializeFor: aValue from: aDeposit to: aWithdraw

	deposit := aDeposit.
	withdraw := aWithdraw.
	value := aValue!
!TransferWithdraw class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:32:03'!
transfer: aTransfer on: anAccount

	| withdraw |
	
	withdraw := self new initializeFrom: aTransfer,
	anAccount register: withdraw! !
!TransferWithdraw class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:32:46' prior: 50696831!
transfer: aTransfer on: anAccount

	| withdraw |
	
	withdraw := self new initializeFrom: aTransfer,
	anAccount register: withdraw.
	
	^withdraw.! !
!TransferWithdraw class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:33:27' prior: 50696839!
transfer: aTransfer on: anAccount

	| transferWithdraw |
	
	transferWithdraw := self new initializeFrom: aTransfer,
	anAccount register: transferWithdraw.
	
	^transferWithdraw.! !
!TransferWithdraw class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:34:20' prior: 50696847!
transfer: aTransfer on: anAccount

	| transferWithdraw |
	
	transferWithdraw := self new initializeFrom: aTransfer.
	anAccount register: transferWithdraw.
	
	^transferWithdraw.! !
!TransferDeposit class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:35:08'!
transfer: aTransfer on: anAccount

	| transferDeposit |
	
	transferDeposit := self new initializeFrom: aTransfer.
	anAccount register: transferDeposit.
	
	^transferDeposit.! !

!methodRemoval: TransferDeposit class #from: stamp: 'AS 5/25/2023 16:35:14'!
from: aTransfer

	^ self new initializeFrom: aTransfer!

!methodRemoval: TransferWithdraw class #from: stamp: 'AS 5/25/2023 16:35:19'!
from: aTransfer

	^ self new initializeFrom: aTransfer!
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:39:10' prior: 50696804!
register: aValue from: sourceAccount to: destinationAccount

	| transfer deposit withdraw |

	transfer := self new for: aValue.
	
	withdraw := TransferWithdraw transfer: transfer on: sourceAccount.
	deposit := TransferDeposit transfer: transfer on: destinationAccount.
	
	transfer withdraw: withdraw.
	transfer deposit: deposit.
	
	^ transfer! !

!methodRemoval: Transfer class #for:from:to: stamp: 'AS 5/25/2023 16:39:17'!
for: aValue from: aDeposit to: aWithdraw

	^ self new initializeFor: aValue from: aDeposit to: aWithdraw!
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:43:48' prior: 50696882!
register: aValue from: sourceAccount to: destinationAccount

	| transfer deposit withdraw |

	transfer := self new.
	
	withdraw := TransferWithdraw transfer: transfer on: sourceAccount.
	deposit := TransferDeposit transfer: transfer on: destinationAccount.
	
	transfer for: aValue from: withdraw to: deposit.
	
	^ transfer! !
!Transfer methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 16:44:57'!
initializeFor: aValue from: aWithdraw to: aDeposit

	value := aValue.
	withdraw := aWithdraw.
	deposit := aDeposit.! !
!Transfer class methodsFor: 'instance creation' stamp: 'AS 5/25/2023 16:45:09' prior: 50696902!
register: aValue from: sourceAccount to: destinationAccount

	| transfer deposit withdraw |

	transfer := self new.
	
	withdraw := TransferWithdraw transfer: transfer on: sourceAccount.
	deposit := TransferDeposit transfer: transfer on: destinationAccount.
	
	transfer initializeFor: aValue from: withdraw to: deposit.
	
	^ transfer! !

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 16:45:20'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 16:45:57'!
ERROR!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 16:45:57'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 16:45:57'!
ERROR!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 16:46:47'!
ERROR!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 16:46:47'!
ERROR!
!Transfer methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 16:47:27' overrides: 16902254!
value
	
	^ value! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 16:47:56'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 16:47:56'!
PASSED!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 16:54:43'!
test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := account accountSummary.
	
	self assert: 1 equals: report size.	
	self assert: 'Balance = 0' equals: (report at: 1)
! !

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 16:54:50'!
ERROR!
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 16:55:31'!
accountSummary
	self shouldBeImplemented.! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 16:56:52' prior: 50697046!
accountSummary
	
	| report |
	
	report := OrderedCollection new.
	report add: 'Balance = 0'.
	
	^report
	! !

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 16:56:54'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 16:56:54'!
PASSED!
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 17:00:45'!
test11AccountSummaryWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := account accountSummary.
	
	self assert: 3 equals: report size.	
	self assert: report includes: 'Depósito por 100'.
	self assert: report includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report at: 3)
! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 17:04:42' prior: 50697051!
accountSummary
	
	| report |
	
	report := OrderedCollection new.
	
	transactions do: [ :transaction | transaction reportOn: report ].			
	report add: ('Balance = ', self balance).
	
	^report
	! !
!AccountTransaction methodsFor: 'balance' stamp: 'AS 5/25/2023 17:05:18'!
reportOn: aReport
	
	self subclassResponsibility.! !
!Deposit methodsFor: 'balance' stamp: 'AS 5/25/2023 17:06:09' overrides: 50697128!
reportOn: aReport
	
	aReport add: 'Depósito por ', value! !

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:06:20'!
ERROR!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:06:20'!
ERROR!
!Deposit methodsFor: 'balance' stamp: 'AS 5/25/2023 17:10:59' prior: 50697133 overrides: 50697128!
reportOn: aReport
	
	aReport add: 'Depósito por ', value asString.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 17:12:00'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:12:00'!
ERROR!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:12:00'!
ERROR!
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 17:13:07' prior: 50697119!
accountSummary
	
	| report |
	
	report := OrderedCollection new.
	
	transactions do: [ :transaction | transaction reportOn: report ].			
	report add: ('Balance = ', self balance asString).
	
	^report
	! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:13:14'!
PASSED!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:13:14'!
PASSED!
!Deposit methodsFor: 'balance' stamp: 'AS 5/25/2023 17:22:13' prior: 50697147 overrides: 50697128!
reportOn: aReport
	
	aReport writeDeposit: value! !

Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Report category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 17:22:38'!
Object subclass: #Report
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummary category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 17:25:01'!
Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Report subclass: #TransferNet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #TransferNet category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 17:25:10'!
Report subclass: #TransferNet
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Report subclass: #AccountSummary
	instanceVariableNames: 'lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummary category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 17:27:35'!
Report subclass: #AccountSummary
	instanceVariableNames: 'lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #AccountSummary category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 17:27:42'!
Report subclass: #AccountSummary
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

Object subclass: #Report
	instanceVariableNames: 'lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #Report category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 17:27:47'!
Object subclass: #Report
	instanceVariableNames: 'lines'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!AccountSummary class methodsFor: 'nil' stamp: 'AS 5/25/2023 17:28:39'!
on: anAccount
	
	^self new initializeOn: anAccount! !
!AccountSummary methodsFor: 'no messages' stamp: 'AS 5/25/2023 17:35:12'!
initializeOn: anAccount
	
	anAccount reportOn: self.
	
	lines add: 'Balance = ', anAccount balance asString.
	! !
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 17:35:46'!
reportOn
	
	| report |
	
	report := OrderedCollection new.
	
	transactions do: [ :transaction | transaction reportOn: report ].			
	report add: ('Balance = ', self balance asString).
	
	^report
	! !

!methodRemoval: ReceptiveAccount #accountSummary stamp: 'AS 5/25/2023 17:35:46'!
accountSummary
	
	| report |
	
	report := OrderedCollection new.
	
	transactions do: [ :transaction | transaction reportOn: report ].			
	report add: ('Balance = ', self balance asString).
	
	^report
	!
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 17:36:02'!
reportOn: aReport
	
	| report |
	
	report := OrderedCollection new.
	
	transactions do: [ :transaction | transaction reportOn: report ].			
	report add: ('Balance = ', self balance asString).
	
	^report
	! !

!methodRemoval: ReceptiveAccount #reportOn stamp: 'AS 5/25/2023 17:36:06'!
reportOn
	
	| report |
	
	report := OrderedCollection new.
	
	transactions do: [ :transaction | transaction reportOn: report ].			
	report add: ('Balance = ', self balance asString).
	
	^report
	!
!ReceptiveAccount methodsFor: 'reports' stamp: 'AS 5/25/2023 17:36:32' prior: 50697353!
reportOn: aReport
	
	transactions do: [ :transaction | transaction reportOn: aReport ].			
	! !
!AccountSummary methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 17:37:32'!
writeDeposit: aValue

	lines add: 'Depósito = ', aValue asString.! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 17:38:09' prior: 50697031!
test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report size.	
	self assert: 'Balance = 0' equals: (report at: 1)
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 17:39:01' prior: 50697102!
test11AccountSummaryWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report includes: 'Depósito por 100'.
	self assert: report includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report at: 3)
! !
!Report methodsFor: 'no messages' stamp: 'AS 5/25/2023 17:39:16'!
lines

	^lines! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 17:40:03' prior: 50697382!
test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)
! !
!ReceptiveAccountTest methodsFor: 'tests' stamp: 'AS 5/25/2023 17:40:18' prior: 50697394!
test11AccountSummaryWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report lines at: 3)
! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 17:40:22'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:40:22'!
ERROR!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:40:22'!
ERROR!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:40:30'!
ERROR!
!AccountSummary methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 17:41:15' prior: 50697329!
initializeOn: anAccount
	
	lines := OrderedCollection new.
	
	anAccount reportOn: self.
	
	lines add: 'Balance = ', anAccount balance asString.
	! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:42:19'!
PASSED!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:42:20'!
FAILURE!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:42:20'!
FAILURE!

report lines!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:43:44'!
FAILURE!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:43:58'!
PASSED!

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:44:02'!
PASSED!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:44:02'!
FAILURE!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:44:02'!
FAILURE!
!AccountSummary methodsFor: 'transactions' stamp: 'AS 5/25/2023 17:44:24' prior: 50697377!
writeDeposit: aValue

	lines add: 'Depósito por ', aValue asString.! !

!testRun: #ReceptiveAccountTest #test01ReceptiveAccountHaveZeroAsBalanceWhenCreated stamp: 'AS 5/25/2023 17:44:27'!
PASSED!

!testRun: #ReceptiveAccountTest #test02DepositIncreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:44:27'!
PASSED!

!testRun: #ReceptiveAccountTest #test03WithdrawDecreasesBalanceOnTransactionValue stamp: 'AS 5/25/2023 17:44:27'!
PASSED!

!testRun: #ReceptiveAccountTest #test04WithdrawValueMustBePositive stamp: 'AS 5/25/2023 17:44:27'!
PASSED!

!testRun: #ReceptiveAccountTest #test05ReceptiveAccountKnowsRegisteredTransactions stamp: 'AS 5/25/2023 17:44:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test06ReceptiveAccountDoNotKnowNotRegisteredTransactions stamp: 'AS 5/25/2023 17:44:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test07AccountKnowsItsTransactions stamp: 'AS 5/25/2023 17:44:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test08TransferIncreasesBalanceOfDestinationAccountAndDecreasesBalanceOfSourceAccountOnTransactionValue stamp: 'AS 5/25/2023 17:44:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test09TransferDepositKnowsTransferWithdrawAndViceversa stamp: 'AS 5/25/2023 17:44:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 17:44:28'!
PASSED!

!testRun: #ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 17:44:28'!
PASSED!
!Withdraw methodsFor: 'nil' stamp: 'AS 5/25/2023 19:30:00' overrides: 50697128!
reportOn: aReport
	
	aReport writeWithdraw: value! !
!AccountSummary methodsFor: 'transactions' stamp: 'AS 5/25/2023 19:30:32'!
writeWithdraw: aValue

	lines add: 'Extracción por ', aValue asString.! !

TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!

!classDefinition: #ReportTest category: 'Portfolio-Solucion' stamp: 'AS 5/25/2023 19:31:01'!
TestCase subclass: #ReportTest
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'Portfolio-Solucion'!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:35:16'!
test01AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)! !

!methodRemoval: ReceptiveAccountTest #test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:35:22'!
test10AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)
!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:35:36'!
test02AccountSummaryWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report lines at: 3)
! !

!methodRemoval: ReceptiveAccountTest #test11AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 19:35:42'!
test11AccountSummaryWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report lines at: 3)
!

!methodRemoval: AccountSummary #writeWithdraw: stamp: 'AS 5/25/2023 19:36:20'!
writeWithdraw: aValue

	lines add: 'Extracción por ', aValue asString.!

!methodRemoval: Withdraw #reportOn: stamp: 'AS 5/25/2023 19:36:28'!
reportOn: aReport
	
	aReport writeWithdraw: value!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:38:27'!
test03AccountSummaryWithWithdrawShouldReturnWithdrawLines

	| account report |
	
	account := ReceptiveAccount  new.

	Withdraw register: 100 on: account.
	Withdraw register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Extracción por 100'.
	self assert: report lines includes: 'Extracción por 150'.
	self assert: 'Balance = -250' equals: (report lines at: 3)
! !

!testRun: #ReportTest #test03AccountSummaryWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:38:30'!
ERROR!
!Withdraw methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 19:38:50' overrides: 50697128!
reportOn: aReport 
	self shouldBeImplemented.! !
!Withdraw methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 19:39:13' prior: 50697758 overrides: 50697128!
reportOn: aReport 
	
	aReport writeWithdraw: value! !

!testRun: #ReportTest #test03AccountSummaryWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:39:14'!
ERROR!
!AccountSummary methodsFor: 'transactions' stamp: 'AS 5/25/2023 19:39:26'!
writeWithdraw: aValue 
	self shouldBeImplemented.! !
!AccountSummary methodsFor: 'transactions' stamp: 'AS 5/25/2023 19:39:59' prior: 50697772!
writeWithdraw: aValue 
	
	lines add: 'Extracción por ', aValue asString! !

!testRun: #ReportTest #test03AccountSummaryWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:40:01'!
PASSED!

!testRun: #ReportTest #test01AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:40:01'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 19:40:01'!
PASSED!

!testRun: #ReportTest #test03AccountSummaryWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:40:01'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:43:31'!
test04AccountSummaryWithTransferShouldReturnTransferLines

	| sourceAccount destinationAccount sourceReport destinationReport |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.

	Transfer register: 100 from: sourceAccount to: destinationAccount.
		
	sourceReport := AccountSummary on: sourceAccount.
	destinationReport := AccountSummary on: destinationAccount.
	
	self assert: sourceReport lines includes: 'Salida por transferencia de 100'.
	self assert: 'Balance = -100' equals: (sourceReport lines at: 2).
	self assert: destinationReport lines includes: 'Entrada por transferencia de 100'.
	self assert: 'Balance = 100' equals: (destinationReport lines at: 2).	
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:43:43' prior: 50697797!
test04AccountSummaryWithTransferShouldReturnTransferLines

	| sourceAccount destinationAccount sourceAccountReport destinationReport |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.

	Transfer register: 100 from: sourceAccount to: destinationAccount.
		
	sourceAccountReport := AccountSummary on: sourceAccount.
	destinationReport := AccountSummary on: destinationAccount.
	
	self assert: sourceAccountReport lines includes: 'Salida por transferencia de 100'.
	self assert: 'Balance = -100' equals: (sourceAccountReport lines at: 2).
	self assert: destinationReport lines includes: 'Entrada por transferencia de 100'.
	self assert: 'Balance = 100' equals: (destinationReport lines at: 2).	
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:43:54' prior: 50697822!
test04AccountSummaryWithTransferShouldReturnTransferLines

	| sourceAccount destinationAccount sourceAccountReport destinationAccountReport |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.

	Transfer register: 100 from: sourceAccount to: destinationAccount.
		
	sourceAccountReport := AccountSummary on: sourceAccount.
	destinationAccountReport := AccountSummary on: destinationAccount.
	
	self assert: sourceAccountReport lines includes: 'Salida por transferencia de 100'.
	self assert: 'Balance = -100' equals: (sourceAccountReport lines at: 2).
	self assert: destinationAccountReport lines includes: 'Entrada por transferencia de 100'.
	self assert: 'Balance = 100' equals: (destinationAccountReport lines at: 2).	
! !

!testRun: #ReportTest #test04AccountSummaryWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 19:43:58'!
ERROR!
!AccountTransaction methodsFor: 'balance' stamp: 'AS 5/25/2023 19:45:43' prior: 50697128!
reportOn: aReport
	
	aReport writeTransferWithdraw: self value! !

!testRun: #ReportTest #test04AccountSummaryWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 19:45:56'!
ERROR!
!AccountTransaction methodsFor: 'balance' stamp: 'AS 5/25/2023 19:46:49' prior: 50697879!
reportOn: aReport

	self subclassResponsibility ! !
!TransferWithdraw methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 19:47:25' overrides: 50697888!
reportOn: aReport

	aReport writeTransferWithdraw: transfer value! !
!AccountSummary methodsFor: 'transactions' stamp: 'AS 5/25/2023 19:47:51'!
writeTransferWithdraw: aValue 
	
	lines add: 'Salida por transferencia de ', aValue asString! !
!AccountSummary methodsFor: 'transactions' stamp: 'AS 5/25/2023 19:48:12'!
writeTransferDeposit: aValue 
	
	lines add: 'Entrada por transferencia de ', aValue asString! !
!TransferDeposit methodsFor: 'as yet unclassified' stamp: 'AS 5/25/2023 19:48:30' overrides: 50697888!
reportOn: aReport

	aReport writeTransferDeposit: transfer value! !

!testRun: #ReportTest #test01AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:48:36'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 19:48:36'!
PASSED!

!testRun: #ReportTest #test03AccountSummaryWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:48:36'!
PASSED!

!testRun: #ReportTest #test04AccountSummaryWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 19:48:36'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:52:08'!
test01AccountSummaryOnEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)! !

!methodRemoval: ReportTest #test01AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:52:08'!
test01AccountSummaryFromEmptyAccountShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:52:32'!
test02AccountSummaryOnAccountWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report lines at: 3)
! !

!methodRemoval: ReportTest #test02AccountSummaryWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 19:52:32'!
test02AccountSummaryWithDepositShouldReturnDepositLines

	| account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Deposit register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Depósito por 150'.
	self assert: 'Balance = 250' equals: (report lines at: 3)
!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:52:44'!
test03AccountSummaryOnAccountWithWithdrawShouldReturnWithdrawLines

	| account report |
	
	account := ReceptiveAccount  new.

	Withdraw register: 100 on: account.
	Withdraw register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Extracción por 100'.
	self assert: report lines includes: 'Extracción por 150'.
	self assert: 'Balance = -250' equals: (report lines at: 3)
! !

!methodRemoval: ReportTest #test03AccountSummaryWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:52:44'!
test03AccountSummaryWithWithdrawShouldReturnWithdrawLines

	| account report |
	
	account := ReceptiveAccount  new.

	Withdraw register: 100 on: account.
	Withdraw register: 150 on: account.
	
	report := AccountSummary on: account.
	
	self assert: report lines includes: 'Extracción por 100'.
	self assert: report lines includes: 'Extracción por 150'.
	self assert: 'Balance = -250' equals: (report lines at: 3)
!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:52:55'!
test04AccountSummaryOnAccountWithTransferShouldReturnTransferLines

	| sourceAccount destinationAccount sourceAccountReport destinationAccountReport |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.

	Transfer register: 100 from: sourceAccount to: destinationAccount.
		
	sourceAccountReport := AccountSummary on: sourceAccount.
	destinationAccountReport := AccountSummary on: destinationAccount.
	
	self assert: sourceAccountReport lines includes: 'Salida por transferencia de 100'.
	self assert: 'Balance = -100' equals: (sourceAccountReport lines at: 2).
	self assert: destinationAccountReport lines includes: 'Entrada por transferencia de 100'.
	self assert: 'Balance = 100' equals: (destinationAccountReport lines at: 2).	
! !

!methodRemoval: ReportTest #test04AccountSummaryWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 19:52:55'!
test04AccountSummaryWithTransferShouldReturnTransferLines

	| sourceAccount destinationAccount sourceAccountReport destinationAccountReport |
	
	sourceAccount := ReceptiveAccount  new.
	destinationAccount := ReceptiveAccount  new.

	Transfer register: 100 from: sourceAccount to: destinationAccount.
		
	sourceAccountReport := AccountSummary on: sourceAccount.
	destinationAccountReport := AccountSummary on: destinationAccount.
	
	self assert: sourceAccountReport lines includes: 'Salida por transferencia de 100'.
	self assert: 'Balance = -100' equals: (sourceAccountReport lines at: 2).
	self assert: destinationAccountReport lines includes: 'Entrada por transferencia de 100'.
	self assert: 'Balance = 100' equals: (destinationAccountReport lines at: 2).	
!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:53:38'!
test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero

	| account report |
	
	account := ReceptiveAccount  new.

	report := AccountSummary on: account.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:53:50' prior: 50698074!
test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero

	| portfolio report |
	
	portfolio := ReceptiveAccount  new.

	report := AccountSummary on: portfolio.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:54:12' prior: 50698086!
test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero

	| portfolio report |
	
	portfolio := Portfolio  new.

	report := AccountSummary on: portfolio.
	
	self assert: 1 equals: report lines size.	
	self assert: 'Balance = 0' equals: (report lines at: 1)! !

!testRun: #ReportTest #test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:54:13'!
ERROR!
!Portfolio methodsFor: 'reports' stamp: 'AS 5/25/2023 19:54:19'!
reportOn: anAccountSummary 
	self shouldBeImplemented.! !
!Portfolio methodsFor: 'reports' stamp: 'AS 5/25/2023 19:54:58' prior: 50698113!
reportOn: aReport 
	
	! !

!testRun: #ReportTest #test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:55:02'!
PASSED!

!testRun: #ReportTest #test01AccountSummaryOnEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:55:02'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryOnAccountWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 19:55:02'!
PASSED!

!testRun: #ReportTest #test03AccountSummaryOnAccountWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 19:55:02'!
PASSED!

!testRun: #ReportTest #test04AccountSummaryOnAccountWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 19:55:03'!
PASSED!

!testRun: #ReportTest #test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 19:55:03'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 19:58:17'!
test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines

	| portfolio account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Withdraw register: 70 on: account.
	
	portfolio := Portfolio new.
	portfolio add: account.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = 30' equals: (report lines at: 3)
! !

!testRun: #ReportTest #test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 19:58:19'!
FAILURE!
!Portfolio methodsFor: 'reports' stamp: 'AS 5/25/2023 19:59:13' prior: 50698118!
reportOn: aReport 
		
	"transactions do: [ :transaction | transaction reportOn: aReport ].				"! !
!Portfolio methodsFor: 'reports' stamp: 'AS 5/25/2023 20:00:44' prior: 50698168!
reportOn: aReport 
		
	accounts do: [ :account | account reportOn: aReport ].
	"transactions do: [ :transaction | transaction reportOn: aReport ].				"! !

!testRun: #ReportTest #test01AccountSummaryOnEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 20:00:54'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryOnAccountWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:00:54'!
PASSED!

!testRun: #ReportTest #test03AccountSummaryOnAccountWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 20:00:54'!
PASSED!

!testRun: #ReportTest #test04AccountSummaryOnAccountWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 20:00:54'!
PASSED!

!testRun: #ReportTest #test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 20:00:54'!
PASSED!

!testRun: #ReportTest #test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:00:54'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:02:07' prior: 50698146!
test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines

	| portfolio account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Withdraw register: 70 on: account.
	"Transfer register: 60 from: "
	
	portfolio := Portfolio new.
	portfolio add: account.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = 30' equals: (report lines at: 3)
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:02:15' prior: 50698207!
test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines

	| portfolio sourceAccount report |
	
	sourceAccount := ReceptiveAccount  new.

	Deposit register: 100 on: sourceAccount.
	Withdraw register: 70 on: sourceAccount.
	"Transfer register: 60 from: "
	
	portfolio := Portfolio new.
	portfolio add: sourceAccount.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = 30' equals: (report lines at: 3)
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:03:55' prior: 50698226!
test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines

	| portfolio account1 account2 report |
	
	account1 := ReceptiveAccount  new.
	account2 := ReceptiveAccount  new.

	Deposit register: 100 on: account1.
	Withdraw register: 70 on: account1.
	Transfer register: 60 from: account1 to: account2.
	
	portfolio := Portfolio new.
	portfolio add: account1.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: report lines includes: 'Salida por transferencia de 60'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
! !

!testRun: #ReportTest #test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:03:57'!
PASSED!

!testRun: #ReportTest #test01AccountSummaryOnEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 20:03:57'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryOnAccountWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:03:57'!
PASSED!

!testRun: #ReportTest #test03AccountSummaryOnAccountWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 20:03:57'!
PASSED!

!testRun: #ReportTest #test04AccountSummaryOnAccountWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 20:03:57'!
PASSED!

!testRun: #ReportTest #test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 20:03:57'!
PASSED!

!testRun: #ReportTest #test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:03:57'!
PASSED!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:04:49'!
test06AccountSummaryOnPortfolioShouldReturnAccountTransactions

	| portfolio account1 account2 report |
	
	account1 := ReceptiveAccount  new.
	account2 := ReceptiveAccount  new.

	Deposit register: 100 on: account1.
	Withdraw register: 70 on: account1.
	Transfer register: 60 from: account1 to: account2.
	
	portfolio := Portfolio new.
	portfolio add: account1.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: report lines includes: 'Salida por transferencia de 60'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
! !

!methodRemoval: ReportTest #test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:04:49'!
test06AccountSummaryOnPortfolioWithDepositShouldReturnDepositLines

	| portfolio account1 account2 report |
	
	account1 := ReceptiveAccount  new.
	account2 := ReceptiveAccount  new.

	Deposit register: 100 on: account1.
	Withdraw register: 70 on: account1.
	Transfer register: 60 from: account1 to: account2.
	
	portfolio := Portfolio new.
	portfolio add: account1.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: report lines includes: 'Salida por transferencia de 60'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:05:39'!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio account1 account2 report |
	
	account1 := ReceptiveAccount  new.
	account2 := ReceptiveAccount  new.

	Deposit register: 100 on: account1.
	Withdraw register: 70 on: account1.
	Transfer register: 60 from: account1 to: account2.
	
	portfolio := Portfolio new.
	portfolio add: account1.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: report lines includes: 'Salida por transferencia de 60'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:08:25' prior: 50698346!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio childPortfolio account1 account2 report |
	
	account1 := ReceptiveAccount  new.
	account2 := ReceptiveAccount  new.

	Deposit register: 100 on: account1.
	Withdraw register: 70 on: account1.
	
	portfolio := Portfolio new.	
	
	childPortfolio := Portfolio new.
	portfolio add: account1.
	portfolio add: childPortfolio.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:08:44' prior: 50698369!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio childPortfolio account1 report |
	
	account1 := ReceptiveAccount  new.

	Deposit register: 100 on: account1.
	Withdraw register: 70 on: account1.
	
	portfolio := Portfolio new.	
	
	childPortfolio := Portfolio new.
	portfolio add: account1.
	portfolio add: childPortfolio.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:08:47' prior: 50698391!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio childPortfolio account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Withdraw register: 70 on: account.
	
	portfolio := Portfolio new.	
	
	childPortfolio := Portfolio new.
	portfolio add: account.
	portfolio add: childPortfolio.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = -30' equals: (report lines at: 4)
! !
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:10:27' prior: 50698412!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio childPortfolio account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Withdraw register: 70 on: account.
	
	portfolio := Portfolio new.	
	
	childPortfolio := Portfolio new.
	childPortfolio add: account.
	portfolio add: childPortfolio.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = 30' equals: (report lines at: 4)
! !

!testRun: #ReportTest #test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions stamp: 'AS 5/25/2023 20:10:28'!
ERROR!
!ReportTest methodsFor: 'test' stamp: 'AS 5/25/2023 20:10:50' prior: 50698433!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio childPortfolio account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Withdraw register: 70 on: account.
	
	portfolio := Portfolio new.	
	
	childPortfolio := Portfolio new.
	childPortfolio add: account.
	portfolio add: childPortfolio.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = 30' equals: (report lines at: 3)
! !

!testRun: #ReportTest #test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test01AccountSummaryOnEmptyAccountShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test02AccountSummaryOnAccountWithDepositShouldReturnDepositLines stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test03AccountSummaryOnAccountWithWithdrawShouldReturnWithdrawLines stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test04AccountSummaryOnAccountWithTransferShouldReturnTransferLines stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test05AccountSummaryOnEmptyPortfolioShouldReturnOnlyBalanceLineWithZero stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test06AccountSummaryOnPortfolioShouldReturnAccountTransactions stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!testRun: #ReportTest #test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions stamp: 'AS 5/25/2023 20:10:59'!
PASSED!

!methodRemoval: ReportTest #test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions stamp: 'AS 5/25/2023 20:14:52'!
test07AccountSummaryOnPortfolioTreeShouldReturnAllTransactions

	| portfolio childPortfolio account report |
	
	account := ReceptiveAccount  new.

	Deposit register: 100 on: account.
	Withdraw register: 70 on: account.
	
	portfolio := Portfolio new.	
	
	childPortfolio := Portfolio new.
	childPortfolio add: account.
	portfolio add: childPortfolio.

	report := AccountSummary on: portfolio.
	
	self assert: report lines includes: 'Depósito por 100'.
	self assert: report lines includes: 'Extracción por 70'.
	self assert: 'Balance = 30' equals: (report lines at: 3)
!